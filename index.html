<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="坚定 坚持 坚强">
<meta property="og:type" content="website">
<meta property="og:title" content="FJBQ">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="FJBQ">
<meta property="og:description" content="坚定 坚持 坚强">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="FJBQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>FJBQ</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="FJBQ" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">FJBQ</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/30/%E3%80%90UE4%E3%80%91%E5%B0%8F%E7%9F%A5%E8%AF%86%E3%80%81%E9%97%AE%E9%A2%98%20%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/30/%E3%80%90UE4%E3%80%91%E5%B0%8F%E7%9F%A5%E8%AF%86%E3%80%81%E9%97%AE%E9%A2%98%20%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">【UE4】小知识 / 问题 汇总</a>
        </h2>

        <div class="post-meta">
          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-30 21:09:55" itemprop="dateCreated datePublished" datetime="2023-12-30T21:09:55+08:00">2023-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-03 14:10:48" itemprop="dateModified" datetime="2023-12-03T14:10:48+08:00">2023-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UE4/" itemprop="url" rel="index"><span itemprop="name">UE4</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>记录一些 UE4 常用的知识</strong></p>
<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出日志到文件中</span></span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出到屏幕上</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">20</span>, FColor::Yellow, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有时候要输出一下 FSting</span></span><br><span class="line">FString fs = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;%s&quot;</span>), *fs);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><h3 id="获取，设置-Actor-的位置和旋转"><a href="#获取，设置-Actor-的位置和旋转" class="headerlink" title="获取，设置 Actor 的位置和旋转"></a>获取，设置 Actor 的位置和旋转</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FVector NewLocation = <span class="built_in">GetActorLocation</span>();</span><br><span class="line">FRotator NewRotation = <span class="built_in">GetActorRotation</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetActorLocationAndRotation</span>(NewLocation, NewRotation);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些函数都是 Actor 的成员函数，继承后直接用就行了</span></span><br></pre></td></tr></table></figure>



<h3 id="获取-GameState"><a href="#获取-GameState" class="headerlink" title="获取 GameState"></a>获取 GameState</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AMyGameStateBase* GS = <span class="built_in">Cast</span>&lt;AMyGameStateBase&gt;(<span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetGameState</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">GetWorld</span>() 是 Actor 里面的函数；</span><br></pre></td></tr></table></figure>



<h3 id="获取-GameMode"><a href="#获取-GameMode" class="headerlink" title="获取 GameMode"></a>获取 GameMode</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kismet/GameplayStatics.h&quot;</span></span></span><br><span class="line"><span class="type">const</span> AMyGameModeBase* GM = <span class="built_in">Cast</span>&lt;AMyGameModeBase&gt;(UGameplayStatics::<span class="built_in">GetGameMode</span>(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line">AMyGameModeBase* GM = <span class="built_in">Cast</span>&lt;AMyGameModeBase&gt;(<span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetAuthGameMode</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：(GetDefaultGameMode() 是 AGameStateBase 里面的)</span></span><br><span class="line"><span class="type">const</span> AMyGameModeBase* GM = <span class="built_in">Cast</span>&lt;AMyGameModeBase&gt;(<span class="built_in">GetDefaultGameMode</span>());</span><br></pre></td></tr></table></figure>



<h3 id="通过反射，直接获取蓝图中配置的信息"><a href="#通过反射，直接获取蓝图中配置的信息" class="headerlink" title="通过反射，直接获取蓝图中配置的信息"></a>通过反射，直接获取蓝图中配置的信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FString AIPath = <span class="string">&quot;Blueprint&#x27;&quot;</span>;</span><br><span class="line">AIPath.<span class="built_in">Append</span>(M_SoldierInfoList[i].<span class="built_in">ToString</span>());</span><br><span class="line">AIPath.<span class="built_in">Append</span>(<span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">UClass* AIClass = <span class="built_in">LoadClass</span>&lt;AAICharacter_Base&gt;(<span class="literal">NULL</span>, *AIPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (AIClass)</span><br><span class="line">&#123;</span><br><span class="line">    AAICharacter_Base* AI_Base = <span class="built_in">Cast</span>&lt;AAICharacter_Base&gt;(AIClass-&gt;<span class="built_in">GetDefaultObject</span>());</span><br><span class="line">    <span class="keyword">if</span> (AI_Base)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">// 通过 GetDefaultObject() 获取到的 AI_Base 就是蓝图本身的这个Object；</span></span><br><span class="line">    	<span class="comment">// 然后在这里就可以直接获取到蓝图身上的东西了（我们可以往蓝图上面配置东西）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><h3 id="从-c-中加载-UI"><a href="#从-c-中加载-UI" class="headerlink" title="从 c++ 中加载 UI"></a>从 c++ 中加载 UI</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">FString HUDClassLoadPath = <span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Blueprint&#x27;/Game/Blueprints/HUD.HUD_C&#x27;&quot;</span>));</span><br><span class="line"><span class="keyword">auto</span> MyUIClass = <span class="built_in">LoadClass</span>&lt;UUserWidget&gt;(<span class="literal">NULL</span>, *HUDClassLoadPath);</span><br><span class="line"><span class="keyword">if</span> (MyUIClass != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    UUserWidget* MyUI = <span class="built_in">CreateWidget</span>&lt;UUserWidget&gt;(<span class="built_in">GetWorld</span>(), MyUIClass);</span><br><span class="line">    <span class="keyword">if</span> (MyUI != <span class="literal">nullptr</span>) MyUI-&gt;<span class="built_in">AddToViewport</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line">FString UiPath = <span class="built_in">TEXT</span>(<span class="string">&quot;/Script/UMGEditor.WidgetBlueprint&#x27;/Game/Blueprints/HUD.HUD_C&#x27;&quot;</span>);<span class="comment">//动态加载UI 类</span></span><br><span class="line">UClass* MyUIClass = <span class="built_in">LoadClass</span>&lt;UUserWidget&gt;(<span class="literal">nullptr</span>, *UiPath);</span><br><span class="line"><span class="keyword">if</span> (MyUIClass)</span><br><span class="line">&#123;</span><br><span class="line">	UUserWidget* MyUI = UWidgetBlueprintLibrary::<span class="built_in">Create</span>(GWorld, MyUIClass, <span class="literal">nullptr</span>);<span class="comment">//创建蓝图添加到窗口</span></span><br><span class="line">	MyUI-&gt;<span class="built_in">AddToViewport</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 需要包含头文件：</span></span><br><span class="line"><span class="comment">#include &quot;Blueprint/UserWidget.h&quot;</span></span><br><span class="line"><span class="comment">#include &quot;Blueprint/WidgetBlueprintLibrary.h&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 两种方法都得在当前项目的 .Build.cs 文件中检查是否有包含 &quot;UMG&quot; 模块，没有的话需要添加上去，这样才能编译通过；</span></span><br><span class="line"><span class="comment">PublicDependencyModuleNames.AddRange(new string[] &#123; &quot;Core&quot;, &quot;CoreUObject&quot;, &quot;Engine&quot;, &quot;InputCore&quot;, &quot;HeadMountedDisplay&quot;, &quot;UMG&quot; &#125;);</span></span><br><span class="line"><span class="comment">（看到最后一个没有~）</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure>



<h3 id="在-C-代码中设置-GameMode"><a href="#在-C-代码中设置-GameMode" class="headerlink" title="在 C++ 代码中设置 GameMode"></a>在 C++ 代码中设置 GameMode</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestGameGameMode 构造函数中设置对应的 GameMode 的参数,当然要先引入下面对应类的头文件</span></span><br><span class="line">ATestGameGameMode::<span class="built_in">ATestGameGameMode</span>()</span><br><span class="line">&#123;</span><br><span class="line">	GameStateClass = ATestGameState::<span class="built_in">StaticClass</span>();</span><br><span class="line">	PlayerControllerClass = ATestPlayerController::<span class="built_in">StaticClass</span>();</span><br><span class="line">	PlayerStateClass = ATestPlayerState::<span class="built_in">StaticClass</span>();</span><br><span class="line">	HUDClass = ATestHUD::<span class="built_in">StaticClass</span>();</span><br><span class="line">	DefaultPawnClass = ATestPawn::<span class="built_in">StaticClass</span>();</span><br><span class="line">	SpectatorClass = ATest_SpectatorPawn::<span class="built_in">StaticClass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="C-类-加载-蓝图类"><a href="#C-类-加载-蓝图类" class="headerlink" title="C++类 加载 蓝图类"></a>C++类 加载 蓝图类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FString CharacterClassLoadPath = <span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Blueprint&#x27;/Game/ThirdPersonCPP/Blueprints/ThirdPersonCharacter.ThirdPersonCharacter_C&#x27;&quot;</span>));	<span class="comment">// 路径</span></span><br><span class="line">DefaultPawnClass = <span class="built_in">LoadClass</span>&lt;AMyProject02Character&gt;(<span class="literal">NULL</span>, *CharacterClassLoadPath);		<span class="comment">// 动态加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里需要注意这个 TEXT 里面的规则... 真的是很烦...</span></span><br><span class="line"><span class="comment">// Blueprint&#x27;路径&#x27;；最后的蓝图类是 blueprintname.blueprintname_C</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意字符串的拼接</span></span><br><span class="line">	FString s = <span class="string">&quot;Blueprint&#x27;&quot;</span>;</span><br><span class="line">	s.<span class="built_in">Append</span>(ClassPath.<span class="built_in">ToString</span>());	<span class="comment">// ClassPath 是 FSoftClassPath</span></span><br><span class="line">	s.<span class="built_in">Append</span>(<span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">	UClass* BP_ProjectileClass = <span class="built_in">LoadClass</span>&lt;AProjectile&gt;(<span class="literal">NULL</span>, *s);</span><br></pre></td></tr></table></figure>



<h2 id="创建销毁"><a href="#创建销毁" class="headerlink" title="创建销毁"></a>创建销毁</h2><h3 id="创建组件，初始化组件，使用组件"><a href="#创建组件，初始化组件，使用组件" class="headerlink" title="创建组件，初始化组件，使用组件"></a>创建组件，初始化组件，使用组件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--------------- .h 文件-----------------*/</span> 	</span><br><span class="line">UStaticMeshComponent *VisualMesh = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------- .cpp 文件-----------------*/</span> 	</span><br><span class="line"><span class="comment">// 一般在构造函数里面做</span></span><br><span class="line">VisualMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;VisualMesh&quot;</span>));	<span class="comment">// 创建组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 VisualMesh 作为根组件</span></span><br><span class="line">RootComponent = <span class="built_in">Cast</span>&lt;USceneComponent&gt;(VisualMesh);						</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将组件附在另一个组件下面</span></span><br><span class="line">Box-&gt;<span class="built_in">SetupAttachment</span>(VisualMesh);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置碰撞预设</span></span><br><span class="line">VisualMesh-&gt;<span class="built_in">SetCollisionProfileName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;BlockAllDynamic&quot;</span>));		</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置模型(注意，ConstructorHelpers::FObjectFinder 只能在构造函数中用，否则会崩溃)</span></span><br><span class="line"><span class="function"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; <span class="title">CubeVisualAsset</span><span class="params">(TEXT(<span class="string">&quot;/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube&quot;</span>))</span></span>;	<span class="comment">// 注意路径格式</span></span><br><span class="line"><span class="keyword">if</span> (CubeVisualAsset.<span class="built_in">Succeeded</span>())</span><br><span class="line">&#123;</span><br><span class="line">	VisualMesh-&gt;<span class="built_in">SetStaticMesh</span>(CubeVisualAsset.Object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置位置</span></span><br><span class="line">VisualMesh-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>



<h3 id="创建、销毁Actor"><a href="#创建、销毁Actor" class="headerlink" title="创建、销毁Actor"></a>创建、销毁Actor</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AMyBox *mybox = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AMyBox&gt;(SpawnLocation, SpawnRotation);	<span class="comment">// 创建</span></span><br><span class="line">mybox-&gt;<span class="built_in">destroy</span>();	<span class="comment">// 销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个特效类对象，附在MyBox类对象上面（这里的this是MyBox的对象）</span></span><br><span class="line">AMyEffect *MyEffect = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AMyEffect&gt;();</span><br><span class="line">MyEffect-&gt;<span class="built_in">AttachToActor</span>(<span class="keyword">this</span>, FAttachmentTransformRules::KeepRelativeTransform);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟创建 Actor，用于完整的创建，放置还未初始化就被销毁的情况</span></span><br><span class="line">	AProjectile* NewProjectile = <span class="built_in">Cast</span>&lt;AProjectile&gt;(UGameplayStatics::<span class="built_in">BeginDeferredActorSpawnFromClass</span>(<span class="keyword">this</span>, BP_ProjectileClass, SpawnTransform, ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn));</span><br><span class="line">	<span class="keyword">if</span> (NewProjectile)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 在这里就是完成创建之前要做的事情</span></span><br><span class="line">		NewProjectile-&gt;<span class="built_in">SetOwner</span>(<span class="keyword">this</span>);</span><br><span class="line">		NewProjectile-&gt;<span class="built_in">Init</span>(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	UGameplayStatics::<span class="built_in">FinishSpawningActor</span>(NewProjectile, SpawnTransform);</span><br></pre></td></tr></table></figure>



<h3 id="粒子效果的使用实例"><a href="#粒子效果的使用实例" class="headerlink" title="粒子效果的使用实例"></a>粒子效果的使用实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UParticleSystem</span>* PickUpFX;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UParticleSystem</span>* StaticFX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actor 消失，特效不消失</span></span><br><span class="line">UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="keyword">this</span>, PickUpFX, <span class="built_in">GetActorLocation</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// MeshComp 是一个组件，特效附着在组件上面，Actor销毁，特效也销毁</span></span><br><span class="line">UGameplayStatics::<span class="built_in">SpawnEmitterAttached</span>(StaticFX, MeshComp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一篇将了随着Actor销毁，特效销毁/不销毁 的两种做法。</span></span><br><span class="line">https:<span class="comment">//blog.csdn.net/weixin_36728104/article/details/82893670</span></span><br></pre></td></tr></table></figure>





<h2 id="数学计算"><a href="#数学计算" class="headerlink" title="数学计算"></a>数学计算</h2><h3 id="计算两个位置的距离"><a href="#计算两个位置的距离" class="headerlink" title="计算两个位置的距离"></a>计算两个位置的距离</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FVector::<span class="built_in">Distance</span>(FVector1, Fvector2);</span><br></pre></td></tr></table></figure>

<h3 id="随机数的使用"><a href="#随机数的使用" class="headerlink" title="随机数的使用"></a>随机数的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kismet/KismetMathLibrary.h&quot;</span></span></span><br><span class="line"><span class="type">float</span> RandomX = UKismetMathLibrary::<span class="built_in">RandomFloatInRange</span>(MIN_X, MAX_X);</span><br></pre></td></tr></table></figure>

<h3 id="时间的使用"><a href="#时间的使用" class="headerlink" title="时间的使用"></a>时间的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的游戏时间</span></span><br><span class="line"><span class="type">double</span> CurrentTime = FDateTime::<span class="built_in">Now</span>().<span class="built_in">GetTimeOfDay</span>().<span class="built_in">GetTotalMilliseconds</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出年月日</span></span><br><span class="line">FDateTime tt = FDateTime::<span class="built_in">Now</span>();</span><br><span class="line"><span class="type">int</span> year = tt.<span class="built_in">GetYear</span>();</span><br><span class="line"><span class="type">int</span> month = tt.<span class="built_in">GetMonth</span>();</span><br><span class="line"><span class="type">int</span> day = tt.<span class="built_in">GetDay</span>();</span><br><span class="line"><span class="type">int</span> hour = tt.<span class="built_in">GetHour</span>();</span><br><span class="line"><span class="type">int</span> minute = tt.<span class="built_in">GetMinute</span>();</span><br><span class="line"><span class="type">int</span> second = tt.<span class="built_in">GetSecond</span>();</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;Time : %d, %d, %d, %d, %d, %d&quot;</span>), year, month, day, hour, minute, second);</span><br></pre></td></tr></table></figure>



<h2 id="定时器的使用"><a href="#定时器的使用" class="headerlink" title="定时器的使用"></a>定时器的使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个定时器 Handle，用于特效对象的延迟销毁</span></span><br><span class="line">FTimerHandle TimerHandle;</span><br><span class="line"><span class="built_in">GetWorldTimerManager</span>().<span class="built_in">SetTimer</span>(TimerHandle, <span class="keyword">this</span>, &amp;AMyEffect::OnDestroyed, <span class="number">2.0f</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测定时器是否活跃</span></span><br><span class="line"><span class="built_in">GetWorldTimerManager</span>().<span class="built_in">IsTimerActive</span>(M_TimerHandle) == <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清楚定时器</span></span><br><span class="line"><span class="built_in">GetWorldTimerManager</span>().<span class="built_in">ClearTimer</span>(M_TimerHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个可以看一下官方文档</span></span><br><span class="line">https:<span class="comment">//docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但其实关于定时，我们可以通过记录时间的方式来实现，这样更加简单。</span></span><br></pre></td></tr></table></figure>



<h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><h3 id="运行行为树"><a href="#运行行为树" class="headerlink" title="运行行为树"></a>运行行为树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">UBehaviorTreeComponent</span>* M_BehaviorTree;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">UBlackboardComponent</span>* M_Blackboard;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;BaseConfig&quot;</span>)</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">UBehaviorTree</span>* BTree = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">UBehaviorTree* <span class="title">AAICharacter_Base::GetBTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAIController_Base::RunAIBehaviorTree</span><span class="params">(APawn* InPawn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AAICharacter_Base* AI = <span class="built_in">Cast</span>&lt;AAICharacter_Base&gt;(InPawn);</span><br><span class="line">	<span class="keyword">if</span> (AI &amp;&amp; AI-&gt;<span class="built_in">GetBTree</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		M_Blackboard-&gt;<span class="built_in">InitializeBlackboard</span>(*AI-&gt;<span class="built_in">GetBTree</span>()-&gt;BlackboardAsset);		<span class="comment">// 初始化AI中的黑板，黑板是在行为树中的。</span></span><br><span class="line">		M_BehaviorTree-&gt;<span class="built_in">StartTree</span>(*AI-&gt;<span class="built_in">GetBTree</span>());									<span class="comment">// 开始运行行为树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用感知组件"><a href="#使用感知组件" class="headerlink" title="使用感知组件"></a>使用感知组件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Perception/AISenseConfig_Sight.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Perception/AIPerceptionComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UAISenseConfig_Sight</span>* SightConfig = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UAIPerceptionComponent</span>* M_AIPerception = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">AAIController::<span class="built_in">AAIController</span>()</span><br><span class="line">&#123;</span><br><span class="line">	M_AIPerception = <span class="built_in">CreateDefaultSubobject</span>&lt;UAIPerceptionComponent&gt;(<span class="string">&quot;AIPerception&quot;</span>);</span><br><span class="line">	SightConfig = <span class="built_in">CreateDefaultSubobject</span>&lt;UAISenseConfig_Sight&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AISightConfig&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span> (M_AIPerception)</span><br><span class="line">	&#123;</span><br><span class="line">		M_AIPerception-&gt;<span class="built_in">ConfigureSense</span>(*SightConfig);</span><br><span class="line">		M_AIPerception-&gt;<span class="built_in">SetDominantSense</span>(SightConfig-&gt;<span class="built_in">GetSenseImplementation</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意绑定感知函数不能在构造函数中，否则不生效，所以放在 BeginPlay 里面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAIController::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (M_AIPerception)</span><br><span class="line">	&#123;</span><br><span class="line">		M_AIPerception-&gt;OnTargetPerceptionUpdated.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AAIController::OnTargetPerceptionUpdated);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	UAIPerceptionSystem::<span class="built_in">RegisterPerceptionStimuliSource</span>(<span class="keyword">this</span>, UAISense_Sight::<span class="built_in">StaticClass</span>(), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 AI 感知组件的参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAIController_CloseCombat::InitAIPerception</span><span class="params">(APawn* InPawn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 写自己的设置参数逻辑</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意设置完需要重新配置一下，否则不生效！！！</span></span><br><span class="line">	M_AIPerception-&gt;<span class="built_in">ConfigureSense</span>(*SightConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="枚举的使用"><a href="#枚举的使用" class="headerlink" title="枚举的使用"></a>枚举的使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ECampType</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">	NONE,</span><br><span class="line">	RED		=	<span class="number">1</span>	<span class="built_in">UMETA</span>(DisplayName = <span class="string">&quot;Red&quot;</span>),</span><br><span class="line">	BLUE	=	<span class="number">2</span>	<span class="built_in">UMETA</span>(DisplayName = <span class="string">&quot;Blue&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举转换成字符串</span></span><br><span class="line">UEnum* <span class="type">const</span> CampTypeEnum = <span class="built_in">StaticEnum</span>&lt;ECampType&gt;();</span><br><span class="line">FString s = CampTypeEnum-&gt;<span class="built_in">GetDisplayNameTextByValue</span>(<span class="built_in">static_cast</span>&lt;uint8&gt;(ECampType::RED)).<span class="built_in">ToString</span>();</span><br></pre></td></tr></table></figure>



<h2 id="遍历-TMap"><a href="#遍历-TMap" class="headerlink" title="遍历 TMap"></a>遍历 TMap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TMap&lt;FString, <span class="type">int</span>&gt;::TConstIterator iter = _Map.<span class="built_in">CreateConstIterator</span>(); iter; ++iter)</span><br></pre></td></tr></table></figure>





<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="导入项目时，vs显示不支持？"><a href="#导入项目时，vs显示不支持？" class="headerlink" title="导入项目时，vs显示不支持？"></a>导入项目时，vs显示不支持？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答：vs版本不匹配，可以去网上找找 vs 和 ue 版本的匹配程度；我是：</span><br><span class="line">ue 4.24 &lt;=&gt; vs 2017</span><br><span class="line">ue 4.27 &lt;=&gt; vs 2022</span><br></pre></td></tr></table></figure>

<h2 id="换了之后-vs-编译时显示-sdk-有问题？"><a href="#换了之后-vs-编译时显示-sdk-有问题？" class="headerlink" title="换了之后 vs 编译时显示 sdk 有问题？"></a>换了之后 vs 编译时显示 sdk 有问题？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这个搞了好久...盲猜删<span class="number">2017</span>的时候给删掉了...</span><br><span class="line"></span><br><span class="line">报错信息：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Could not find NetFxSDK install dir; this will prevent SwarmInterface from installing.  Install a version of .NET Framework SDK at 4.6.0 or higher.	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">参考这篇文章：</span><br><span class="line">https:<span class="comment">//zhuanlan.zhihu.com/p/133456753</span></span><br></pre></td></tr></table></figure>





      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/13/games101/Lec%2015/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/13/games101/Lec%2015/" class="post-title-link" itemprop="url">【Games 101】Lec 15：光线追踪 3（辐射度量学，光传输，全局光照）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-13 13:16:57 / 修改时间：15:00:31" itemprop="dateCreated datePublished" datetime="2024-01-13T13:16:57+08:00">2024-01-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-15：Ray-Tracing-3-Light-Transport-Global-Illumination"><a href="#Lecture-15：Ray-Tracing-3-Light-Transport-Global-Illumination" class="headerlink" title="Lecture 15：Ray Tracing 3 (Light Transport &amp; Global Illumination)"></a>Lecture 15：Ray Tracing 3 (Light Transport &amp; Global Illumination)</h1><p>这节课讲的是 <strong>Light Transport &amp; Global Illumination</strong> 当然首先包含了上一节课最后的辐射度量学；</p>
<p>ps：这几节课是真的难…</p>
<h1 id="1-辐射度量学（Basic-radiometry）"><a href="#1-辐射度量学（Basic-radiometry）" class="headerlink" title="1. 辐射度量学（Basic radiometry）"></a>1. 辐射度量学（Basic radiometry）</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><strong>辐射度量学的动机：</strong></p>
<p>光源中定义L&#x3D;10，但是10代表的是什么无法确定，缺少单位。</p>
<p><strong>定义：</strong></p>
<p>辐射度量学就是<strong>在物理上准确度量光照</strong>的方法。</p>
<p>它定义了一系列的方法和单位，准确的定义了光在空间中的属性：</p>
<ul>
<li>Radiant flux（辐射通量）</li>
<li>intensity（辐射强度）</li>
<li>irradiance（辐射[照]度）</li>
<li>radiance（辐[射]亮度）</li>
</ul>
<h2 id="1-2-角，立体角（solid-angle），微分立体角"><a href="#1-2-角，立体角（solid-angle），微分立体角" class="headerlink" title="1.2 角，立体角（solid angle），微分立体角"></a>1.2 角，立体角（solid angle），微分立体角</h2><ol>
<li><strong>角 Angle：</strong> 圆上的弧长与半径的比值。</li>
</ol>
<p><img src="/images/Games101/15/01.png"></p>
<ol start="2">
<li><strong>立体角（solid angle）：球面上的面积和半径平方的比值。</strong>（弧度制在三维空间的延申）</li>
</ol>
<p><img src="/images/Games101/15/02.png"></p>
<ol start="3">
<li><strong>微分立体角（Differential）</strong></li>
</ol>
<p><img src="/images/Games101/15/03.png"></p>
<blockquote>
<p>dA 是球面上的微分面积，近似成长方形</p>
</blockquote>
<p>通过积分可以得到，整个球的立体角是 <strong>4π</strong> 。</p>
<p><img src="/images/Games101/15/04.png"></p>
<h2 id="1-3-Radiant-Energy-and-Flux-Power"><a href="#1-3-Radiant-Energy-and-Flux-Power" class="headerlink" title="1.3 Radiant Energy and Flux (Power)"></a>1.3 Radiant Energy and Flux (Power)</h2><h3 id="1-3-1-Radiant-Energy"><a href="#1-3-1-Radiant-Energy" class="headerlink" title="1.3.1 Radiant Energy"></a>1.3.1 Radiant Energy</h3><p><strong>定义：Radiant energy是一种电磁辐射的能量。它由 <strong>焦耳</strong>（J&#x3D;Joule）单位来度量，用符号</strong>Q<strong>来表示。</strong></p>
<p><img src="/images/Games101/15/05.png"></p>
<h3 id="1-3-2-Radient-Flux-Power"><a href="#1-3-2-Radient-Flux-Power" class="headerlink" title="1.3.2 Radient Flux(Power)"></a>1.3.2 Radient Flux(Power)</h3><p><strong>定义：</strong></p>
<ul>
<li><strong>Radient flux(Power) 是单位时间的发射出的、反射的、传播的和接收的能量。</strong></li>
<li>或者：<strong>单位时间辐射出光子的数量</strong></li>
</ul>
<p><img src="/images/Games101/15/06.png"></p>
<h2 id="1-4-与光相关的物理量"><a href="#1-4-与光相关的物理量" class="headerlink" title="1.4 与光相关的物理量"></a>1.4 与光相关的物理量</h2><p>主要是区别下面三种物理量：</p>
<ul>
<li><strong>Radiant Intensity</strong>：光源辐射出的能量；</li>
<li><strong>Irrdiance</strong>：物体表面接收的光的能量；</li>
<li><strong>Radiance</strong>：光线在传播过程中的能量；</li>
</ul>
<p><img src="/images/Games101/15/07.png"></p>
<h3 id="1-4-1-Radient-intensity"><a href="#1-4-1-Radient-intensity" class="headerlink" title="1.4.1 Radient intensity"></a>1.4.1 Radient intensity</h3><p><strong>定义：</strong></p>
<ul>
<li>Radient intensity是 <strong>每单位立体角</strong> 辐射的能量。</li>
</ul>
<p><img src="/images/Games101/15/08.png"></p>
<h3 id="1-4-2-Irradiance"><a href="#1-4-2-Irradiance" class="headerlink" title="1.4.2 Irradiance"></a>1.4.2 Irradiance</h3><p><strong>定义：</strong></p>
<ul>
<li><strong>Irradiance</strong> 是<strong>单位面积的辐射通量</strong>（面必须和光线<strong>垂直</strong>，否则要变成和投影面垂直的）。</li>
</ul>
<p><img src="/images/Games101/15/09.png"></p>
<p><strong>Irradiance 例子：</strong></p>
<ul>
<li>冬夏温度之分是因为点光源辐射的能量到达辐射点的角度不同步（阳光和不同区域的夹角不同），导致接收的能量不同。</li>
<li>Irradiance 会衰减（不是 Intensity 衰减）</li>
</ul>
<p><img src="/images/Games101/15/10.png"></p>
<h3 id="1-4-3-Radiance"><a href="#1-4-3-Radiance" class="headerlink" title="1.4.3 Radiance"></a>1.4.3 Radiance</h3><p>Radiance 描述光线在传播过程中的属性。</p>
<p><strong>定义：</strong></p>
<ul>
<li>单位面积，单位立体角接受的能力；</li>
<li>或者理解为：<strong>在单位面积，单位立体角 发出的能量</strong>；</li>
</ul>
<p><img src="/images/Games101/15/11.png"></p>
<p><strong>注意：</strong></p>
<p>因为 <strong>Irradiance</strong> 是<strong>单位面积的辐射通量</strong>，<strong>Intensity</strong> 是<strong>单位立体角发出的能量</strong>。</p>
<p>所以 Radiance是<strong>每单位立体角的 Irradiance</strong>，Radiance是<strong>每单位面积的正交 Intensity</strong>。</p>
<h4 id="1-4-3-1-Incident-Radiance"><a href="#1-4-3-1-Incident-Radiance" class="headerlink" title="1.4.3.1 Incident Radiance"></a>1.4.3.1 Incident Radiance</h4><p>Incident Radiance 是每<strong>单位立体角</strong>的<strong>到达</strong>表面的 <strong>Irradiance</strong>。</p>
<p><img src="/images/Games101/15/12.png"></p>
<h4 id="1-4-3-2-Exiting-Radiance"><a href="#1-4-3-2-Exiting-Radiance" class="headerlink" title="1.4.3.2 Exiting Radiance"></a>1.4.3.2 Exiting Radiance</h4><p>Exiting surface radiance 是<strong>每单位面积</strong>向某个角度辐射出的 <strong>Intensity</strong>（这里参考文章里面应该是写错了）。</p>
<p><img src="/images/Games101/15/13.png"></p>
<h2 id="1-5-Irradiance-和-Radiance"><a href="#1-5-Irradiance-和-Radiance" class="headerlink" title="1.5 Irradiance 和 Radiance"></a>1.5 Irradiance 和 Radiance</h2><p><strong>Irradiance</strong>：被区域 dA 吸收的所有的能量。</p>
<p><strong>Radiance</strong>：被区域 dA 的来自d ω 的能量（多了一个立体角）。</p>
<p><img src="/images/Games101/15/14.png"></p>
<h2 id="1-6-各向同性点光源-Isotropic-Point-Source"><a href="#1-6-各向同性点光源-Isotropic-Point-Source" class="headerlink" title="1.6 各向同性点光源 Isotropic Point Source"></a>1.6 各向同性点光源 Isotropic Point Source</h2><p>如果点光源均匀的辐射出光，则可以得到点光源的强度 <strong>I</strong> 如下所示。</p>
<p><img src="/images/Games101/15/15.png"></p>
<h1 id="2-双向反射分布函数-Bidirectional-Reflectance-Distribution-Function（BRDF）"><a href="#2-双向反射分布函数-Bidirectional-Reflectance-Distribution-Function（BRDF）" class="headerlink" title="2. 双向反射分布函数 Bidirectional Reflectance Distribution Function（BRDF）"></a>2. 双向反射分布函数 Bidirectional Reflectance Distribution Function（BRDF）</h1><p><strong>引入</strong> ：</p>
<ul>
<li>来自于 <strong>ωi 立体角</strong>的 <strong>Radiance</strong> 转化成 dA 接受的能量E，然后能量E会变成向着任何其他方向 ω 的 Radiance。</li>
</ul>
<p><strong>意义：</strong></p>
<ul>
<li><strong>BRDF</strong> 用于<strong>表示某个微小面积 dA 从某个微小立体角 dωi 接受的 Irradiance 会如何被分配到不同的立体角去。</strong></li>
</ul>
<p><strong>定义：</strong></p>
<p><strong>如下图所示，从来自 ωi 立体角的 Irradiance（dE(ωi))，经过单位面积吸收后，向某一立体角 ωr 发射出去，发射出去的 Radiance 是 dLr(x , ωr)</strong></p>
<p><img src="/images/Games101/15/16.png"></p>
<p><strong>BRDF 用于表示从每个入射方向进来的光线会每个向出射方向 ωr 反射的能量多少。</strong></p>
<p><strong>BRDF 就是任何一个出射方向的 Radiance 的微分 除以 在入射点上 Irradiance的微</strong>分，BRDF 如下所示。</p>
<p><img src="/images/Games101/15/17.png"></p>
<h2 id="2-1-反射方程（The-Reflection-Equation）"><a href="#2-1-反射方程（The-Reflection-Equation）" class="headerlink" title="2.1 反射方程（The Reflection Equation）"></a>2.1 反射方程（The Reflection Equation）</h2><p>BRDF 是描述光线对物体时如何作用的，所以可以<strong>用于定义不同的材质</strong>。</p>
<p><strong>把每一个方向对出射方向的贡献积分起来就会获得向某个方向反射出光照的结果。</strong></p>
<p><img src="/images/Games101/15/18.png"></p>
<p>反射radiance取决于入射radiance，而入射Radiance不仅取决于光源，还有<strong>被其他物体反射的光</strong>，具有递归关系。</p>
<p><img src="/images/Games101/15/19.png"></p>
<h2 id="2-2-渲染方程（The-Rendering-Equation）"><a href="#2-2-渲染方程（The-Rendering-Equation）" class="headerlink" title="2.2 渲染方程（The Rendering Equation）"></a>2.2 渲染方程（The Rendering Equation）</h2><p><strong>渲染方程</strong> &#x3D; <strong>加上自己辐射的 Radiance</strong> + <strong>反射方程</strong></p>
<p><img src="/images/Games101/15/20.png"></p>
<p>注意：</p>
<ul>
<li><p>这里默认所有的方向 ω 都是向外的。</p>
</li>
<li><p>而且此时考虑的照亮到这一点的都是光源</p>
</li>
</ul>
<p><strong>但是实际上照亮这一点的不仅仅有光源的 Radiance，还有可能是其他物体反射过来的 Radiance；</strong></p>
<p>如果<strong>考虑其他物体反射的radiance</strong>，就把反射物体和反射面当成光源，可以把渲染方程写成更通用的形式。</p>
<p><img src="/images/Games101/15/21.png"></p>
<p><strong>以上的式子可以简单的表达为：</strong></p>
<p><img src="/images/Games101/15/22.png"></p>
<p><strong>K为反射操作符，进一步简写为：</strong></p>
<p><img src="/images/Games101/15/23.png"></p>
<p>可以看出L是递归定义的。</p>
<h3 id="2-2-1-结论"><a href="#2-2-1-结论" class="headerlink" title="2.2.1 结论"></a>2.2.1 结论</h3><p>简写渲染方程（L&#x3D; E + K L）的目的是解出 L。</p>
<p><strong>解L的方法如下所示，其中K也可以理解成反射次数，反射次数越多，项越多，K^2 代表光弹射两次。</strong></p>
<p><img src="/images/Games101/15/24.png"></p>
<p><strong>全局光照 &#x3D; 直接光照（E） + 间接光照（KE + K^2E + K^3E + …）</strong></p>
<p><img src="/images/Games101/15/25.png"></p>
<p><strong>光栅化的着色一般只有 E+EK，而后面的间接光照部分光栅化难以做到，一般使用光线追踪（路径追踪）来进行计算。</strong></p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489/article/details/121655346?spm=1001.2014.3001.5502">图形学笔记（十三）光线追踪3——双向反射分布函数BRDF（反射方程、递归方程）、辐射度量学基础radiometry、立体角、Radiant Energy、Flux、Irrdiance、Radiance_irrdiance 测量仪-CSDN博客</a></p>
<p><strong>好难…</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/13/games101/Lec%2016/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/13/games101/Lec%2016/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-13 13:16:57 / 修改时间：13:17:07" itemprop="dateCreated datePublished" datetime="2024-01-13T13:16:57+08:00">2024-01-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/09/games101/Lec%2014/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/09/games101/Lec%2014/" class="post-title-link" itemprop="url">【Games 101】Lec 14：光线追踪 2（加速光线追踪 和 辐射度量学）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-09 22:42:57" itemprop="dateCreated datePublished" datetime="2024-01-09T22:42:57+08:00">2024-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-10 23:46:38" itemprop="dateModified" datetime="2024-01-10T23:46:38+08:00">2024-01-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-14：Ray-Tracing-2-Acceleration-Radiometry"><a href="#Lecture-14：Ray-Tracing-2-Acceleration-Radiometry" class="headerlink" title="Lecture 14：Ray Tracing 2 (Acceleration &amp; Radiometry)"></a>Lecture 14：Ray Tracing 2 (Acceleration &amp; Radiometry)</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这节课讲了 <strong>光线追踪的加速</strong> 和 辐射度量学；</p>
<p>这篇文章写的是光线追踪的加速，辐射度量学一起放在下一篇文章；</p>
<p>上篇文章讲了包围盒，这节课前面讲的是如何用包围盒加速光线追踪；</p>
<h1 id="均匀空间划分-Uniform-Spatial-Partitions-（Grids）"><a href="#均匀空间划分-Uniform-Spatial-Partitions-（Grids）" class="headerlink" title="均匀空间划分 Uniform Spatial Partitions （Grids）"></a>均匀空间划分 Uniform Spatial Partitions （Grids）</h1><h2 id="预处理-–-建立加速格子"><a href="#预处理-–-建立加速格子" class="headerlink" title="预处理 – 建立加速格子"></a>预处理 – 建立加速格子</h2><ul>
<li><strong>找到包围盒</strong></li>
<li><strong>创建格子</strong></li>
<li><strong>标记出和物体相交的格子</strong></li>
<li><img src="/images/Games101/14/01.png"></li>
</ul>
<h2 id="光线与场景求交点"><a href="#光线与场景求交点" class="headerlink" title="光线与场景求交点"></a>光线与场景求交点</h2><ul>
<li><strong>依次遍历光线穿过的格子</strong></li>
<li><strong>如果这个格子被标记，则说明这个格子里面有物体，那么就计算光线是否和这个格子里面的物体相交</strong></li>
<li><img src="/images/Games101/14/02.png"></li>
</ul>
<h2 id="均匀空间划分的结果"><a href="#均匀空间划分的结果" class="headerlink" title="均匀空间划分的结果"></a>均匀空间划分的结果</h2><p>格子太多和格子太少都是不好的。</p>
<ul>
<li>只有一个格子：没有加速效果。</li>
<li>格子特别密集：需要做很多光线与格子求交，加大开销。</li>
<li>下面是划分方式的经验之谈：</li>
<li><img src="/images/Games101/14/03.png"></li>
</ul>
<p>格子划分法适用于大小和空间<strong>均匀分布</strong>的大型对象集合（如下图所示）。</p>
<p><img src="/images/Games101/14/04.png"></p>
<p>但是此方法不适合于有很多空旷区域的场景（如下图所示），下面又称为 “teapot in stadium” 问题。（其实就是分布不均的场景，有的地方物体很密，有的地方物体很稀疏）</p>
<p><img src="/images/Games101/14/05.png"></p>
<h1 id="空间划分（Spatial-Partitions）"><a href="#空间划分（Spatial-Partitions）" class="headerlink" title="空间划分（Spatial Partitions）"></a>空间划分（Spatial Partitions）</h1><h2 id="空间划分的方式"><a href="#空间划分的方式" class="headerlink" title="空间划分的方式"></a>空间划分的方式</h2><p><img src="/images/Games101/14/06.png"></p>
<ul>
<li><strong>Oct-Tree 八叉树</strong> 把场景包起来，然后把正方体切成<strong>八份</strong>（三维的就是8份，xyz各切一刀，但是上面的图是4份，因为是2维的，所以看起来是2^2）。不断的对子节点递归进行此过程，放格子里面是空的或者物体足够少就停下来。（但是有个严重的问题，随着维度的升高，节点数量指数型增长）</li>
<li><strong>KD-Tree</strong> 与八叉树几乎相同，但是对每次划分的格子，总是<strong>沿着某一个轴切割</strong>（通常是交替的），且对每个格子<strong>仅切割一次</strong>。（好处是相比于八叉树，节点数量的复杂度不会随着维度指数型增长。）（而且不用等分，看下面的例子好理解）</li>
<li><strong>BSP-Tree</strong> 对空间二分，每次划分时选择一个方向，与KD-Tree的区别在于它的切割不一定是与轴平行的。（存在的问题是在维度高的时候不好计算，切割的几何体从点到线到面到超平面。）</li>
</ul>
<h2 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h2><h3 id="KD-Tree-的基本结构"><a href="#KD-Tree-的基本结构" class="headerlink" title="KD-Tree 的基本结构"></a>KD-Tree 的基本结构</h3><p>本质上是一颗二叉树，如下图所示（为了简化没画全，实际上1、2等节点都有子节点）。</p>
<p><img src="/images/Games101/14/07.png"></p>
<ul>
<li>对于<strong>非叶子节点</strong><ul>
<li>划分的轴：x、y或z轴。</li>
<li>划分的位置：分割的平面沿轴的坐标。</li>
<li>子节点：一定有两个子节点。</li>
<li><strong>在非叶子节点不会存储物体。</strong></li>
</ul>
</li>
<li>对于<strong>叶子节点</strong><ul>
<li><strong>存储物体列表。</strong></li>
</ul>
</li>
</ul>
<p>还是有点抽象？没事，看一下下面的应用：（最好看一下原视频）</p>
<h3 id="计算光线与物体交点的步骤"><a href="#计算光线与物体交点的步骤" class="headerlink" title="计算光线与物体交点的步骤"></a>计算光线与物体交点的步骤</h3><ul>
<li>如果<strong>走到非叶子节点</strong>，则<strong>探一下它的两个子节点（递归）</strong></li>
<li>如果<strong>走到叶子节点</strong>，则：<ul>
<li>如果包围盒里面没有物体，则跳过就行了；</li>
<li>如果有物体，则判断光线是否和物体相交；</li>
</ul>
</li>
</ul>
<p><img src="/images/Games101/14/08.png"></p>
<h3 id="KD-Tree的问题"><a href="#KD-Tree的问题" class="headerlink" title="KD-Tree的问题"></a>KD-Tree的问题</h3><ul>
<li>很难判断物体的三角形和AABB包围盒是否有交集。（比如一个包围盒很小，整个嵌在了三角形的面里面，这个要怎么判断？）</li>
<li>一个物体可能会与很多AABB包围盒有交集。也即一个物体可能存储在多个叶子节点里。（计算起来比较废）</li>
</ul>
<h1 id="物体划分与BVH加速结构（Object-Partition-Bounding-Volume-Hierarchy）"><a href="#物体划分与BVH加速结构（Object-Partition-Bounding-Volume-Hierarchy）" class="headerlink" title="物体划分与BVH加速结构（Object Partition &amp; Bounding Volume Hierarchy）"></a>物体划分与BVH加速结构（Object Partition &amp; Bounding Volume Hierarchy）</h1><p>换一种思想，既然对空间划分这么麻烦，那么就直接划分物体；</p>
<h2 id="思想和步骤"><a href="#思想和步骤" class="headerlink" title="思想和步骤"></a>思想和步骤</h2><ul>
<li>首先找到一个包围盒（这个简单啊，所有三角形坐标求min，max就行）</li>
<li>递归的把物体集合划分成两个子集；</li>
<li>重新计算子集的包围盒；</li>
<li>当满足一定要求的时候停止（比如规定一个包围盒里面只有五个三角形的时候）；</li>
<li>在每个叶子节点里存储所有物体；</li>
</ul>
<p>下面是图解：</p>
<p><img src="/images/Games101/14/09.png"></p>
<h2 id="BVH-优点和缺点"><a href="#BVH-优点和缺点" class="headerlink" title="BVH 优点和缺点"></a>BVH 优点和缺点</h2><p>BVH避免了KD-Tree的问题，具有如下优点。</p>
<ul>
<li><strong>一个物体</strong>只能出现在<strong>一个格子</strong>里。</li>
<li><strong>不涉及三角形和包围盒求交</strong>的问题。</li>
</ul>
<p>缺点：</p>
<ul>
<li>BVH并<strong>没有</strong>把<strong>空间严格</strong>的<strong>划分</strong>开（包围盒有可能相交）。</li>
</ul>
<h2 id="BVH-的细节问题"><a href="#BVH-的细节问题" class="headerlink" title="BVH 的细节问题"></a>BVH 的细节问题</h2><h3 id="如何划分节点？"><a href="#如何划分节点？" class="headerlink" title="如何划分节点？"></a>如何划分节点？</h3><p>每次都需要选择一个维度来分割（经验上有下面两种做法）。</p>
<ul>
<li>选择节点中<strong>最长的轴</strong>。</li>
<li>取<strong>中间的物体</strong>的位置来划分节点。</li>
</ul>
<h3 id="如何存储-BVH-树？"><a href="#如何存储-BVH-树？" class="headerlink" title="如何存储 BVH 树？"></a>如何存储 BVH 树？</h3><ul>
<li>中间节点存储包围盒和子节点的指针。</li>
<li>叶子节点存储包围盒和物体列表。</li>
<li>节点代表场景中图元（primitives）的子集，所有物体都在子树中。</li>
</ul>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 参考的是课件里面的</span><br><span class="line"><span class="built_in">Intersect</span>(Ray ray, BVH node) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ray misses node.bbox) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node is a leaf node)</span><br><span class="line">        test intersection with all objs;</span><br><span class="line">    	<span class="keyword">return</span> closest intersection;</span><br><span class="line">    </span><br><span class="line">    hit1 = <span class="built_in">Intersect</span>(ray, node.child1);</span><br><span class="line">    hit2 = <span class="built_in">Intersect</span>(ray, node.child2);</span><br><span class="line">    <span class="keyword">return</span> the closer of hit1, hit2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Games101/14/10.png"></p>
<h1 id="空间划分和物体划分"><a href="#空间划分和物体划分" class="headerlink" title="空间划分和物体划分"></a>空间划分和物体划分</h1><h3 id="空间划分（如KD-tree）"><a href="#空间划分（如KD-tree）" class="headerlink" title="空间划分（如KD-tree）"></a>空间划分（如KD-tree）</h3><ul>
<li>把空间划分成不重叠的区域。</li>
<li>一个物体可能被包含在多个区域中。</li>
</ul>
<h3 id="物体划分（如BVH）"><a href="#物体划分（如BVH）" class="headerlink" title="物体划分（如BVH）"></a>物体划分（如BVH）</h3><ul>
<li>把物体划分成不相交的子集。</li>
<li>每个子集的包围盒在空间上可能是重叠的。</li>
</ul>
<p><img src="/images/Games101/14/11.png"></p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489/article/details/121512582?spm=1001.2014.3001.5502">图形学笔记（十二）光线追踪2——使用AABB包围盒加速光线追踪、空间划分（八叉树、KD树、BSP树）、物体划分（BVH加速结构）、光线与物体求交_光线追踪算法遍历八叉树-CSDN博客</a></p>
<hr>
<p><strong>AI孙燕姿</strong> 真好听 hhh</p>
<p>等哪天闲了也来研究研究这东西。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/09/games101/Lec%2013/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/09/games101/Lec%2013/" class="post-title-link" itemprop="url">【Games 101】Lec 13：光线追踪 1（Shadow Mapping，Whitted-Style Ray Tracing）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-09 21:13:23" itemprop="dateCreated datePublished" datetime="2024-01-09T21:13:23+08:00">2024-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-10 00:24:07" itemprop="dateModified" datetime="2024-01-10T00:24:07+08:00">2024-01-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-13：Ray-Tracing-1-Shadow-Mapping，Whitted-Style-Ray-Tracing"><a href="#Lecture-13：Ray-Tracing-1-Shadow-Mapping，Whitted-Style-Ray-Tracing" class="headerlink" title="Lecture 13：Ray Tracing 1 (Shadow Mapping，Whitted-Style Ray Tracing)"></a>Lecture 13：Ray Tracing 1 (Shadow Mapping，Whitted-Style Ray Tracing)</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这一节课主要讲了 <strong>阴影</strong> 和 <strong>光线追踪</strong>；</p>
<p>光纤追踪这一部分有点难啊… </p>
<p>挺抽象的，不太好理解…</p>
<h1 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Shadow Mapping<strong>本质是一种图像空间</strong>的算法。</p>
<p>我们之前学的都没有考虑到<strong>阴影</strong>，现在考虑一下这个东西；</p>
<h2 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h2><ul>
<li>从光源渲染，从光源看场景，可以求出深度图（点到光源的深度）（z-buffer）</li>
<li><img src="/images/Games101/13/01.png"></li>
<li>从相机渲染，也就是从相机发出光线，可以得到我们看到的点，然后求这些点到光源的深度；如果这个深度和从光源渲染的深度是一样的，则说明这个点没有被遮挡；否则说明，这个点被遮挡了；</li>
<li><img src="/images/Games101/13/02.png"></li>
</ul>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/images/Games101/13/03.png"></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ul>
<li>生成的是硬阴影（只对点光源（没有体积））。</li>
<li>阴影的效果取决于shadow map的分辨率。</li>
<li>涉及浮点精度比较的问题，导致渲染出来的效果一般。</li>
</ul>
<h2 id="软阴影和硬阴影"><a href="#软阴影和硬阴影" class="headerlink" title="软阴影和硬阴影"></a>软阴影和硬阴影</h2><p>下面图中，左上是硬阴影，左下是软阴影；</p>
<p><img src="/images/Games101/13/04.png"></p>
<h3 id="软阴影的原理"><a href="#软阴影的原理" class="headerlink" title="软阴影的原理"></a>软阴影的原理</h3><p>由于点光源有大小，会形成<strong>本影（Umbra）区域</strong>和<strong>半影（Penumbra）区域</strong>。所以会形成阴影的过渡。</p>
<h2 id="进行光线追踪（Ray-Tracing）的原因"><a href="#进行光线追踪（Ray-Tracing）的原因" class="headerlink" title="进行光线追踪（Ray Tracing）的原因"></a>进行光线追踪（Ray Tracing）的原因</h2><p><img src="/images/Games101/13/05.png"></p>
<ul>
<li><strong>难以做软阴影</strong>；</li>
<li><strong>难以表现光线多次弹射，比如间接光照</strong>；</li>
<li><strong>光栅化很快但是质量较低</strong>；</li>
<li><strong>光线追踪很准确，但是很慢</strong>；</li>
</ul>
<p>光栅化：实时（游戏），光线追踪：离线（动画）。</p>
<p>光线追踪一帧就要花10K个计算机小时</p>
<p>光栅化和光线追踪都是成像方式。</p>
<h1 id="光线追踪（算法）"><a href="#光线追踪（算法）" class="headerlink" title="光线追踪（算法）"></a>光线追踪（算法）</h1><h2 id="光线的一些定义概念"><a href="#光线的一些定义概念" class="headerlink" title="光线的一些定义概念"></a>光线的一些定义概念</h2><ul>
<li><p>光线沿直线传播。</p>
</li>
<li><p>光线和光线不会发生碰撞。</p>
</li>
<li><p>光线会从光源发出，打到场景中，经过反射折射等最终进入人眼（光线具有可逆性）。</p>
</li>
</ul>
<h2 id="光线投影（Ray-Casting）"><a href="#光线投影（Ray-Casting）" class="headerlink" title="光线投影（Ray Casting）"></a>光线投影（Ray Casting）</h2><p>光线投射是<strong>光线追踪中用于生成初始光线的第一步。</strong></p>
<ul>
<li><p>通过每个像素投射一条光线来生成图像</p>
</li>
<li><p>通过向光源发送光线来检查阴影</p>
</li>
</ul>
<p><strong>具体的讲：</strong></p>
<ul>
<li>从视点开始经过像素获得与场景中物体最近的交点。</li>
<li><img src="/images/Games101/13/06.png"></li>
<li>将交点和和光源连线，判断这个点是否对光源可见，从而确定该点是否是阴影；</li>
<li><img src="/images/Games101/13/07.png"></li>
<li>然后计算着色，并将结果写回像素；</li>
</ul>
<h2 id="Recursive（Whitted-Style）-Ray-Tracing"><a href="#Recursive（Whitted-Style）-Ray-Tracing" class="headerlink" title="Recursive（Whitted- Style） Ray Tracing"></a>Recursive（Whitted- Style） Ray Tracing</h2><p>这个光线追踪算法可以看成是优化，<strong>它考虑了反射和折射的光线</strong>。</p>
<p><img src="/images/Games101/13/08.png"></p>
<p>对<strong>每一个弹射点都要计算着色的值</strong>，然后<strong>把所有着色的值都加到像素的值里面</strong>去。</p>
<p>当然这里需要考虑能量的衰减：</p>
<p><img src="/images/Games101/13/09.png"></p>
<p>光线有不同的分类：</p>
<p><img src="/images/Games101/13/10.png"></p>
<p><strong>上面只是讲了大概应该怎么做，下面具体的讲细节。</strong></p>
<h2 id="光线和表面的交点（Ray-Surface-Intersection）"><a href="#光线和表面的交点（Ray-Surface-Intersection）" class="headerlink" title="光线和表面的交点（Ray-Surface Intersection）"></a>光线和表面的交点（Ray-Surface Intersection）</h2><p>回顾一下上面，首先光线追踪的第一步，是不是要求一条光线和表面的交点？</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h4><p>光线在数学上定义成 <strong>有起点和方向的射线</strong>，用 t 来表示时间，则我们可以得到射线的一个表达式：</p>
<p><img src="/images/Games101/13/11.png"></p>
<ul>
<li>r(t)：是 t 时刻射线上的点；</li>
<li>o：是起始点；</li>
<li>d：表示方向，感觉可以理解为速度；</li>
</ul>
<h4 id="平面"><a href="#平面" class="headerlink" title="平面"></a>平面</h4><p>通过一个<strong>法向量</strong>和一个<strong>平面上的点</strong>来进行定义。</p>
<p><img src="/images/Games101/13/12.png"></p>
<p><strong>平面的表达式</strong> 平面是满足下面条件所有p点的集合。</p>
<h3 id="光线-和-球-求交"><a href="#光线-和-球-求交" class="headerlink" title="光线 和 球 求交"></a>光线 和 球 求交</h3><p>这个很简单，带进去就行；</p>
<p><img src="/images/Games101/13/13.png"></p>
<p><img src="/images/Games101/13/14.png"></p>
<h3 id="光线-和-隐式表面-求交"><a href="#光线-和-隐式表面-求交" class="headerlink" title="光线 和 隐式表面 求交"></a>光线 和 隐式表面 求交</h3><p>也是一样的，带入：</p>
<p><img src="/images/Games101/13/15.png"></p>
<h3 id="光线-和-三角形面-求交"><a href="#光线-和-三角形面-求交" class="headerlink" title="光线 和 三角形面 求交"></a>光线 和 三角形面 求交</h3><h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h4><p>光线和三角形求交有如下作用：</p>
<ul>
<li>渲染：可见性、阴影、光照…</li>
<li>几何：可以判断点是再物体内还是物体外。<br>对任何一个封闭的曲面，在内部找一个点，如果点在形状内，那么从这个点发出的任意方向的射线与此物体的交点数量一定是奇数。</li>
</ul>
<p><img src="/images/Games101/13/16.png"></p>
<h4 id="具体算法-1"><a href="#具体算法-1" class="headerlink" title="具体算法"></a>具体算法</h4><p>简单的办法是让场景中的每个三角形与光线进行求交计算，但是有如下严重问题。</p>
<ul>
<li>简单但是运算量大。</li>
<li>可以有0或1个交点。</li>
</ul>
<p>因为<strong>三角形在平面内</strong>，所以可以把光线和三角形求交拆成两个问题：</p>
<ul>
<li><p>让光线与平面求交（目前与平面求交比与三角形求交容易）。</p>
</li>
<li><p>判断与平面的交点是否在三角形内。</p>
</li>
</ul>
<p><strong>也就是说：光线与平面求交再判断是否在三角形内！</strong></p>
<p><img src="/images/Games101/13/17.png"></p>
<p>通过上面的图，可以求出 t，进而求出 r(t) （也就是交点）；</p>
<p>然后再判断交点是否在三角形里面；</p>
<h4 id="Moller-Trumbore-（MT）算法"><a href="#Moller-Trumbore-（MT）算法" class="headerlink" title="Moller Trumbore （MT）算法"></a>Moller Trumbore （MT）算法</h4><p>通过上面我们可以知道，我们需要两步来求解；</p>
<p>MT 算法通过<strong>使用重心坐标</strong>来同时判断点是否在三角形里面；</p>
<p>在下面的式子中，左边是光线的表达式，右边是三角形上一点的重心坐标形式。</p>
<p><img src="/images/Games101/13/18.png"></p>
<p>根据上面的等式解出来 <strong>t ，b1 ，b2</strong>（<strong>三个方程，三个未知数</strong>，也可以使用克莱默法则）。</p>
<p><img src="/images/Games101/13/19.png"></p>
<p>如果解出来的 <strong>t ，b1 ，b2 ，1-b1-b2</strong> 都<strong>大于0</strong>，则说明解是有意义的。</p>
<h1 id="包围盒（Bounding-Volumes）"><a href="#包围盒（Bounding-Volumes）" class="headerlink" title="包围盒（Bounding Volumes）"></a>包围盒（Bounding Volumes）</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>原始的做法是让每个像素的光线要和<strong>所有三角形面求交点</strong>，计算量太大，那么如何让这个过程加速呢？如果我们圈定包围盒，<strong>连与包围盒都不相交的三角形就不用接着算了</strong>，那么就可以很大的减少计算量。</p>
<p><img src="/images/Games101/13/20.png"></p>
<p><strong>基本思想</strong>：使用一个简单的几何体来包围一个复杂的物体，如果光线不能碰到包围盒，那么就不用再计算其与里面物体的（三角形的）交点。</p>
<p>这样就能少算很多很多 三角形和光线 的求交运算；</p>
<h2 id="求光线与长方体的交点"><a href="#求光线与长方体的交点" class="headerlink" title="求光线与长方体的交点"></a>求光线与长方体的交点</h2><p>3D物体通常的包围盒是长方体。<br>一个重要理解：<strong>长方体是三对不同的面形成的交集</strong>。</p>
<p><img src="/images/Games101/13/21.png"></p>
<p>我们使用的包围盒通常是<strong>轴对齐（AABB）包围盒</strong>。Axis-Aligned Bounding Box(AABB)<br>经过以上分析，现在问题就变成了<strong>求光线和轴对齐包围盒的交点；</strong></p>
<h2 id="求光线和轴对齐包围盒的交点"><a href="#求光线和轴对齐包围盒的交点" class="headerlink" title="求光线和轴对齐包围盒的交点"></a>求光线和轴对齐包围盒的交点</h2><h3 id="考虑2维的情况"><a href="#考虑2维的情况" class="headerlink" title="考虑2维的情况"></a>考虑2维的情况</h3><p>先分析简单的，2维的长方形；</p>
<p>由于前面提到的光线方程是参数方程，所以只要我们计算光线什么时候会和一对平行的边有<strong>交点</strong>（计算 <strong>t-min , t-max</strong>），就可以求出<strong>光线进入和离开这个边的时间</strong>。</p>
<p><img src="/images/Games101/13/22.png"></p>
<p>看上面的图：</p>
<p>首先注意到长方形有两对边；</p>
<p><strong>左边的图</strong>：是求光线和<strong>左右两边</strong>的相交时的<strong>时间</strong>；</p>
<p><strong>中间的图</strong>：是求光线和<strong>上下两边</strong>的相交时的<strong>时间</strong>；</p>
<p>然后对这两段<strong>求交集</strong>，，此时 <strong>t-min , t-max</strong> 就分别代表着<strong>光线进入和离开长方体的时间</strong>。</p>
<h3 id="考虑3维的情况"><a href="#考虑3维的情况" class="headerlink" title="考虑3维的情况"></a>考虑3维的情况</h3><p>根据2维的情况，我们<strong>推导出3维的情况的性质</strong>：</p>
<ul>
<li>只有当光线<strong>进入了所有的对面</strong>，才能说光线进入了盒子。</li>
<li>只要光线<strong>离开任意一个对面</strong>，光线就离开了盒子。</li>
</ul>
<hr>
<p>然后通过上面我们知道，Box 有3对面，也就是每一对面，光线都能和这对面求一组 t-min , t-max；</p>
<p><strong>所以再根据上面的性质可以求出光线进入 BOX 的 t （t-enter）和 离开 BOX 的 t（t-exit）</strong></p>
<p><strong>t-enter &#x3D; max( t1-min , t2-min , t3-min )</strong></p>
<p><strong>t-exit &#x3D; min( t1-max , t2-max , t3-max )</strong></p>
<p>ti 表示第 i 对面；</p>
<hr>
<p><strong>t为负时的意义：</strong></p>
<ul>
<li>如果 <strong>t-exit &lt; 0</strong>，说明<strong>盒子在光线背后</strong>，说明<strong>没有交点</strong>。</li>
<li>如果 <strong>t-exit &gt;&#x3D; 0 &amp;&amp; t-enter &lt; 0</strong>，说明<strong>光线的起点在盒子里</strong>，一定有交点。</li>
</ul>
<hr>
<p><strong>结论：</strong></p>
<p>如果满足 <strong>t-enter &lt; t-exit &amp;&amp; t-exit &gt;&#x3D; 0</strong>，则说明光线与AABB包围盒有交点。</p>
<hr>
<p><img src="/images/Games101/13/23.png"></p>
<p><img src="/images/Games101/13/24.png"></p>
<h3 id="使用轴对齐-AABB-概念的原因"><a href="#使用轴对齐-AABB-概念的原因" class="headerlink" title="使用轴对齐(AABB)概念的原因"></a>使用轴对齐(AABB)概念的原因</h3><p>主要目的是<strong>简化计算</strong>。<br>普通情况计算 t：</p>
<p><img src="/images/Games101/13/25.png"></p>
<p>轴对齐的情况下计算t（只需要考虑各方向的分量即可）：</p>
<p><img src="/images/Games101/13/26.png"></p>
<hr>
<p>ok，这个就是这一节课的内容…</p>
<p>这一节课是真的多，写了好久好久…</p>
<p>关于包围盒只是讲了怎么做，但是还没讲怎么用（下一节？）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/08/games101/Lec%2012/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/08/games101/Lec%2012/" class="post-title-link" itemprop="url">【Games 101】Lec 12：几何 3</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-08 23:01:07 / 修改时间：23:33:32" itemprop="dateCreated datePublished" datetime="2024-01-08T23:01:07+08:00">2024-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-12：Geometry-3"><a href="#Lecture-12：Geometry-3" class="headerlink" title="Lecture 12：Geometry 3"></a>Lecture 12：Geometry 3</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这节课主要讲的是 <strong>曲面细分</strong>，<strong>曲面简化</strong> 和 <strong>阴影</strong>；</p>
<p>这篇文章记录 曲面细分 和 曲面简化，阴影放在下一篇文章；</p>
<h1 id="曲面细分"><a href="#曲面细分" class="headerlink" title="曲面细分"></a>曲面细分</h1><p>曲面细分一般来说，需要先增加点的数量，然后再调整点的位置。</p>
<h2 id="Loop细分"><a href="#Loop细分" class="headerlink" title="Loop细分"></a>Loop细分</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>整体步骤：</p>
<ul>
<li>增加三角形数量；</li>
<li>改变三角形位置，让模型看上去更加光滑；</li>
<li><img src="/images/Games101/12/01.png"></li>
</ul>
<h3 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h3><ul>
<li>把每个三角形分成4个（这里就会产生新的顶点）</li>
</ul>
<p><img src="/images/Games101/12/02.png"></p>
<ul>
<li>根据权重分配新的顶点（新顶点和旧顶点的调整方式不同）。<ul>
<li><strong>更新 新顶点</strong>：周围几个点的加权平均；</li>
<li><strong>更新 旧顶点</strong>：根据自己原本的位置和自己周围顶点的位置来进行加权平均（n是顶点的度数）</li>
</ul>
</li>
</ul>
<p><img src="/images/Games101/12/03.png"></p>
<p><img src="/images/Games101/12/04.png"></p>
<h3 id="Loop细分结果"><a href="#Loop细分结果" class="headerlink" title="Loop细分结果"></a>Loop细分结果</h3><p><img src="/images/Games101/12/05.png"></p>
<h2 id="Catmull-Clark细分（General-Mesh）"><a href="#Catmull-Clark细分（General-Mesh）" class="headerlink" title="Catmull-Clark细分（General Mesh）"></a>Catmull-Clark细分（General Mesh）</h2><p>Loop 细分只能解决三角形网格的细分问题，对于一般的情况（一般的网格面）可以采用Catmull-Clark细分。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>非四边形面</strong>（Non-quad face）：顾名思义。<br><strong>奇异点</strong>（Extraordinary vertex）：度数不为 4 的点。</p>
<p><img src="/images/Games101/12/06.png"></p>
<h3 id="Catmull-Clark细分算法"><a href="#Catmull-Clark细分算法" class="headerlink" title="Catmull-Clark细分算法"></a>Catmull-Clark细分算法</h3><ul>
<li><strong>增加新的点</strong><ul>
<li>取每个面的一个点（比如重心）</li>
<li>取每个边的中点</li>
<li>将所有新添加的点做连接</li>
<li><img src="/images/Games101/12/07.png"></li>
<li>在一次细分后会引入两个新的奇异点。</li>
<li>新奇异点的度数为3，其他奇异点的度数不变。</li>
<li>经过一次细分，所有非四边形面会消失。</li>
<li>细分之后，每个非四边形面都会变成一个奇异点（以后再细分奇异点和非四边形面都不会发生变化了）。</li>
<li><img src="/images/Games101/12/08.png"></li>
</ul>
</li>
<li><strong>调整规则</strong><ul>
<li>对于 <strong>新点</strong>，<strong>面上的点</strong>和<strong>边上的点</strong>位置更新规则如下：</li>
<li><img src="/images/Games101/12/09.png"></li>
<li>对于 <strong>旧点</strong>：</li>
<li><img src="/images/Games101/12/10.png"></li>
</ul>
</li>
</ul>
<h3 id="Catmull-Clark细分结果"><a href="#Catmull-Clark细分结果" class="headerlink" title="Catmull-Clark细分结果"></a>Catmull-Clark细分结果</h3><p><img src="/images/Games101/12/11.png"></p>
<h1 id="曲面简化"><a href="#曲面简化" class="headerlink" title="曲面简化"></a>曲面简化</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>目标：减少三角形的数量并保留整体的形状。</p>
<p><img src="/images/Games101/12/12.png"></p>
<h2 id="做法：边坍缩（Collapsing-An-Edge）"><a href="#做法：边坍缩（Collapsing-An-Edge）" class="headerlink" title="做法：边坍缩（Collapsing An Edge）"></a>做法：边坍缩（Collapsing An Edge）</h2><p><img src="/images/Games101/12/13.png"></p>
<h2 id="优化：二次误差度量"><a href="#优化：二次误差度量" class="headerlink" title="优化：二次误差度量"></a>优化：二次误差度量</h2><p><strong>二次误差度量（Quadric Error Metrics）</strong></p>
<ul>
<li>它用来表示曲面简化带来的误差的大小。</li>
<li>用局部顶点做平均效果是不好的。</li>
<li>二次误差：在平面中找一个点，使得这个点与它相关联的面的距离平方和达到最小，将这个点作为新的点；</li>
</ul>
<p><img src="/images/Games101/12/14.png"></p>
<p><strong>做法：</strong></p>
<ul>
<li>首先将每条边的二次误差值，作为他们各自的分数；</li>
<li>首先选一条分数最小的，进行边塌缩；</li>
<li>此时其他边的分数会变化，所以更新所有边的分数；</li>
<li>然后继续重复上面的操作；</li>
</ul>
<p>（可以用堆来实现，是贪心算法的结果）</p>
<p><img src="/images/Games101/12/15.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/08/games101/Lec%2011/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/08/games101/Lec%2011/" class="post-title-link" itemprop="url">【Games 101】Lec 11：几何 2 （曲线 和 曲面）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-08 21:42:58 / 修改时间：22:23:12" itemprop="dateCreated datePublished" datetime="2024-01-08T21:42:58+08:00">2024-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-11：Geometry-2-Curves-and-Surfaces"><a href="#Lecture-11：Geometry-2-Curves-and-Surfaces" class="headerlink" title="Lecture 11：Geometry 2 (Curves and Surfaces)"></a>Lecture 11：Geometry 2 (Curves and Surfaces)</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这节课主要讲了几何中的 曲线 和 曲面；</p>
<p>前面一段是在讲几何的显示表示，放在放一篇文章了；</p>
<h1 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>用一系列的控制点来定义某一条曲线。这些控制点使用切线来定义贝塞尔曲线。</p>
<p><img src="/images/Games101/11/01.png"></p>
<p>看上图，注意曲线起始方向沿着P0 P1，结束方向沿着P2 P3；</p>
<p> （不要求曲线经过控制点，但一定要经过起止点 和 极值点（控制点关于时间插值出来的点））</p>
<h2 id="计算贝塞尔曲线——de-Casteljau-算法"><a href="#计算贝塞尔曲线——de-Casteljau-算法" class="headerlink" title="计算贝塞尔曲线——de Casteljau 算法"></a>计算贝塞尔曲线——de Casteljau 算法</h2><p>首先我们<strong>把整个曲线映射到 [0，1] 的时间轴上</strong>；</p>
<p><strong>曲线上的每个点都是关于时间 t（0，1 之间）的插值的结果</strong>；</p>
<p>这也是为什么贝塞尔曲线是<strong>显示</strong>的表示（做了映射）；</p>
<p>下面看看是如何具体做映射的：</p>
<ul>
<li>给定三个控制点生成的贝塞尔曲线称为二次贝塞尔曲线（quadratic Bezier）。</li>
</ul>
<p><img src="/images/Games101/11/02.png"></p>
<ul>
<li>使用线性插值插入一个点（假设起点是时间0，终点是时间1），假设当前这个点对应时间轴的上 t ，按时间轴的比例，标记出一个线段上的插值点 b01;</li>
</ul>
<p><img src="/images/Games101/11/03.png"></p>
<ul>
<li>对于每个第一层（原始的）线段都做一下插值，变成：</li>
</ul>
<p><img src="/images/Games101/11/04.png"></p>
<ul>
<li>然后继续，同理，对于第二层的线段也同样操作，直至剩下一个点；</li>
</ul>
<p><img src="/images/Games101/11/05.png"></p>
<ul>
<li>这样我们只是得到了一个 t 的插值后的点，我们对 [0, 1] 所有的 t 都进行插值，最终就能得到这个曲线；</li>
</ul>
<p><img src="/images/Games101/11/06.png"></p>
<h2 id="贝塞尔曲线代数公式"><a href="#贝塞尔曲线代数公式" class="headerlink" title="贝塞尔曲线代数公式"></a>贝塞尔曲线代数公式</h2><p><strong>推导：</strong></p>
<p><img src="/images/Games101/11/07.png"></p>
<p>如果有n+1个控制点（从0开始编号），可以得到n阶的贝塞尔曲线。</p>
<p><img src="/images/Games101/11/08.png"></p>
<p><strong>Bernstein 多项式：</strong></p>
<p><img src="/images/Games101/11/09.png"></p>
<p>例如，当 n&#x3D;3 时，公式为：</p>
<p><img src="/images/Games101/11/10.png"></p>
<h2 id="贝塞尔曲线的性质"><a href="#贝塞尔曲线的性质" class="headerlink" title="贝塞尔曲线的性质"></a>贝塞尔曲线的性质</h2><p><img src="/images/Games101/11/11.png"></p>
<h1 id="逐段（Piecewise）贝塞尔曲线"><a href="#逐段（Piecewise）贝塞尔曲线" class="headerlink" title="逐段（Piecewise）贝塞尔曲线"></a>逐段（Piecewise）贝塞尔曲线</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>由于当控制点太多，曲线难以被控制点控制。</p>
<p>所以<strong>逐段</strong>定义贝塞尔曲线（一般用<strong>四个控制点</strong>）。</p>
<p><img src="/images/Games101/11/12.png"></p>
<p>如果要让不同的分段之间光滑过渡，只需要在<strong>切线上连续</strong>（<strong>方向</strong>和<strong>大小</strong>上）。</p>
<h2 id="分段贝塞尔曲线的连续性"><a href="#分段贝塞尔曲线的连续性" class="headerlink" title="分段贝塞尔曲线的连续性"></a>分段贝塞尔曲线的连续性</h2><p><img src="/images/Games101/11/13.png"></p>
<h1 id="其他类型的曲线"><a href="#其他类型的曲线" class="headerlink" title="其他类型的曲线"></a>其他类型的曲线</h1><h2 id="样条-Spline"><a href="#样条-Spline" class="headerlink" title="样条 Spline"></a>样条 Spline</h2><p>一个连续的曲线是由一系列控制点控制点，在任意一个地方可以满足一定的连续性。</p>
<p>简单来说就是一个可控的曲线。</p>
<h2 id="B样条-B-Splines"><a href="#B样条-B-Splines" class="headerlink" title="B样条 B-Splines"></a>B样条 B-Splines</h2><ul>
<li>贝塞尔曲线的扩展（具有局部性，容易控制），就是基函数（basis）样条。</li>
<li>比贝塞尔曲线需要更多的信息。</li>
<li>满足贝塞尔曲线的所有性质。</li>
<li>难</li>
</ul>
<h1 id="（贝塞尔）曲面"><a href="#（贝塞尔）曲面" class="headerlink" title="（贝塞尔）曲面"></a>（贝塞尔）曲面</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>把贝塞尔曲线的概念延申到平面上。</p>
<p><img src="/images/Games101/11/14.png"></p>
<p>回顾一下，每段贝塞尔曲线是4个点的线性插值的结果；</p>
<p>所以，每一片贝塞尔曲面是16控制点，两次线性插值的结果：</p>
<p>第一次先 4 组（每组四个）进行一次线性插值，得到四条贝塞尔曲线，然后对于四条曲线，我们再插值一次，得到曲面：</p>
<p><img src="/images/Games101/11/15.png"></p>
<p>规范的讲：</p>
<p>输入：<strong>4*4 控制点</strong></p>
<p>输出：<strong>一个在 [0,1] ^2 内的 (u,v) 参数化的二维曲面</strong></p>
<p>反过来讲，<strong>给一个 贝塞尔曲面上参数化后的 (u,v)，我们就能知道 (u,v) 对应的是曲面上的哪个点。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/07/games101/Lec%2008/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/07/games101/Lec%2008/" class="post-title-link" itemprop="url">【Games 101】Lec 08：渲染2（阴影 渲染管线 和 纹理映射）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-07 22:29:15 / 修改时间：22:43:45" itemprop="dateCreated datePublished" datetime="2024-01-07T22:29:15+08:00">2024-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-8：Shading-2-Shading-Pipeline-and-Texture-Mapping"><a href="#Lecture-8：Shading-2-Shading-Pipeline-and-Texture-Mapping" class="headerlink" title="Lecture 8：Shading 2 (Shading, Pipeline and Texture Mapping)"></a>Lecture 8：Shading 2 (Shading, Pipeline and Texture Mapping)</h1><p><img src="/images/Games101/08/01.png"></p>
<p><img src="/images/Games101/08/02.png"></p>
<h2 id="Blinn-Phong-模型的后两种"><a href="#Blinn-Phong-模型的后两种" class="headerlink" title="Blinn-Phong 模型的后两种"></a>Blinn-Phong 模型的后两种</h2><h3 id="高光像（高光反射-镜面反射）"><a href="#高光像（高光反射-镜面反射）" class="headerlink" title="高光像（高光反射 &#x2F; 镜面反射）"></a>高光像（高光反射 &#x2F; 镜面反射）</h3><blockquote>
<p>当我们<strong>观察方向</strong>和<strong>光线反射的方向</strong>很接近的时候，那么就会产生镜面反射；</p>
<p><img src="/images/Games101/08/03.png"></p>
<p>怎么算？？</p>
<p>Blinn-Phong 模型中做了一个改进，它发现了，<strong>观察方向和光线反射的方向很接近 &lt;&#x3D;&gt; 平面的法向量和半程向量很接近</strong>，所以考虑下面的计算方法：</p>
<p><img src="/images/Games101/08/04.png"></p>
<p><strong>指数 p 的一个作用：控制高光的衰减大小</strong></p>
<p><img src="/images/Games101/08/05.png"></p>
<p><img src="/images/Games101/08/06.png"></p>
</blockquote>
<h3 id="环境反射（间接反射）"><a href="#环境反射（间接反射）" class="headerlink" title="环境反射（间接反射）"></a>环境反射（间接反射）</h3><blockquote>
<p>大胆假设：任何一个点接收到环境的光是一样的！</p>
<p><img src="/images/Games101/08/07.png"></p>
<p><strong>Ia：表示来自环境的光强</strong><br><strong>Ka：系数</strong></p>
<p>所以可以看到，环境光是一个<strong>常数</strong>，和观测方向无关！</p>
</blockquote>
<h3 id="Blinn-Phong-模型-小结："><a href="#Blinn-Phong-模型-小结：" class="headerlink" title="Blinn-Phong 模型 小结："></a>Blinn-Phong 模型 小结：</h3><p>把所有的光加起来就是最终结果：</p>
<p><img src="/images/Games101/08/08.png"></p>
<p>所以：</p>
<p><strong>Blinn-Phong 模型</strong> &#x3D; <strong>漫反射模型</strong> + <strong>高光反射&#x2F;镜面反射</strong> + <strong>环境反射</strong></p>
<h2 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h2><h3 id="着色模型"><a href="#着色模型" class="headerlink" title="着色模型"></a>着色模型</h3><blockquote>
<p>着色频率不同产生不同的效果：</p>
<p><img src="/images/Games101/08/09.png"></p>
<hr>
<p><strong>第一种：对每个三角形的平面进行着色；</strong><br>（求法线）</p>
<p><img src="/images/Games101/08/10.png"></p>
<hr>
<p><strong>第二种：对于每个顶点求一个法线，然后进行着色；</strong></p>
<p><img src="/images/Games101/08/11.png"></p>
<hr>
<p><strong>第三种：对于每个像素我们都去着色；</strong></p>
<p>（对每个像素都去求一个法线）</p>
<p><img src="/images/Games101/08/12.png"></p>
<hr>
<p>要看情况使用不同的着色频率，当我们的物体的平面比较多的时候（模型足够复杂），这时候我们就可以直接用简单的着色模型了，最终的效果也不会差。</p>
<p><img src="/images/Games101/08/13.png"></p>
</blockquote>
<h3 id="定义一些东西"><a href="#定义一些东西" class="headerlink" title="定义一些东西"></a>定义一些东西</h3><blockquote>
<p><strong>定义每个顶点的法向量</strong></p>
<p><img src="/images/Games101/08/14.png"></p>
<p><strong>顶点的法向量 &#x3D; 相关的面的法向量的加权平均值</strong></p>
<hr>
<p><strong>定义每个像素的法向量</strong></p>
<p><img src="/images/Games101/08/15.png"></p>
<p><strong>像素的法向量 &#x3D; 顶点法向量平面的重心坐标</strong></p>
</blockquote>
<h2 id="图形管线（实时渲染管线）"><a href="#图形管线（实时渲染管线）" class="headerlink" title="图形管线（实时渲染管线）"></a>图形管线（实时渲染管线）</h2><blockquote>
<p><strong>Graphics (Real-time Rendering) Pipeline</strong></p>
<p><strong>定义：如何从 一个场景 -&gt; 一张图 的过程</strong></p>
<p>就是一些列不同的操作：</p>
<p><img src="/images/Games101/08/16.png"></p>
<ol start="0">
<li><strong>3D模型</strong></li>
<li><strong>顶点处理</strong></li>
<li><strong>三角形处理</strong></li>
<li><strong>光栅化</strong></li>
<li><strong>着色</strong></li>
<li><strong>输出</strong></li>
</ol>
<hr>
<p>现代GPU允许我们自己定义这些操作，所以也叫做 <strong>可编程渲染管线</strong>（也就是我们讲的<strong>Shader</strong>）</p>
<p>具体的讲：</p>
<p>对于一个顶点或者一个像素，我们可以自己编程计算，自己规定这个点或者像素最后显示的颜色；（只用统一写一次，应用于每一个点）</p>
<p><strong>顶点着色器</strong>：给每个点写一个着色的程序</p>
<p><strong>像素着色器 &#x2F; 片元着色器</strong>：给每个像素写一个着色的程序 </p>
<p><img src="/images/Games101/08/17.png"></p>
<p><img src="/images/Games101/08/18.png"></p>
</blockquote>
<h2 id="现代图形学发展"><a href="#现代图形学发展" class="headerlink" title="现代图形学发展"></a>现代图形学发展</h2><p><img src="/images/Games101/08/19.png"></p>
<h2 id="纹理映射（Texture-Mapping）"><a href="#纹理映射（Texture-Mapping）" class="headerlink" title="纹理映射（Texture Mapping）"></a>纹理映射（Texture Mapping）</h2><blockquote>
<p><strong>定义一个点的不同属性</strong>，具体讲，对于一个三维空间，我们都可以把它展开成二维平面，从而和图像对于；</p>
<p><img src="/images/Games101/08/20.png"></p>
<p>那么现在我们要解决的问题就是，我们如何<strong>将一张图像（纹理）贴到三维的物体</strong>上面？（这个过程就是纹理映射）</p>
<p><img src="/images/Games101/08/21.png"></p>
<p>其实问题就是，对于物体上的三角形，我们要怎么映射到纹理上的三角形。</p>
<p>这个问题比较复杂…这里我们规定已经是映射好了的。</p>
<p><strong>纹理的坐标</strong>：</p>
<p><img src="/images/Games101/08/22.png"></p>
<p><img src="/images/Games101/08/23.png"></p>
<p>U V 都在 0~1 之内</p>
</blockquote>
<hr>
<p><strong>思考：</strong></p>
<ul>
<li><p>假设我们知道了三角形三个点对应的纹理坐标，我们如何知道三角形内部任意一点的纹理坐标（U V）？</p>
</li>
<li><p>在三角形的三个顶点有各自不同的属性，如何在三角形内部做一个平滑的过渡，使得我们能快速知道三角形内部任意一点通过插值之后的属性是多少？（<strong>重心坐标</strong>）</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/07/games101/Lec%2003/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/07/games101/Lec%2003/" class="post-title-link" itemprop="url">【Games 101】Lec 03：变换</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-07 22:28:30 / 修改时间：22:36:50" itemprop="dateCreated datePublished" datetime="2024-01-07T22:28:30+08:00">2024-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-03-Transformation"><a href="#Lecture-03-Transformation" class="headerlink" title="Lecture 03: Transformation"></a>Lecture 03: Transformation</h1><p><img src="/images/Games101/03/01.png"></p>
<h2 id="二维变换"><a href="#二维变换" class="headerlink" title="二维变换"></a>二维变换</h2><h3 id="缩放变换"><a href="#缩放变换" class="headerlink" title="缩放变换"></a>缩放变换</h3><p><img src="/images/Games101/03/02.png"></p>
<p>用矩阵表示，矩阵就叫<strong>缩放矩阵</strong></p>
<p><strong>对称变换</strong>一下：</p>
<p><img src="/images/Games101/03/03.png"></p>
<p><strong>复杂一点的</strong>：</p>
<p>这里的 x 的变换 和 y 是有关系的 x’ &#x3D; x + ay</p>
<p><img src="/images/Games101/03/04.png"></p>
<h3 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h3><p><img src="/images/Games101/03/05.png"></p>
<p><strong>推导：</strong></p>
<p>推关系（x’ 和 x）（y’ 和 y）：（<strong>利用特殊点（1，0）</strong>）</p>
<p><img src="/images/Games101/03/06.png"></p>
<p>从上图可以得到：</p>
<p>A &#x3D; cosθ</p>
<p>C &#x3D; sinθ</p>
<p>同理，用特殊点（0，1）算出B D</p>
<p>B &#x3D; -sinθ</p>
<p>D &#x3D; cosθ</p>
<p>所以可以得到<strong>旋转矩阵</strong> Rθ；</p>
<p><strong>记忆：</strong></p>
<p>记图，然后自己推到一下就行！</p>
<p><strong>性质：</strong></p>
<p><strong>旋转矩阵的转置 &lt;&#x3D;&gt; 旋转矩阵的逆</strong></p>
<p>如果一个 <strong>矩阵转置 &#x3D; 矩阵的逆</strong>，则这个矩阵叫做<strong>正交矩阵</strong></p>
<p><img src="/images/Games101/03/07.png"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>线性变换：输入坐标 * 矩阵 &#x3D; 输出坐标</strong></p>
<p><img src="/images/Games101/03/08.png"></p>
<p>上面的例子统称为<strong>线性变换</strong></p>
<h2 id="齐次坐标（统一变换）"><a href="#齐次坐标（统一变换）" class="headerlink" title="齐次坐标（统一变换）"></a>齐次坐标（统一变换）</h2><h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><p>当我们平移图像的时候，可以发现我们无法用之前的简单的矩阵x向量的形式表示，而是得用下面的表示方法：</p>
<p><img src="/images/Games101/03/09.png"></p>
<p>所以，<strong>平移不属于线性变换</strong>；</p>
<p>但是我们不想要它特殊，所以引入了<strong>齐次坐标</strong>，<strong>用于表示各种变换</strong>！</p>
<h3 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h3><p>首先，用<strong>三个数</strong>来表示一个<strong>二维向量</strong>；</p>
<p><strong>相当于就是把二维变成三维，然后用特殊的数字去表示三维</strong>！</p>
<ul>
<li>点：第三维是 1</li>
<li>向量：第三维是 0</li>
</ul>
<p>这样就能通过齐次坐标的方式，把所有的变换都表示成 <strong>矩阵 x 向量</strong> 的形式；</p>
<p><img src="/images/Games101/03/10.png"></p>
<p><strong>为什么向量第三维是 0 ？</strong></p>
<p>这么做是为了保证向量的平移不变性；</p>
<p>同时保证了在一些运算下仍然是正确的；</p>
<p>在齐次坐标下：point1 + point2 &#x3D; point 1 2 的中点</p>
<p><img src="/images/Games101/03/11.png"></p>
<p>(x1,y1,w)转置 + (x2,y2,w)转置</p>
<p>&#x3D;&gt; ( (x1+x2) , (y1+y2) , 2w )转置</p>
<p>&#x3D;&gt; ( (x1+x2)&#x2F;2w , (y1+y2)&#x2F;2w , 1)</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><strong>仿射变换：</strong></p>
<p><img src="/images/Games101/03/12.png"></p>
<p><strong>齐次变换：</strong></p>
<p><img src="/images/Games101/03/13.png"></p>
<p>注意到，在表示<strong>二维坐标的仿射变换</strong>中，<strong>齐次变换矩阵</strong>的最后一行都是<strong>（0，0，1）</strong>；</p>
<p>注意是有条件的，二维坐标，仿射变换.</p>
<p><strong>验证：</strong>（缩放，旋转，平移）</p>
<p><img src="/images/Games101/03/14.png"></p>
<h2 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h2><p>要变换回来，则乘以<strong>变换矩阵的逆矩阵</strong></p>
<p><img src="/images/Games101/03/15.png"></p>
<h3 id="变换组合"><a href="#变换组合" class="headerlink" title="变换组合"></a>变换组合</h3><p>首先规定，这里默认的旋转是 以0,0为中心，逆时针 旋转的；</p>
<p>变换的顺序很重要；</p>
<p><strong>变换组合</strong> 其实本质上就是对应着 <strong>矩阵的乘法！！！</strong></p>
<p>当矩阵乘法的<strong>顺序不同</strong>，得到的变换<strong>结果</strong>也是<strong>不同</strong>的。</p>
<p><strong>举个例子</strong>：</p>
<p><img src="/images/Games101/03/16.png"></p>
<p>在这个变换中，我们需要先旋转45度，再平移；</p>
<p>那么对应的数学结果就是：</p>
<p><img src="/images/Games101/03/17.png"></p>
<p><strong>总结：</strong></p>
<p><strong>我们按照变换的顺序，在原向量的基础上，往原向量的左边，从右往左依次乘上变换矩阵</strong></p>
<p><img src="/images/Games101/03/18.png"></p>
<p><strong>值得注意的是</strong>：矩阵乘法有结合律！</p>
<h3 id="变换的分解"><a href="#变换的分解" class="headerlink" title="变换的分解"></a>变换的分解</h3><p><img src="/images/Games101/03/19.png"></p>
<h2 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h2><p>同理，在三维变换中，也有平移这样的非线性变换操作；</p>
<p>所以继续引入齐次坐标；</p>
<p>用四个数去表示三维空间；</p>
<p>三维变成四维，第四维度取特殊值；</p>
<ul>
<li>描述<strong>点</strong>，最后一维为1；</li>
<li>描述<strong>向量</strong>，最后一维为0；</li>
</ul>
<p><img src="/images/Games101/03/20.png"></p>
<p>当 w !&#x3D; 0 时，齐次坐标下的点 (x , y, z , w) , 则表示三维空间中的点 (x&#x2F;w , y&#x2F;w , z&#x2F;w)</p>
<p>将 x y z 都 &#x2F;w 就可以表示成三维空间中的点了！</p>
<p><img src="/images/Games101/03/21.png"></p>
<p>同样的，在描述三维空间中的反射变换时，变换矩阵的最后一行是（0，0，0，1）；</p>
<p>平移操作还是体现在最后一列；</p>
<p>值得注意的是 : </p>
<p>当我们写出齐次坐标的时候，它表示的其实是：<br><strong>先线性变换，在进行平移</strong>！</p>
<p><strong>具体的变换 :</strong> </p>
<p><img src="/images/Games101/03/22.png"></p>
<p><img src="/images/Games101/03/23.png"></p>
<p>这里注意一下绕y轴为啥是反的？这个和轴的顺序和右手螺旋定则有关；</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><img src="/images/Games101/03/24.png"></p>
<p>任意一个3D的旋转，都可以分解为分别绕x y z轴旋转；</p>
<p>a β γ 称为<strong>欧拉角</strong></p>
<p><strong>Rodrigues’ 旋转公式</strong>：</p>
<p>就是能把任意一个旋转分解为绕 x y z 的旋转：</p>
<p><img src="/images/Games101/03/25.png"></p>
<p>n向量：旋转轴（可以理解为一个方向向量，且规定n过原点）</p>
<p>a：旋转角度</p>
<p><strong>推导</strong>：</p>
<p><img src="/images/Games101/03/26.png"></p>
<p><strong>扩展 :</strong> </p>
<p><strong>四元数 : 主要用于两个旋转之间的插值</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/07/games101/Lec%2004/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/07/games101/Lec%2004/" class="post-title-link" itemprop="url">【Games 101】Lec 04：变换（续）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-07 22:28:30 / 修改时间：22:37:59" itemprop="dateCreated datePublished" datetime="2024-01-07T22:28:30+08:00">2024-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-04-Transformation-Cont"><a href="#Lecture-04-Transformation-Cont" class="headerlink" title="Lecture 04 : Transformation Cont."></a>Lecture 04 : Transformation Cont.</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/images/Games101/04/01.png"></p>
<ul>
<li><p><strong>View &#x2F; Camera transformation：视图变换 &#x2F; 相机变换</strong></p>
</li>
<li><p><strong>Projection transformation：投影变换</strong></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/554093703">图形学：正交&#x2F;透视投影矩阵的推导（多个思路） - 知乎 (zhihu.com)</a></p>
<p>上面这一边里面讲的非常清楚了 ! </p>
<h2 id="视图变换"><a href="#视图变换" class="headerlink" title="视图变换"></a>视图变换</h2><h3 id="试图变换是什么"><a href="#试图变换是什么" class="headerlink" title="试图变换是什么?"></a>试图变换是什么?</h3><p><strong>三元素 :</strong></p>
<ul>
<li>把场景搭好（<strong>model transformation，模型变换</strong>）</li>
<li>找一个好的角度，把相机放好（<strong>view transformation，视图变换</strong>）</li>
<li>然后拍照（<strong>projection transformation，投影变换</strong>）<br>简称 <strong>MVP 变换</strong></li>
</ul>
<p><img src="/images/Games101/04/02.png"></p>
<p><strong>特别解释 :</strong> </p>
<ol>
<li><strong>位置</strong>：这个没啥好说的…就是一个坐标</li>
<li><strong>凝视方向</strong>：也就是向哪里看，这里其实包含了两个方向，我们把头当作摄像机，那么凝视方向就包含了我们头<strong>左右看</strong>和<strong>上下看</strong>的元素（不歪头）</li>
<li><strong>向上方向</strong>：这个不是说向上看的意思…还是把我们的头当作摄像机，当我们确定了头的位置和凝视方向时，当我们歪头时，我们可以发现我们看到的还是不同的，所以我们还需要一个元素来约束；<strong>这里引入一个始终垂直于我们头顶的法向量，这个法向量指向的方向就是向上方向</strong>，当我们歪头时，这个法向量也不同；</li>
</ol>
<p>因此，通过上面这3个元素，我们可以唯一确定相机看到的图像！！！</p>
<h3 id="如何进行视图变换"><a href="#如何进行视图变换" class="headerlink" title="如何进行视图变换?"></a>如何进行视图变换?</h3><p>首先我们将相机定，其他东西都随相机移动；<br>（固定指的是：相机在0 0 0处，且x向前，y向上，-z向右）</p>
<p>具体操作：（初始相机在e点，看向g，向上是t，g叉乘t对应着x）</p>
<ul>
<li>先平移到 0 0 0</li>
<li>将 g 旋转到 -z </li>
<li>将 t 旋转到 y</li>
<li>最后将 g 叉乘 t 旋转到 x</li>
</ul>
<p><img src="/images/Games101/04/03.png"></p>
<p><strong>下面是矩阵表示</strong>：</p>
<p>直接求这个变换矩阵的话不太好求，我们可以反过来想：</p>
<p>将（x、y、-z）旋转到（g x t、t、g），得到旋转矩阵，将这个旋转矩阵求逆就是我们结果，注意到上节课的性质，这种变换的矩阵是<strong>正交矩阵</strong>，即 <strong>矩阵的逆&lt;&#x3D;&gt;矩阵的转置</strong>，所以直接求矩阵的转置就行。</p>
<p><img src="/images/Games101/04/04.png"></p>
<h2 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h2><h3 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h3><p><strong>无</strong>近大远小效果</p>
<p><img src="/images/Games101/04/07.png"></p>
<p>假设相机在 0 0 0 处，且看向-z方向，向右是x，向上是y；那么将相机x y范围内的的物体的z方向去掉得到的图像就是正交投影</p>
<p><img src="/images/Games101/04/08.png"></p>
<p><strong>更加规范的</strong>：</p>
<ol>
<li>先将物体的中心移到原点0 0 0</li>
<li>将物体进行缩放，缩放到（-1，1）³的立方体中<br>（这里长方体等物体会变得不一样… 后面会将再一次拉伸 ( <strong>视口变换</strong> )…）</li>
</ol>
<p><img src="/images/Games101/04/09.png"></p>
<p><img src="/images/Games101/04/10.png"></p>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>**概述 : **</p>
<p><strong>有</strong>近大远小效果</p>
<p><img src="/images/Games101/04/05.png"></p>
<p>回顾一下，前面我们讲了，齐次坐标（用四个数表示三维空间中的 点&#x2F;向量）</p>
<p><img src="/images/Games101/04/06.png"></p>
<p><strong>如何进行透视投影？</strong></p>
<p>还是那个问题，正面不好想，我们反着想；</p>
<p>透视投影要做的是将平面变成进平面 ( 挤压 ) ;</p>
<p>也就是如何 <strong>透视投影 -&gt; 正交投影</strong>，得到变换矩阵之后；求这个变换矩阵的逆，那么这个逆就是 <strong>正交投影 -&gt; 透视投影</strong> 的结果。</p>
<p><strong>透视投影 -&gt; 正交投影</strong></p>
<ol>
<li>将 透视投影 的梯形体挤压成长方体（近平面不变，远平面挤压，且远平面的z不变，且远平面的中心点的坐标仍然不变）</li>
<li>做一遍正交投影</li>
</ol>
<p>**具体分析 : **</p>
<p>第二步是比较简单的，上面说过了；</p>
<p><strong>下面分析第一步要怎么做？？？</strong></p>
<p>首先我们要明确一下我们的问题，现在的问题是：</p>
<p>如何将在透视投影中的点（x y z）变换为正交投影中的点（x’ y’ z’），也就是<strong>求</strong> 透视投影 -&gt; 正交投影 的<strong>变换矩阵</strong></p>
<p>首先我们可以发现变换时点在z轴上的变换是比较难求的，这里我们先不考虑z轴的情况，后面再求；</p>
<p>我们先看x轴和y轴的情况，可以发现他们形成一个相似三角形，因此 x’ x，y’ y 的关系很容易就知道了！</p>
<p><img src="/images/Games101/04/11.png"></p>
<p><img src="/images/Games101/04/12.png"></p>
<p>前面说过，齐次坐标下，每个数都同时乘上同一个数，这个<strong>点&#x2F;向量</strong>是<strong>不变</strong>的，表示的还是那个点；所以我们可以进一步的变换：</p>
<p><img src="/images/Games101/04/13.png"></p>
<p>接着我们试着反推一下这个变换矩阵：（什么样的矩阵 乘上 透视时的点 会变成 正交时的点？）</p>
<p><img src="/images/Games101/04/14.png"></p>
<p>可以发现，我们可以得到这个变换矩阵的大部分信息：</p>
<p><img src="/images/Games101/04/15.png"></p>
<p>由于我们把这个z轴给展示不管了，所以导致这个变换矩阵的第三行是未知的；现在我们需要通过一些性质去把第三行解出来；可以发现在变换前后有这样<strong>两个性质</strong>：</p>
<ul>
<li>变换前后，<strong>近</strong>平面上的<strong>点是不变的</strong>（x y z都不变）；</li>
<li>变换前后，<strong>远</strong>平面上的<strong>中心点是不变的</strong>（x y z都不变）；</li>
</ul>
<p>我们先利用第一个性质，假设在近平面上有一个点（x y n 1），那么变换之后还是（x y n 1），变换一下为（nx ny n² n）;</p>
<p><img src="/images/Games101/04/16.png"></p>
<p>利用上面的残缺矩阵，我们可知：</p>
<p>（？？？？）（x y n 1）转置 &#x3D; （nx ny n² n）转置</p>
<p>从而我们可以推出第三行：</p>
<p><img src="/images/Games101/04/17.png"></p>
<p>同时得到一个方程：</p>
<p><img src="/images/Games101/04/18.png"></p>
<p>接着我们利用第二个性质：远平面上的中心点为（0 0 f 1），变换后还是（0 0 f 1），同理变换一下（0 0 f² f）</p>
<p><img src="/images/Games101/04/19.png"></p>
<p>同样，我们可以的到一个方程：</p>
<p><img src="/images/Games101/04/20.png"></p>
<p>也就是说我们有两个未知数A B，有两个方程，这样就能解除A B，从而得到我们的变换矩阵了！</p>
<p><img src="/images/Games101/04/21.png"></p>
<p><img src="/images/Games101/04/22.png"></p>
<p>分析结束！！！</p>
<p><strong>注意 :</strong> </p>
<p>到这里 , 我们只是求出了 <strong>透视投影压缩变换</strong> , 也就是 <strong>透视投影 -&gt; 正交投影</strong> ;</p>
<p>所以如果要求<strong>透视投影矩阵</strong> , 我们还需要乘上一个 <strong>正交投影矩阵</strong> : </p>
<p><img src="/images/Games101/04/23.png"></p>
<p>具体的话可以再看一下这篇文章的分析 : </p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/554093703">图形学：正交&#x2F;透视投影矩阵的推导（多个思路） - 知乎 (zhihu.com)</a></p>
<p>**思考 : **</p>
<p>在近平面和远平面之间的点，从透视投影 -&gt; 正交投影的过程中，它们的z轴是向近缩，还是向远拉伸？？？</p>
<p><strong>题解</strong>：</p>
<p>离相机更远（更靠近远平面）</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/510906191">GANES101 透视投影的理解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="FJBQ"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">FJBQ</p>
  <div class="site-description" itemprop="description">坚定 坚持 坚强</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-10 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FJBQ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共30.3k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":225,"hOffset":-15,"vOffset":-15},"mobile":{"show":false},"react":{"opacity":1},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
