<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="坚定 坚持 坚强">
<meta property="og:type" content="website">
<meta property="og:title" content="FJBQ">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="FJBQ">
<meta property="og:description" content="坚定 坚持 坚强">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="FJBQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>FJBQ</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="FJBQ" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">FJBQ</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/30/games101/GAMES%20101%20%E9%9A%8F%E7%AC%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/30/games101/GAMES%20101%20%E9%9A%8F%E7%AC%94/" class="post-title-link" itemprop="url">Games 101 随笔 / 作业</a>
        </h2>

        <div class="post-meta">
          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-30 21:22:39" itemprop="dateCreated datePublished" datetime="2023-12-30T21:22:39+08:00">2023-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-29 21:47:07" itemprop="dateModified" datetime="2024-01-29T21:47:07+08:00">2024-01-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>准备学一下 Games 101, 这一篇记录一下学习笔记 ;</strong></p>
<p><strong>对应的应该还有 Games 101 作业 ( 希望能够坚持 ! )</strong></p>
<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/07/games101/Lec%2001/">【Games 101】Lec 01：计算机图形学概述</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/07/games101/Lec%2002/">【Games 101】Lec 02：回顾线性代数</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/07/games101/Lec%2003/">【Games 101】Lec 03：变换</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/07/games101/Lec%2004/">【Games 101】Lec 04：变换（续）</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/07/games101/Lec%2005/">【Games 101】Lec 05：光栅化1（三角形）</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/07/games101/Lec%2006/">【Games 101】Lec 06：光栅化2（抗锯齿 和 深度缓冲）</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/07/games101/Lec%2007/">【Games 101】Lec 07：渲染1（光照 阴影 和 图形管线）</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/07/games101/Lec%2008/">【Games 101】Lec 08：渲染2（阴影 渲染管线 和 纹理映射）</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/07/games101/Lec%2009/">【Games 101】Lec 09：渲染3（纹理映射（续））</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/07/games101/Lec%2010/">【Games 101】Lec 10：几何 1 （入门）</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/08/games101/Lec%2011/">【Games 101】Lec 11：几何 2 （曲线 和 曲面）</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/08/games101/Lec%2012/">【Games 101】Lec 12：几何 3</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/09/games101/Lec%2013/">【Games 101】Lec 13：光线追踪 1（Shadow Mapping，Whitted-Style Ray Tracing）</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/09/games101/Lec%2014/">【Games 101】Lec 14：光线追踪 2（加速光线追踪 和 辐射度量学）</a></p>
<p><a target="_blank" rel="noopener" href="https://fjbq-blog.top/2024/01/13/games101/Lec%2015/">【Games 101】Lec 15：光线追踪 3（辐射度量学，光传输，全局光照）</a></p>
<p><a target="_blank" rel="noopener" href="https://fjbq-blog.top/2024/01/13/games101/Lec%2016/">【Games 101】Lec 16：光线追踪 4（蒙特卡罗积分，路径追踪）</a></p>
<p><a target="_blank" rel="noopener" href="https://fjbq-blog.top/2024/01/13/games101/Lec%2017/">【Games 101】Lec 17：材质和外观</a></p>
<p><a target="_blank" rel="noopener" href="https://fjbq-blog.top/2024/01/20/games101/Lec%2018/">【Games 101】Lec 18：渲染的前沿话题</a></p>
<p><a target="_blank" rel="noopener" href="https://fjbq-blog.top/2024/01/20/games101/Lec%2019/">【Games 101】Lec 19：照相机、镜头、光场</a></p>
<p><a target="_blank" rel="noopener" href="https://fjbq-blog.top/2024/01/20/games101/Lec%2020/">【Games 101】Lec 20：颜色和感知</a></p>
<p><a target="_blank" rel="noopener" href="https://fjbq-blog.top/2024/01/21/games101/Lec%2021/">【Games 101】Lec 21：动画</a></p>
<p><a target="_blank" rel="noopener" href="https://fjbq-blog.top/2024/01/21/games101/Lec%2022/">【Games 101】Lec 22：动画（续）</a></p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p><strong>ps：做起来真的感觉不简单啊！</strong></p>
<p><a target="_blank" rel="noopener" href="https://fjbq-blog.top/2024/01/27/games101/HomeWork%200/">【Games 101】HomeWork 0：虚拟机的使用</a></p>
<p><a target="_blank" rel="noopener" href="https://fjbq-blog.top/2024/01/27/games101/HomeWork%201/">【Games 101】HomeWork 1：旋转与投影</a></p>
<p><a target="_blank" rel="noopener" href="https://fjbq-blog.top/2024/01/27/games101/HomeWork%202/">【Games 101】HomeWork 2：Triangles and Z-buffering（光栅化 和 抗锯齿）</a></p>
<p><a target="_blank" rel="noopener" href="https://fjbq-blog.top/2024/01/27/games101/HomeWork%203/">【Games 101】HomeWork 3：Pipeline and Shading（渲染小奶牛）</a></p>
<p><a target="_blank" rel="noopener" href="https://fjbq-blog.top/2024/01/27/games101/HomeWork%204/">【Games 101】HomeWork 4：Bézier 曲线</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><strong>可以参考这三个大佬的分析</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/cheng-feng-28-76/posts">Keanu - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/stardustToStardust/posts">柚子没有贝壳味 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489?type=blog">Magic__Conch-CSDN博客</a></p>
<p><strong>Eigen 库：</strong></p>
<p><a target="_blank" rel="noopener" href="https://eigen.tuxfamily.org/dox/">Eigen: Main Page</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hongge_smile/article/details/107296658">Eigen库学习教程(全)_find_package(eigen3 3 required)-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/293023673">快速入门矩阵运算——开源库Eigen - 知乎 (zhihu.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/27/games101/HomeWork%200/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/27/games101/HomeWork%200/" class="post-title-link" itemprop="url">【Games 101】HomeWork 0：虚拟机的使用</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-27 23:51:29 / 修改时间：23:59:09" itemprop="dateCreated datePublished" datetime="2024-01-27T23:51:29+08:00">2024-01-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HomeWork-0：虚拟机的使用"><a href="#HomeWork-0：虚拟机的使用" class="headerlink" title="HomeWork 0：虚拟机的使用"></a>HomeWork 0：虚拟机的使用</h1><p>配环境…</p>
<p>真的是一波三折啊，捣鼓了好久…</p>
<p>还好虚拟机里面什么都有了</p>
<p>首先按照 pdf 里面的流程走就行了，下面记录一下一些问题：</p>
<h2 id="黑屏…"><a href="#黑屏…" class="headerlink" title="黑屏…"></a>黑屏…</h2><p>我是重启之后就会黑屏，还没输入密码呢…</p>
<p>这个问题我直接删掉虚拟机，如何重新创建一个就好了；</p>
<h2 id="安装-增强功能-显示-无法挂载光盘什么的"><a href="#安装-增强功能-显示-无法挂载光盘什么的" class="headerlink" title="安装 增强功能 显示 无法挂载光盘什么的"></a>安装 增强功能 显示 无法挂载光盘什么的</h2><p>首先检查一下虚拟机是否有 VBox_GAs_… 光盘，有的话先弹出他，然后再尝试安装；</p>
<p>然后可能会失败，看下面这两篇：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/560813527">VirtualBox 安装 ubuntu后安装增强工具无效的解决办法 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34777600/article/details/99337930">VirtualBox：unable to access “VBox_GAS_6.8.XXX-CSDN博客</a></p>
<p>成功安装之后就能：</p>
<p>调整虚拟机的分辨率；</p>
<p>主机和虚拟机之间拖拽文件；</p>
<p>等；</p>
<p>然后继续照着 pdf 里面操作就行了</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>下面是作业0的代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;eigen3/Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;eigen3/Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这个一些基本运算</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Example of cpp \n&quot;</span>;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">1.0</span>, b = <span class="number">2.0</span>;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; a/b &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">sqrt</span>(b) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">acos</span>(<span class="number">-1</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">sin</span>(<span class="number">30.0</span>/<span class="number">180.0</span>*<span class="built_in">acos</span>(<span class="number">-1</span>)) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Example of vector</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Example of vector \n&quot;</span>;</span><br><span class="line">    <span class="comment">//这个 Vector3f 是定义了一个三维向量，float(注意这里其实也就是一个 3x1 的矩阵)</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">v</span><span class="params">(<span class="number">1.0f</span>,<span class="number">2.0f</span>,<span class="number">3.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">w</span><span class="params">(<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    <span class="comment">// vector output</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Example of output \n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// vector add</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Example of add \n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; v + w &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// vector scalar multiply</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Example of scalar multiply \n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; v * <span class="number">3.0f</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">2.0f</span> * v &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Example of matrix</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Example of matrix \n&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这个 Matrix3f 是定义了一个3x3的float的矩阵；</span></span><br><span class="line"><span class="comment">        其实跳进去看源码就知道了，通过模板和宏定义实现的；</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    Eigen::Matrix3f i,j,ans;</span><br><span class="line">    i &lt;&lt; <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>, <span class="number">9.0</span>;</span><br><span class="line">    j &lt;&lt; <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">1.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>, <span class="number">5.0</span>, <span class="number">9.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>;</span><br><span class="line">    <span class="comment">// matrix output</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Example of output \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// matrix add i + j</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this is matrix add : \n&quot;</span>;</span><br><span class="line">    ans = i + j;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// matrix scalar multiply i * 2.0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this is matrix scalar multiply : \n&quot;</span>;</span><br><span class="line">    ans = i * <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// matrix multiply i * j</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this is matrix multiply : \n&quot;</span>;</span><br><span class="line">    ans = i * j;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    matrix multiply vector i * v</span></span><br><span class="line"><span class="comment">    这个就是定义一个自定义大小的float矩阵，我这里定义的是 1x3 的；</span></span><br><span class="line"><span class="comment">    因为 v 是一个 1x3 的，i 是一个 3x3 的；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this is matrix multiply vector : \n&quot;</span>;</span><br><span class="line">    <span class="function">Eigen::MatrixXf <span class="title">ans1</span><span class="params">(<span class="number">1</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    ans1 = i * v;</span><br><span class="line">    cout &lt;&lt; ans1 &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作业描述:</span></span><br><span class="line"><span class="comment">    给定一个点 P=(2,1), 将该点绕原点先逆时针旋转 45◦，再平移 (1,2), 计算出变换后点的坐标（要求用齐次坐标进行计算）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">    1. 首先说到要用齐次坐标表示，我们回顾一下，2维的点用齐次坐标表示，则需要加上一个1的维，也就是（2，1，1）；</span></span><br><span class="line"><span class="comment">    2. 然后平移旋转，我们可以构造一个旋转矩阵，然后将这个坐标和这个旋转矩阵相乘，完成旋转变换；</span></span><br><span class="line"><span class="comment">    3. 最后对于平移，我们同样可以构造一个平移矩阵，然后相乘就行，完成平移变换；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    想不起来的可以回顾一下这里：http://fjbq-blog.top/2023/12/30/GAMES%20101%20%E9%9A%8F%E7%AC%94/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将角度转换为弧度</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">DegToRad</span><span class="params">(<span class="type">double</span> Deg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Deg / <span class="number">180.0</span> * M_PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// (2,1) 的点的齐次坐标表示（3 x 1 的矩阵）</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">Point</span><span class="params">(<span class="number">2.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转变换</span></span><br><span class="line">    <span class="type">double</span> Deg = <span class="number">45.0</span>;</span><br><span class="line">    <span class="type">double</span> Rad = <span class="built_in">DegToRad</span>(Deg);</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix3f RotationMatrix;</span><br><span class="line">    RotationMatrix  &lt;&lt;  <span class="built_in">cos</span>(Rad), -<span class="built_in">sin</span>(Rad), <span class="number">0</span>,</span><br><span class="line">                        <span class="built_in">sin</span>(Rad), <span class="built_in">cos</span>(Rad), <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    Point = RotationMatrix * Point;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;旋转变换之后：\n&quot;</span> &lt;&lt; Point &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平移变换</span></span><br><span class="line">    <span class="type">double</span> tx = <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">double</span> ty = <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix3f TranslationMatrix;</span><br><span class="line">    TranslationMatrix &lt;&lt;    <span class="number">1</span>, <span class="number">0</span>, tx,</span><br><span class="line">                            <span class="number">0</span>, <span class="number">1</span>, ty,</span><br><span class="line">                            <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Point = TranslationMatrix * Point;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最终结果：\n&quot;</span> &lt;&lt; Point &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="/images/Games101/homework/00/00.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/27/games101/HomeWork%204/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/27/games101/HomeWork%204/" class="post-title-link" itemprop="url">【Games 101】HomeWork 4：Bézier 曲线</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-27 23:26:46 / 修改时间：23:59:30" itemprop="dateCreated datePublished" datetime="2024-01-27T23:26:46+08:00">2024-01-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HomeWork-4：Bezier-曲线"><a href="#HomeWork-4：Bezier-曲线" class="headerlink" title="HomeWork 4：Bézier 曲线"></a>HomeWork 4：Bézier 曲线</h1><p>这个挺简单的，挺有意思的：</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 套公式求的 贝塞尔 曲线</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">naive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_0 = points[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_1 = points[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_2 = points[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_3 = points[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> t = <span class="number">0.0</span>; t &lt;= <span class="number">1.0</span>; t += <span class="number">0.001</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> point = std::<span class="built_in">pow</span>(<span class="number">1</span> - t, <span class="number">3</span>) * p_0 + <span class="number">3</span> * t * std::<span class="built_in">pow</span>(<span class="number">1</span> - t, <span class="number">2</span>) * p_1 +</span><br><span class="line">                 <span class="number">3</span> * std::<span class="built_in">pow</span>(t, <span class="number">2</span>) * (<span class="number">1</span> - t) * p_2 + std::<span class="built_in">pow</span>(t, <span class="number">3</span>) * p_3;</span><br><span class="line"></span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归做法的贝塞尔曲线</span></span><br><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="type">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 只剩一个控制点的时候就能返回了</span></span><br><span class="line">    <span class="keyword">if</span>(control_points.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> control_points[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    std::vector&lt;cv::Point2f&gt; temp_control_points;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; control_points.<span class="built_in">size</span>()<span class="number">-1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这个比较简单，看着图推一下就行</span></span><br><span class="line">        cv::Point2f temp_point = control_points[i] - (control_points[i] - control_points[i+<span class="number">1</span>]) * t;</span><br><span class="line">        temp_control_points.<span class="built_in">push_back</span>(temp_point);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recursive_bezier</span>(temp_control_points, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现绘制 Bézier 曲线的功能（传进来一组控制点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1000 个 t</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">float</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t += <span class="number">0.001f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Point2f point = <span class="built_in">recursive_bezier</span>(control_points, t);</span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面是贝塞尔曲线：</strong><br><strong>红色：公式</strong><br><strong>绿色：递归</strong><br><strong>黄色：两个同时调用的结果</strong></p>
<p><img src="/images/Games101/homework/04/01.png"></p>
<p><img src="/images/Games101/homework/04/02.png"></p>
<p><img src="/images/Games101/homework/04/03.png"></p>
<p><strong>提高：（反走样）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    做一下反走样</span></span><br><span class="line"><span class="comment">    https://zhuanlan.zhihu.com/p/464122963</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bezier_2</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> t = <span class="number">0.0</span>; t &lt;= <span class="number">1.0</span>; t += <span class="number">0.001</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Point2f point = <span class="built_in">recursive_bezier</span>(control_points, t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求距离点 point 最近的四个像素的像素交点中心（其实就是右下角的像素的起点）</span></span><br><span class="line">        cv::Point2i p0;</span><br><span class="line">        p0.x = point.x-std::<span class="built_in">floor</span>(point.x) &lt; <span class="number">0.5</span> ? std::<span class="built_in">floor</span>(point.x) : std::<span class="built_in">ceil</span>(point.x);</span><br><span class="line">        p0.y = point.y-std::<span class="built_in">floor</span>(point.y) &lt; <span class="number">0.5</span> ? std::<span class="built_in">floor</span>(point.y) : std::<span class="built_in">ceil</span>(point.y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 点 point 最近的四个像素点的起点</span></span><br><span class="line">        std::vector&lt;cv::Point2i&gt; ps;</span><br><span class="line">        ps.<span class="built_in">push_back</span>(p0);</span><br><span class="line">        ps.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2i</span>(p0.x<span class="number">-1</span>, p0.y));</span><br><span class="line">        ps.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2i</span>(p0.x, p0.y<span class="number">-1</span>));</span><br><span class="line">        ps.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2i</span>(p0.x<span class="number">-1</span>, p0.y<span class="number">-1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 点 p 到相邻四个点的中心点的距离</span></span><br><span class="line">        <span class="type">float</span> sum_d = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="type">float</span> max_d = <span class="built_in">sqrt</span>(<span class="number">2</span>);</span><br><span class="line">        std::vector&lt;<span class="type">float</span>&gt; ds = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 像素点的中心</span></span><br><span class="line">            <span class="function">cv::Point2f <span class="title">cp</span><span class="params">(ps[i].x + <span class="number">0.5f</span>, ps[i].y + <span class="number">0.5f</span>)</span></span>;</span><br><span class="line">            <span class="type">float</span> d = max_d - std::<span class="built_in">sqrt</span>(std::<span class="built_in">pow</span>(point.x - cp.x, <span class="number">2</span>) + std::<span class="built_in">pow</span>(point.y - cp.y, <span class="number">2</span>));</span><br><span class="line">            ds.<span class="built_in">push_back</span>(d);</span><br><span class="line">            sum_d += d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求一下加权的颜色直就行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> k = ds[i] / sum_d;</span><br><span class="line">            window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(ps[i].y, ps[i].x)[<span class="number">1</span>] = std::<span class="built_in">min</span>(<span class="number">255.f</span>, window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(ps[i].y, ps[i].x)[<span class="number">1</span>] + <span class="number">255.f</span> * k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>反走样对比，效果还是挺明显的：</strong></p>
<p><img src="/images/Games101/homework/04/04.png"></p>
<p><img src="/images/Games101/homework/04/05.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/27/games101/HomeWork%203/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/27/games101/HomeWork%203/" class="post-title-link" itemprop="url">【Games 101】HomeWork 3：Pipeline and Shading（渲染小奶牛）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-27 23:26:46" itemprop="dateCreated datePublished" datetime="2024-01-27T23:26:46+08:00">2024-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-28 00:03:36" itemprop="dateModified" datetime="2024-01-28T00:03:36+08:00">2024-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HomeWork-3：Pipeline-and-Shading（渲染小奶牛）"><a href="#HomeWork-3：Pipeline-and-Shading（渲染小奶牛）" class="headerlink" title="HomeWork 3：Pipeline and Shading（渲染小奶牛）"></a>HomeWork 3：Pipeline and Shading（渲染小奶牛）</h1><p>这次作业是渲染小奶牛，有 法线，Binne-Pong，纹理贴图，凹凸贴图，位移贴图；</p>
<p>这个作业好多呀，感觉挺难的…</p>
<p>得参考这几篇文章：</p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/07/games101/Lec%2007/">【Games 101】Lec 07：渲染1（光照 阴影 和 图形管线）</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/07/games101/Lec%2008/">【Games 101】Lec 08：渲染2（阴影 渲染管线 和 纹理映射）</a></p>
<p><a target="_blank" rel="noopener" href="http://fjbq-blog.top/2024/01/07/games101/Lec%2009/">【Games 101】Lec 09：渲染3（纹理映射（续））</a></p>
<h2 id="法线"><a href="#法线" class="headerlink" title="法线"></a>法线</h2><p>首先实现一个法线的：</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取投影矩阵（直接搬前面的就行）</span></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_projection_matrix</span><span class="params">(<span class="type">float</span> eye_fov, <span class="type">float</span> aspect_ratio, <span class="type">float</span> zNear, <span class="type">float</span> zFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Matrix4f projection = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 透视投影压缩矩阵</span></span><br><span class="line">    Eigen::Matrix4f M_persp;</span><br><span class="line">    M_persp &lt;&lt;  zNear, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, zNear, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, zNear + zFar, -zNear*zFar,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求一下正交投影矩阵要用到的参数</span></span><br><span class="line">    <span class="type">float</span> alpha = <span class="number">0.5</span> * (eye_fov / <span class="number">180.0f</span> * MY_PI);     <span class="comment">// 视野角度的一半</span></span><br><span class="line">    <span class="type">float</span> yTop = -zNear * <span class="built_in">tan</span>(alpha);              <span class="comment">// 因为这里的z给的是负数，所以加负号之后再转换</span></span><br><span class="line">    <span class="type">float</span> yBottom = -yTop;</span><br><span class="line">    <span class="type">float</span> xRight = yTop * aspect_ratio;                 <span class="comment">// aspect_ratio 是 xy 的比例</span></span><br><span class="line">    <span class="type">float</span> xLeft = -xRight;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix4f M_trans;</span><br><span class="line">    M_trans &lt;&lt;  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -(xLeft + xRight) / <span class="number">2</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -(yTop + yBottom) / <span class="number">2</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -(zNear + zFar) / <span class="number">2</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix4f M_ortho;</span><br><span class="line">    M_ortho &lt;&lt;  <span class="number">2</span> / (xRight - xLeft), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">2</span> / (yTop - yBottom), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span> / (zNear - zFar), <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个就是 正交投影矩阵</span></span><br><span class="line">    M_ortho = M_ortho * M_trans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 透视投影矩阵 = 正交投影矩阵 * 透视压缩矩阵（注意顺序哦）</span></span><br><span class="line">    projection = M_ortho * M_persp * projection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> projection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>rasterizer.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    三角形光栅化</span></span><br><span class="line"><span class="comment">    view_pos 是三角形三个顶点的试图坐标，视图坐标是指相机空间（或观察空间）中的坐标，即相对于相机的坐标。</span></span><br><span class="line"><span class="comment">    以支持在屏幕空间内进行插值和渲染</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">rasterize_triangle</span>(<span class="type">const</span> Triangle&amp; t, <span class="type">const</span> std::array&lt;Eigen::Vector3f, <span class="number">3</span>&gt;&amp; view_pos) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> min_x = INT_MAX;</span><br><span class="line">    <span class="type">int</span> max_x = INT_MIN;</span><br><span class="line">    <span class="type">int</span> min_y = INT_MAX;</span><br><span class="line">    <span class="type">int</span> max_y = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求一下三角形的包围盒</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> point : v) <span class="comment">//获取包围盒边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        min_x = <span class="built_in">min</span>((<span class="type">float</span>)min_x, point[<span class="number">0</span>]);</span><br><span class="line">        max_x = <span class="built_in">max</span>((<span class="type">float</span>)max_x, point[<span class="number">0</span>]);</span><br><span class="line">        min_y = <span class="built_in">min</span>((<span class="type">float</span>)min_y, point[<span class="number">1</span>]);</span><br><span class="line">        max_y = <span class="built_in">max</span>((<span class="type">float</span>)max_y, point[<span class="number">1</span>]);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历包围盒里面的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = min_y; y &lt;= max_y; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = min_x; x &lt;= max_x; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">insideTriangle</span>((<span class="type">float</span>)x+<span class="number">0.5</span>, (<span class="type">float</span>)y+<span class="number">0.5</span>, t.v))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 求一下三角形重心坐标</span></span><br><span class="line">                <span class="keyword">auto</span>[alpha, beta, gamma] = <span class="built_in">computeBarycentric2D</span>(x+<span class="number">0.5</span>, y+<span class="number">0.5</span>, t.v);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 求一下深度</span></span><br><span class="line">                <span class="type">float</span> w_reciprocal = <span class="number">1.0</span>/(alpha / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">                <span class="type">float</span> z_interpolated = alpha * v[<span class="number">0</span>].<span class="built_in">z</span>() / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * v[<span class="number">1</span>].<span class="built_in">z</span>() / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * v[<span class="number">2</span>].<span class="built_in">z</span>() / v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">                z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断当前z值是否小于原来z表此位置的z值</span></span><br><span class="line">                <span class="keyword">if</span> (z_interpolated &lt; depth_buf[<span class="built_in">get_index</span>(x, y)]) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 颜色插值</span></span><br><span class="line">                    <span class="keyword">auto</span> interpolated_color = <span class="built_in">interpolate</span>(alpha, beta, gamma, t.color[<span class="number">0</span>], t.color[<span class="number">1</span>], t.color[<span class="number">2</span>], <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 法线插值(需要归一化 .normalized())</span></span><br><span class="line">                    <span class="keyword">auto</span> interpolated_normal = <span class="built_in">interpolate</span>(alpha, beta, gamma, t.normal[<span class="number">0</span>], t.normal[<span class="number">1</span>], t.normal[<span class="number">2</span>], <span class="number">1.0f</span>).<span class="built_in">normalized</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 纹理插值</span></span><br><span class="line">                    <span class="keyword">auto</span> interpolated_texcoords = <span class="built_in">interpolate</span>(alpha, beta, gamma, t.tex_coords[<span class="number">0</span>], t.tex_coords[<span class="number">1</span>], t.tex_coords[<span class="number">2</span>], <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 视图坐标插值</span></span><br><span class="line">                    <span class="keyword">auto</span> interpolated_shadingcoords = <span class="built_in">interpolate</span>(alpha,beta,gamma,view_pos[<span class="number">0</span>],view_pos[<span class="number">1</span>],view_pos[<span class="number">2</span>],<span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 用一个结构体存一下</span></span><br><span class="line">                    <span class="function">fragment_shader_payload <span class="title">payload</span><span class="params">( interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &amp;*texture : <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">                    payload.view_pos = interpolated_shadingcoords;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 传给片段着色器，获取最终颜色</span></span><br><span class="line">                    <span class="keyword">auto</span> pixel_color = <span class="built_in">fragment_shader</span>(payload);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 更新深度缓存，并设置像素的颜色</span></span><br><span class="line">                    depth_buf[<span class="built_in">get_index</span>(x,y)] = z_interpolated;</span><br><span class="line">                    <span class="built_in">set_pixel</span>(<span class="built_in">Vector2i</span>(x,y),pixel_color);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能按照 pdf 里面的操作运行啦，结果如下：</p>
<p><img src="/images/Games101/homework/03/01.png"></p>
<h2 id="Binne-Pong"><a href="#Binne-Pong" class="headerlink" title="Binne-Pong"></a>Binne-Pong</h2><p><strong>main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Blinn-Phong 片段渲染器</span></span><br><span class="line"><span class="comment">    Blinn-Phong 模型 = 环境反射 + 漫反射模型 + 高光反射/镜面反射</span></span><br><span class="line"><span class="comment">    总结：边看笔记的公式边写就行（主要是得搞清楚代码里面的每个变量到底是啥）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">phong_fragment_shader</span><span class="params">(<span class="type">const</span> fragment_shader_payload&amp; payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Ambient 环境反射的系数</span></span><br><span class="line">    Eigen::Vector3f ka = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.005</span>, <span class="number">0.005</span>, <span class="number">0.005</span>);</span><br><span class="line">    <span class="comment">// Diffuse 漫反射系数</span></span><br><span class="line">    Eigen::Vector3f kd = payload.color;</span><br><span class="line">    <span class="comment">// Specular 高光反射</span></span><br><span class="line">    Eigen::Vector3f ks = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.7937</span>, <span class="number">0.7937</span>, <span class="number">0.7937</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义两个光源</span></span><br><span class="line">    <span class="keyword">auto</span> l1 = light&#123;&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> l2 = light&#123;&#123;<span class="number">-20</span>, <span class="number">20</span>, <span class="number">0</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环境反射的 Ia（也是就环境光的强度）</span></span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视点</span></span><br><span class="line">    Eigen::Vector3f eye_pos&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指数 p 的一个作用：控制高光的衰减大小（可以在笔记中搜索这句话）</span></span><br><span class="line">    <span class="type">float</span> p = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表面的 颜色，视图位置，法线</span></span><br><span class="line">    Eigen::Vector3f color = payload.color;</span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终的光</span></span><br><span class="line">    Eigen::Vector3f result_color = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 环境反射，漫反射，高光反射</span></span><br><span class="line">    Eigen::Vector3f ambient=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    Eigen::Vector3f diffuse=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    Eigen::Vector3f specular=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于每条光线，计算 漫反射 和 高光反射（环境光始终不变，最后加上去就行）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            计算漫反射</span></span><br><span class="line"><span class="comment">            - light.intensity：是光强，也就是公式中的 I</span></span><br><span class="line"><span class="comment">            - r_squared：物体与光源距离的平方（也就是公式中的 r^2）</span></span><br><span class="line"><span class="comment">            - light.position - point：表示的是光线到表面的向量（也就是公式中的 I，可以看一下 &quot;漫反射模型&quot;）</span></span><br><span class="line"><span class="comment">            - 从&quot;漫反射模型&quot;笔记里面可以看到，normal.dot(((light.position - point).normalized())) 这一项就是在求一个角度</span></span><br><span class="line"><span class="comment">            - cwiseProduct：是Eigen库中的一个函数，用于对两个向量进行逐元素乘法。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">float</span> r_squared=(light.position - point).<span class="built_in">squaredNorm</span>();</span><br><span class="line">        diffuse = kd.<span class="built_in">cwiseProduct</span>(light.intensity / r_squared) * <span class="built_in">MAX</span>(<span class="number">0</span>, normal.<span class="built_in">dot</span>(((light.position - point).<span class="built_in">normalized</span>())));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            计算高光反射</span></span><br><span class="line"><span class="comment">            - h：入射与反射光的半程向量</span></span><br><span class="line"><span class="comment">            - light.position - point：表示的是 光线 到表面的向量</span></span><br><span class="line"><span class="comment">            - eye_pos - point：表示的是 眼睛 到表面的向量</span></span><br><span class="line"><span class="comment">            - 计算高光的时候，一定要注意p次幂</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 套公式</span></span><br><span class="line">        <span class="keyword">auto</span> h = ((light.position - point).<span class="built_in">normalized</span>() + (eye_pos - point).<span class="built_in">normalized</span>()).<span class="built_in">normalized</span>();</span><br><span class="line">        specular = ks.<span class="built_in">cwiseProduct</span>(light.intensity / r_squared) * std::<span class="built_in">pow</span>(std::<span class="built_in">max</span>(<span class="number">0.0f</span>, normal.<span class="built_in">dot</span>(h)), p); </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 环境反射（放外面只算一次的话，渲染出来看起来就比较暗一点）</span></span><br><span class="line">        ambient = ka.<span class="built_in">cwiseProduct</span>(amb_light_intensity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后加和一下</span></span><br><span class="line">        result_color += (ambient + diffuse + specular);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result_color * <span class="number">255.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/images/Games101/homework/03/02.png"></p>
<h2 id="纹理贴图（texture）"><a href="#纹理贴图（texture）" class="headerlink" title="纹理贴图（texture）"></a>纹理贴图（texture）</h2><p><strong>main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    纹理片段渲染器</span></span><br><span class="line"><span class="comment">    在实现 Blinn-Phong的基础上,将纹理颜色视为公式中的 kd,实现 Texture Shading Fragment Shader.</span></span><br><span class="line"><span class="comment">    - 使用uv坐标调用纹理get_color函数。</span></span><br><span class="line"><span class="comment">    - uv坐标是rasterize_triangle函数中插值得到的。</span></span><br><span class="line"><span class="comment">    - 用对应点纹理的颜色替换漫反射kd系数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">texture_fragment_shader</span><span class="params">(<span class="type">const</span> fragment_shader_payload&amp; payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> Limit_Number = [](<span class="type">float</span> &amp;number)&#123;</span><br><span class="line">        number = <span class="built_in">max</span>(number, (<span class="type">float</span>)<span class="number">0.0</span>);</span><br><span class="line">        number = <span class="built_in">min</span>(number, (<span class="type">float</span>)<span class="number">1.0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f return_color = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (payload.texture)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 纹理坐标 u v（应该在 [0,1] 之间，限制一下，避免越界）</span></span><br><span class="line">        <span class="type">float</span> u = payload.tex_coords.<span class="built_in">x</span>();</span><br><span class="line">        <span class="type">float</span> v = payload.tex_coords.<span class="built_in">y</span>();</span><br><span class="line">        <span class="built_in">Limit_Number</span>(u);</span><br><span class="line">        <span class="built_in">Limit_Number</span>(v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取对应纹理坐标的颜色</span></span><br><span class="line">        return_color = payload.texture-&gt;<span class="built_in">getColor</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    Eigen::Vector3f texture_color;</span><br><span class="line">    texture_color &lt;&lt; return_color.<span class="built_in">x</span>(), return_color.<span class="built_in">y</span>(), return_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f ka = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.005</span>, <span class="number">0.005</span>, <span class="number">0.005</span>);</span><br><span class="line">    <span class="comment">// 将对应点的纹理颜色替换成漫反射kd系数</span></span><br><span class="line">    Eigen::Vector3f kd = texture_color / <span class="number">255.f</span>;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.7937</span>, <span class="number">0.7937</span>, <span class="number">0.7937</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> l1 = light&#123;&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> l2 = light&#123;&#123;<span class="number">-20</span>, <span class="number">20</span>, <span class="number">0</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> p = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = texture_color;</span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面也是一样的 Blinn-Phong</span></span><br><span class="line">    Eigen::Vector3f result_color = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Eigen::Vector3f ambient=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    Eigen::Vector3f diffuse=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    Eigen::Vector3f specular=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于每条光线，计算 漫反射 和 高光反射（环境光始终不变，最后加上去就行）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 漫反射</span></span><br><span class="line">        <span class="type">float</span> r_squared=(light.position - payload.view_pos).<span class="built_in">squaredNorm</span>();</span><br><span class="line">        diffuse = kd.<span class="built_in">cwiseProduct</span>(light.intensity / r_squared) * <span class="built_in">MAX</span>(<span class="number">0</span>, normal.<span class="built_in">dot</span>(((light.position - point).<span class="built_in">normalized</span>())));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 高光反射</span></span><br><span class="line">        <span class="keyword">auto</span> h = ((light.position - point).<span class="built_in">normalized</span>() + (eye_pos - point).<span class="built_in">normalized</span>()).<span class="built_in">normalized</span>();</span><br><span class="line">        specular = ks.<span class="built_in">cwiseProduct</span>(light.intensity / r_squared) * std::<span class="built_in">pow</span>(std::<span class="built_in">max</span>(<span class="number">0.0f</span>, normal.<span class="built_in">dot</span>(h)), p); </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 环境反射（放外面只算一次的话，渲染出来看起来就比较暗一点）</span></span><br><span class="line">        ambient = ka.<span class="built_in">cwiseProduct</span>(amb_light_intensity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后加和一下</span></span><br><span class="line">        result_color += (ambient + diffuse + specular);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_color * <span class="number">255.f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="/images/Games101/homework/03/03.png"></p>
<h2 id="凹凸贴图（Bump-Mapping）"><a href="#凹凸贴图（Bump-Mapping）" class="headerlink" title="凹凸贴图（Bump Mapping）"></a>凹凸贴图（Bump Mapping）</h2><p><strong>main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Bump Mapping 片段渲染器（凹凸贴图）</span></span><br><span class="line"><span class="comment">    这个好难，建议回去看看视频（P10 前半部分）</span></span><br><span class="line"><span class="comment">    再结合TBN矩阵的求法和应用。</span></span><br><span class="line"><span class="comment">    TBN 矩阵就是世界空间到切线空间之间互相转变的桥梁：</span></span><br><span class="line"><span class="comment">        - 世界空间 = 切线空间 x TBN矩阵</span></span><br><span class="line"><span class="comment">        - 切线空间 = 世界空间 x TBN矩阵的逆</span></span><br><span class="line"><span class="comment">    照着TODO里面写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">bump_fragment_shader</span><span class="params">(<span class="type">const</span> fragment_shader_payload&amp; payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> Limit_Number = [](<span class="type">float</span> &amp;number)&#123;</span><br><span class="line">        number = <span class="built_in">max</span>(number, (<span class="type">float</span>)<span class="number">0.0</span>);</span><br><span class="line">        number = <span class="built_in">min</span>(number, (<span class="type">float</span>)<span class="number">1.0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里 .norm 求范数；</span></span><br><span class="line"><span class="comment">        这里巨坑...</span></span><br><span class="line"><span class="comment">        这里 u v 会大于1...</span></span><br><span class="line"><span class="comment">        导致 getColor(u, v) 的时候会数组越界...所以需要限制一下</span></span><br><span class="line"><span class="comment">        调了一下午了...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">auto</span> func_h = [&amp;payload, Limit_Number](<span class="type">float</span> u, <span class="type">float</span> v) -&gt; <span class="keyword">auto</span> &#123;</span><br><span class="line">        <span class="built_in">Limit_Number</span>(u);</span><br><span class="line">        <span class="built_in">Limit_Number</span>(v);</span><br><span class="line">        <span class="keyword">return</span> payload.texture-&gt;<span class="built_in">getColor</span>(u, v).<span class="built_in">norm</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里 payload 关联的贴图应该是凹凸贴图</span></span><br><span class="line">    Eigen::Vector3f ka = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.005</span>, <span class="number">0.005</span>, <span class="number">0.005</span>);</span><br><span class="line">    Eigen::Vector3f kd = payload.color;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.7937</span>, <span class="number">0.7937</span>, <span class="number">0.7937</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> l1 = light&#123;&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> l2 = light&#123;&#123;<span class="number">-20</span>, <span class="number">20</span>, <span class="number">0</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> p = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color; </span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> kh = <span class="number">0.2</span>, kn = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n是原来模型空间的法线</span></span><br><span class="line">    Eigen::Vector3f n = normal;</span><br><span class="line">    <span class="type">float</span> x = n.<span class="built_in">x</span>(), y = n.<span class="built_in">y</span>(), z = n.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算得到法线空间的基向量t和b(法线空间中，n与模型空间一致)</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">t</span><span class="params">(x*y / sqrt(x*x + z*z), sqrt(x*x + z*z), z*y / sqrt(x*x + z*z))</span></span>;</span><br><span class="line">    Eigen::Vector3f b = n.<span class="built_in">cross</span>(t);</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix3f TBN; <span class="comment">//TBN矩阵: 将纹理坐标对应到模型空间中</span></span><br><span class="line">    TBN &lt;&lt;  t.<span class="built_in">x</span>(), b.<span class="built_in">x</span>(), n.<span class="built_in">x</span>(),</span><br><span class="line">            t.<span class="built_in">y</span>(), b.<span class="built_in">y</span>(), n.<span class="built_in">y</span>(),</span><br><span class="line">            t.<span class="built_in">z</span>(), b.<span class="built_in">z</span>(), n.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纹理坐标和大小</span></span><br><span class="line">    <span class="type">float</span> u = payload.tex_coords.<span class="built_in">x</span>(), v = payload.tex_coords.<span class="built_in">y</span>();</span><br><span class="line">    <span class="type">float</span> w = payload.texture-&gt;width, h = payload.texture-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> dU = kh * kn * (<span class="built_in">func_h</span>(u+<span class="number">1</span>/w, v) - <span class="built_in">func_h</span>(u,v));</span><br><span class="line">    <span class="type">float</span> dV = kh * kn * (<span class="built_in">func_h</span>(u, v+<span class="number">1</span>/h) - <span class="built_in">func_h</span>(u,v));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得切线空间中法线的坐标</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">ln</span><span class="params">(-dU, -dV, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将它转换到模型空间中</span></span><br><span class="line">    normal = (TBN * ln).<span class="built_in">normalized</span>();</span><br><span class="line">    result_color = normal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_color * <span class="number">255.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="/images/Games101/homework/03/04.png"></p>
<h2 id="位移贴图（Displacement-Mapping）"><a href="#位移贴图（Displacement-Mapping）" class="headerlink" title="位移贴图（Displacement Mapping）"></a>位移贴图（Displacement Mapping）</h2><p><strong>main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Displacement Mapping 片段渲染器（位移贴图）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">displacement_fragment_shader</span><span class="params">(<span class="type">const</span> fragment_shader_payload&amp; payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> Limit_Number = [](<span class="type">float</span> &amp;number)&#123;</span><br><span class="line">        number = <span class="built_in">max</span>(number, (<span class="type">float</span>)<span class="number">0.0</span>);</span><br><span class="line">        number = <span class="built_in">min</span>(number, (<span class="type">float</span>)<span class="number">1.0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里 .norm 求范数；</span></span><br><span class="line"><span class="comment">        这里巨坑...</span></span><br><span class="line"><span class="comment">        这里 u v 会大于1...</span></span><br><span class="line"><span class="comment">        导致 getColor(u, v) 的时候会数组越界...所以需要限制一下</span></span><br><span class="line"><span class="comment">        调了一下午了...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">auto</span> func_h = [&amp;payload, Limit_Number](<span class="type">float</span> u, <span class="type">float</span> v) -&gt; <span class="keyword">auto</span> &#123;</span><br><span class="line">        <span class="built_in">Limit_Number</span>(u);</span><br><span class="line">        <span class="built_in">Limit_Number</span>(v);</span><br><span class="line">        <span class="keyword">return</span> payload.texture-&gt;<span class="built_in">getColor</span>(u, v).<span class="built_in">norm</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f ka = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.005</span>, <span class="number">0.005</span>, <span class="number">0.005</span>);</span><br><span class="line">    Eigen::Vector3f kd = payload.color;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.7937</span>, <span class="number">0.7937</span>, <span class="number">0.7937</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> l1 = light&#123;&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> l2 = light&#123;&#123;<span class="number">-20</span>, <span class="number">20</span>, <span class="number">0</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> p = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color; </span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> kh = <span class="number">0.2</span>, kn = <span class="number">0.1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// n是原来模型空间的法线</span></span><br><span class="line">    Eigen::Vector3f n = normal;</span><br><span class="line">    <span class="type">float</span> x = n.<span class="built_in">x</span>(), y = n.<span class="built_in">y</span>(), z = n.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算得到法线空间的基向量t和b(法线空间中，n与模型空间一致)</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">t</span><span class="params">(x*y / sqrt(x*x + z*z), sqrt(x*x + z*z), z*y / sqrt(x*x + z*z))</span></span>;</span><br><span class="line">    Eigen::Vector3f b = n.<span class="built_in">cross</span>(t);</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix3f TBN; <span class="comment">//TBN矩阵: 将纹理坐标对应到模型空间中</span></span><br><span class="line">    TBN &lt;&lt;  t.<span class="built_in">x</span>(), b.<span class="built_in">x</span>(), n.<span class="built_in">x</span>(),</span><br><span class="line">            t.<span class="built_in">y</span>(), b.<span class="built_in">y</span>(), n.<span class="built_in">y</span>(),</span><br><span class="line">            t.<span class="built_in">z</span>(), b.<span class="built_in">z</span>(), n.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纹理坐标和大小</span></span><br><span class="line">    <span class="type">float</span> u = payload.tex_coords.<span class="built_in">x</span>(), v = payload.tex_coords.<span class="built_in">y</span>();</span><br><span class="line">    <span class="type">float</span> w = payload.texture-&gt;width, h = payload.texture-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> dU = kh * kn * (<span class="built_in">func_h</span>(u+<span class="number">1</span>/w, v) - <span class="built_in">func_h</span>(u,v));</span><br><span class="line">    <span class="type">float</span> dV = kh * kn * (<span class="built_in">func_h</span>(u, v+<span class="number">1</span>/h) - <span class="built_in">func_h</span>(u,v));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得切线空间中法线的坐标</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">ln</span><span class="params">(-dU, -dV, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line">    ln.<span class="built_in">normalize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将它转换到模型空间中</span></span><br><span class="line">    normal = (TBN * ln).<span class="built_in">normalized</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变目标点的位置，将目标点拔高</span></span><br><span class="line">    point = point + kn * n * (payload.texture-&gt;<span class="built_in">getColor</span>(u,v).<span class="built_in">norm</span>());</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f ambient=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    Eigen::Vector3f diffuse=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    Eigen::Vector3f specular=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 漫反射</span></span><br><span class="line">        <span class="type">float</span> r_squared = (light.position - point).<span class="built_in">squaredNorm</span>();</span><br><span class="line">        diffuse = kd.<span class="built_in">cwiseProduct</span>(light.intensity / r_squared) * <span class="built_in">MAX</span>(<span class="number">0</span>, normal.<span class="built_in">dot</span>(((light.position - point).<span class="built_in">normalized</span>())));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 高光反射</span></span><br><span class="line">        <span class="keyword">auto</span> h = ((light.position - point).<span class="built_in">normalized</span>() + (eye_pos - point).<span class="built_in">normalized</span>()).<span class="built_in">normalized</span>();</span><br><span class="line">        specular = ks.<span class="built_in">cwiseProduct</span>(light.intensity / r_squared) * std::<span class="built_in">pow</span>(std::<span class="built_in">max</span>(<span class="number">0.0f</span>, normal.<span class="built_in">dot</span>(h)), p); </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 环境反射</span></span><br><span class="line">        ambient = ka.<span class="built_in">cwiseProduct</span>(amb_light_intensity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将三种光相加</span></span><br><span class="line">        result_color += ambient + diffuse + specular;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_color * <span class="number">255.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="/images/Games101/homework/03/05.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/27/games101/HomeWork%202/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/27/games101/HomeWork%202/" class="post-title-link" itemprop="url">【Games 101】HomeWork 2：Triangles and Z-buffering（光栅化 和 抗锯齿）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-27 23:26:45 / 修改时间：23:59:18" itemprop="dateCreated datePublished" datetime="2024-01-27T23:26:45+08:00">2024-01-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HomeWork-2：Triangles-and-Z-buffering（光栅化-和-抗锯齿）"><a href="#HomeWork-2：Triangles-and-Z-buffering（光栅化-和-抗锯齿）" class="headerlink" title="HomeWork 2：Triangles and Z-buffering（光栅化 和 抗锯齿）"></a>HomeWork 2：Triangles and Z-buffering（光栅化 和 抗锯齿）</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_projection_matrix</span><span class="params">(<span class="type">float</span> eye_fov, <span class="type">float</span> aspect_ratio, <span class="type">float</span> zNear, <span class="type">float</span> zFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	这个里的 zNear，zFar 给的又是负数了...</span></span><br><span class="line"><span class="comment">    	所以这里是不用反转的...</span></span><br><span class="line"><span class="comment">    	不然结果会相反，大家可以试试</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    Eigen::Matrix4f projection = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> projection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断点是否在三角形内（我这里用的是叉积）</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 这个表示叉积后的方向，0 表示负，1 表示正</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// the current point</span></span><br><span class="line">        Eigen::Vector3f p0 = &#123;x, y, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// the 1st vertex</span></span><br><span class="line">        Eigen::Vector3f p1 = _v[i];</span><br><span class="line">        <span class="comment">// the 2nd vertex</span></span><br><span class="line">        Eigen::Vector3f p2 = _v[(i+<span class="number">1</span>)%<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一个向量 (p1-p0)</span></span><br><span class="line">        Eigen::Vector3f v1 = p1-p0;</span><br><span class="line">        <span class="comment">// 第二个向量 (p1-p2)</span></span><br><span class="line">        Eigen::Vector3f v2 = p1-p2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求一下叉积</span></span><br><span class="line">        <span class="type">float</span> cp = v1.<span class="built_in">cross</span>(v2).<span class="built_in">z</span>();</span><br><span class="line">        <span class="keyword">if</span>(cp == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sign = cp &lt; <span class="number">0</span> ? <span class="number">0</span>: <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">-1</span>) flag = sign;</span><br><span class="line">        <span class="keyword">if</span>(flag != sign) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三角形光栅化</span></span><br><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">rasterize_triangle</span>(<span class="type">const</span> Triangle&amp; t) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> min_x = INT_MAX;</span><br><span class="line">    <span class="type">int</span> max_x = INT_MIN;</span><br><span class="line">    <span class="type">int</span> min_y = INT_MAX;</span><br><span class="line">    <span class="type">int</span> max_y = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求一下三角形的包围盒</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> point : v) <span class="comment">//获取包围盒边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        min_x = <span class="built_in">min</span>(min_x, point[<span class="number">0</span>]);</span><br><span class="line">        max_x = <span class="built_in">max</span>(max_x, point[<span class="number">0</span>]);</span><br><span class="line">        min_y = <span class="built_in">min</span>(min_y, point[<span class="number">1</span>]);</span><br><span class="line">        max_y = <span class="built_in">max</span>(max_y, point[<span class="number">1</span>]);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历包围盒里面的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = min_y; y &lt;= max_y; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = min_x; x &lt;= max_x; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">insideTriangle</span>((<span class="type">float</span>)x+<span class="number">0.5</span>, (<span class="type">float</span>)y+<span class="number">0.5</span>, t.v))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取像素点在三角形内的 “重心坐标的系数”</span></span><br><span class="line">                <span class="keyword">auto</span>[alpha, beta, gamma] = <span class="built_in">computeBarycentric2D</span>(x+<span class="number">0.5</span>, y+<span class="number">0.5</span>, t.v);</span><br><span class="line">                </span><br><span class="line">               	<span class="comment">// 计算这个像素点的深度</span></span><br><span class="line">                <span class="type">float</span> w_reciprocal = <span class="number">1.0</span>/(alpha / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">                <span class="type">float</span> z_interpolated = alpha * v[<span class="number">0</span>].<span class="built_in">z</span>() / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * v[<span class="number">1</span>].<span class="built_in">z</span>() / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * v[<span class="number">2</span>].<span class="built_in">z</span>() / v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">                z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断当前z值是否小于原来z表此位置的z值</span></span><br><span class="line">                <span class="keyword">if</span> (z_interpolated &lt; depth_buf[<span class="built_in">get_index</span>(x, y)]) </span><br><span class="line">                &#123;</span><br><span class="line">                    Eigen::Vector3f p = &#123; (<span class="type">float</span>)x,(<span class="type">float</span>)y, z_interpolated &#125;; <span class="comment">// 当前坐标</span></span><br><span class="line">                    <span class="built_in">set_pixel</span>(p, t.<span class="built_in">getColor</span>()); </span><br><span class="line">                    depth_buf[<span class="built_in">get_index</span>(x, y)] = z_interpolated; <span class="comment">// 更新z值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提高的抗锯齿可以看这里：</strong></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/454001952">Games101｜作业2 + 光栅化 + SSAA vs MSAA + 黑边问题 - 知乎 (zhihu.com)</a></p>
<p><strong>分析的太棒了！</strong></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/images/Games101/homework/02/01.png"></p>
<h2 id="补一下提高-嘻嘻嘻"><a href="#补一下提高-嘻嘻嘻" class="headerlink" title="补一下提高 嘻嘻嘻"></a>补一下提高 嘻嘻嘻</h2><p><strong>rasterizer.hpp 添加</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Eigen::Vector3f&gt; color_list;</span><br></pre></td></tr></table></figure>

<p><strong>rasterizer.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断点是否在三角形内（我这里用的是叉积）</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 这个表示叉积后的方向，0 表示负，1 表示正</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// the current point</span></span><br><span class="line">        Eigen::Vector3f p0 = &#123;x, y, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// the 1st vertex</span></span><br><span class="line">        Eigen::Vector3f p1 = _v[i];</span><br><span class="line">        <span class="comment">// the 2nd vertex</span></span><br><span class="line">        Eigen::Vector3f p2 = _v[(i+<span class="number">1</span>)%<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一个向量 (p1-p0)</span></span><br><span class="line">        Eigen::Vector3f v1 = p1-p0;</span><br><span class="line">        <span class="comment">// 第二个向量 (p1-p2)</span></span><br><span class="line">        Eigen::Vector3f v2 = p1-p2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求一下叉积         float cp = v1.cross(v2).z();</span></span><br><span class="line">        <span class="keyword">if</span>(cp == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sign = cp &lt; <span class="number">0</span> ? <span class="number">0</span>: <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">-1</span>) flag = sign;</span><br><span class="line">        <span class="keyword">if</span>(flag != sign) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 四个采样点 float dx[] = &#123;0.25, 0.25, 0.75, 0.75&#125;;</span></span><br><span class="line"><span class="type">float</span> dy[] = &#123;<span class="number">0.25</span>, <span class="number">0.75</span>, <span class="number">0.25</span>, <span class="number">0.75</span>&#125;;</span><br><span class="line"><span class="comment">// 三角形光栅化</span></span><br><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">rasterize_triangle</span>(<span class="type">const</span> Triangle&amp; t) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> min_x = INT_MAX;</span><br><span class="line">    <span class="type">int</span> max_x = INT_MIN;</span><br><span class="line">    <span class="type">int</span> min_y = INT_MAX;</span><br><span class="line">    <span class="type">int</span> max_y = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求一下三角形的包围盒</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> point : v) <span class="comment">//获取包围盒边界     &#123;</span></span><br><span class="line">        min_x = <span class="built_in">min</span>((<span class="type">float</span>)min_x, point[<span class="number">0</span>]);</span><br><span class="line">        max_x = <span class="built_in">max</span>((<span class="type">float</span>)max_x, point[<span class="number">0</span>]);</span><br><span class="line">        min_y = <span class="built_in">min</span>((<span class="type">float</span>)min_y, point[<span class="number">1</span>]);</span><br><span class="line">        max_y = <span class="built_in">max</span>((<span class="type">float</span>)max_y, point[<span class="number">1</span>]);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历包围盒里面的点     for (int y = min_y; y &lt; max_y; y++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = min_x; x &lt; max_x; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取四个点(MSAA)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> xx = (<span class="type">double</span>)x + dx[i];</span><br><span class="line">                <span class="type">float</span> yy = (<span class="type">double</span>)y + dy[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">insideTriangle</span>(xx, yy, t.v))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 获取像素点在三角形内的 “重心坐标的系数”</span></span><br><span class="line">                	<span class="keyword">auto</span>[alpha, beta, gamma] = <span class="built_in">computeBarycentric2D</span>(x+<span class="number">0.5</span>, y+<span class="number">0.5</span>, t.v);</span><br><span class="line">                </span><br><span class="line">               		<span class="comment">// 计算这个像素点的深度</span></span><br><span class="line">                    <span class="type">float</span> w_reciprocal = <span class="number">1.0</span>/(alpha / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">                    <span class="type">float</span> z_interpolated = alpha * v[<span class="number">0</span>].<span class="built_in">z</span>() / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * v[<span class="number">1</span>].<span class="built_in">z</span>() / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * v[<span class="number">2</span>].<span class="built_in">z</span>() / v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">                    z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断当前z值是否小于原来z表此位置的z值                     if (z_interpolated &lt; depth_buf[get_index(x, y)*4+i]) </span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 更新这个采样点                         depth_buf[get_index(x, y)*4+i] = z_interpolated;</span></span><br><span class="line">                        color_list[<span class="built_in">get_index</span>(x, y)*<span class="number">4</span>+i] = t.<span class="built_in">getColor</span>();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 重新算一下这个像素点的颜色(取平均)</span></span><br><span class="line">                        <span class="function">Eigen::Vector3f <span class="title">new_color</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) </span><br><span class="line">                            new_color += color_list[<span class="built_in">get_index</span>(x, y)*<span class="number">4</span>+j];</span><br><span class="line">                        new_color /= <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 更新当前像素的值                         Eigen::Vector3f p = &#123; (float)x,(float)y, z_interpolated &#125;;</span></span><br><span class="line">                        <span class="built_in">set_pixel</span>(p, new_color);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p><img src="/images/Games101/homework/02/02.png"></p>
<p><strong>结果对比：</strong></p>
<p><img src="/images/Games101/homework/02/03.png"></p>
<p><img src="/images/Games101/homework/02/04.png"></p>
<p><strong>太神奇啦！</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/27/games101/HomeWork%201/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/27/games101/HomeWork%201/" class="post-title-link" itemprop="url">【Games 101】HomeWork 1：旋转与投影</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-27 23:25:29 / 修改时间：23:59:13" itemprop="dateCreated datePublished" datetime="2024-01-27T23:25:29+08:00">2024-01-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HomeWork-1：旋转与投影"><a href="#HomeWork-1：旋转与投影" class="headerlink" title="HomeWork 1：旋转与投影"></a>HomeWork 1：旋转与投影</h1><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    模型变换：</span></span><br><span class="line"><span class="comment">        逐个元素地构建模型变换矩阵并返回该矩阵。</span></span><br><span class="line"><span class="comment">        在此函数中，你只需要实现三维中绕 z 轴旋转的变换矩阵，而不用处理平移与缩放。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    分析：</span></span><br><span class="line"><span class="comment">        这个比较简单，提示也说了我们只需要绕着 z 轴旋转就行；</span></span><br><span class="line"><span class="comment">        回顾一下公式：http://fjbq-blog.top/2023/12/30/GAMES%20101%20%E9%9A%8F%E7%AC%94/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_model_matrix</span><span class="params">(<span class="type">float</span> rotation_angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 转换为弧度制</span></span><br><span class="line">    <span class="type">float</span> rotation_angle_rad = rotation_angle / <span class="number">180.0</span> * MY_PI;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 模型变换矩阵，默认初始化矩阵为单位矩阵</span></span><br><span class="line">    Eigen::Matrix4f model = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line"></span><br><span class="line">    model &lt;&lt; <span class="built_in">cos</span>(rotation_angle_rad), -<span class="built_in">sin</span>(rotation_angle_rad), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">             <span class="built_in">sin</span>(rotation_angle_rad), <span class="built_in">cos</span>(rotation_angle_rad), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">             <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">             <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //绕x轴</span></span><br><span class="line"><span class="comment">    model &lt;&lt; 1, 0, 0, 0,</span></span><br><span class="line"><span class="comment">             0, cos(angle), -sin(angle), 0,</span></span><br><span class="line"><span class="comment">             0, sin(angle), cos(angle), 0,</span></span><br><span class="line"><span class="comment">             0, 0, 0, 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //绕y轴（注意是反的哦）</span></span><br><span class="line"><span class="comment">    model &lt;&lt; cos(angle), 0, sin(angle), 0,</span></span><br><span class="line"><span class="comment">             0, 1, 0, 0,</span></span><br><span class="line"><span class="comment">             -sin(angle), 0, cos(angle), 0,</span></span><br><span class="line"><span class="comment">             0, 0, 0, 1;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    投影变换：</span></span><br><span class="line"><span class="comment">        使用给定的参数逐个元素地构建透视投影矩阵并返回该矩阵。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    分析：</span></span><br><span class="line"><span class="comment">        这个感觉就比较复杂一点了...</span></span><br><span class="line"><span class="comment">        首先根据前面的学习，我们知道 透视投影矩阵 = 正交投影矩阵 * 透视压缩矩阵（注意顺序哦）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        其中这个 正交投影矩阵 里面用到的参数需要我们去求一下的...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_projection_matrix</span><span class="params">(<span class="type">float</span> eye_fov, <span class="type">float</span> aspect_ratio, <span class="type">float</span> zNear, <span class="type">float</span> zFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	怎么感觉知乎大佬的代码怪怪的；</span></span><br><span class="line"><span class="comment">    	这个 zNear，zFar 给的是正数；</span></span><br><span class="line"><span class="comment">    	下面计算的都是用的负数，先转换一下？</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    zNear = -zNear;</span><br><span class="line">    zFar = -zFar;</span><br><span class="line">    </span><br><span class="line">    Eigen::Matrix4f projection = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 透视投影压缩矩阵</span></span><br><span class="line">    Eigen::Matrix4f M_persp;</span><br><span class="line">    M_persp &lt;&lt;  zNear, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, zNear, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, zNear + zFar, -zNear*zFar,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求一下正交投影矩阵要用到的参数</span></span><br><span class="line">    <span class="type">float</span> alpha = <span class="number">0.5</span> * (eye_fov / <span class="number">180.0f</span> * MY_PI);     <span class="comment">// 视野角度的一半</span></span><br><span class="line">    <span class="type">float</span> yTop = -zNear * std::<span class="built_in">tan</span>(alpha);              <span class="comment">// 因为这里的z给的是负数，所以加负号之后再转换</span></span><br><span class="line">    <span class="type">float</span> yBottom = -yTop;</span><br><span class="line">    <span class="type">float</span> xRight = yTop * aspect_ratio;                 <span class="comment">// aspect_ratio 是 xy 的比例</span></span><br><span class="line">    <span class="type">float</span> xLeft = -xRight;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix4f M_trans;</span><br><span class="line">    M_trans &lt;&lt;  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -(xLeft + xRight) / <span class="number">2</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -(yTop + yBottom) / <span class="number">2</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -(zNear + zFar) / <span class="number">2</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix4f M_ortho;</span><br><span class="line">    M_ortho &lt;&lt;  <span class="number">2</span> / (xRight - xLeft), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">2</span> / (yTop - yBottom), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span> / (zNear - zFar), <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个就是 正交投影矩阵</span></span><br><span class="line">    M_ortho = M_ortho * M_trans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 透视投影矩阵 = 正交投影矩阵 * 透视压缩矩阵（注意顺序哦）</span></span><br><span class="line">    projection = M_ortho * M_persp * projection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> projection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    进阶 模型变换矩阵：绕任意轴旋转</span></span><br><span class="line"><span class="comment">    参考的是知乎大佬的：https://zhuanlan.zhihu.com/p/448904350</span></span><br><span class="line"><span class="comment">    用 n 表示一个过原点的向量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_random_model_matrix</span><span class="params">(Eigen::Vector3f n,<span class="type">float</span> rotation_angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Matrix4f model = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line">    Eigen::Matrix3f I = Eigen::Matrix3f::<span class="built_in">Identity</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> angle = rotation_angle / <span class="number">180.0f</span> * MY_PI ;</span><br><span class="line">    <span class="type">float</span> nx = n[<span class="number">0</span>];</span><br><span class="line">    <span class="type">float</span> ny = n[<span class="number">1</span>];</span><br><span class="line">    <span class="type">float</span> nz = n[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    Eigen::Matrix3f N;</span><br><span class="line">    N &lt;&lt; <span class="number">0</span>, -nz, ny,</span><br><span class="line">         nz, <span class="number">0</span>, -nx,</span><br><span class="line">         -ny, nx, <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公式</span></span><br><span class="line">    Eigen::Matrix3f R = std::<span class="built_in">cos</span>(angle) * I + (<span class="number">1</span> - std::<span class="built_in">cos</span>(angle)) * n * n.<span class="built_in">transpose</span>() + std::<span class="built_in">sin</span>(angle) * N;</span><br><span class="line">    </span><br><span class="line">    model &lt;&lt; <span class="built_in">R</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">R</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">R</span>(<span class="number">0</span>, <span class="number">2</span>), <span class="number">0</span>,</span><br><span class="line">             <span class="built_in">R</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">R</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">R</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="number">0</span>,</span><br><span class="line">             <span class="built_in">R</span>(<span class="number">2</span>, <span class="number">0</span>), <span class="built_in">R</span>(<span class="number">2</span>, <span class="number">1</span>), <span class="built_in">R</span>(<span class="number">2</span>, <span class="number">2</span>), <span class="number">0</span>,</span><br><span class="line">             <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><p><img src="/images/Games101/homework/01/01.png"></p>
<p><img src="/images/Games101/homework/01/02.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/21/games101/Lec%2022/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/21/games101/Lec%2022/" class="post-title-link" itemprop="url">【Games 101】Lec 22：动画（续）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-21 13:52:23 / 修改时间：18:02:42" itemprop="dateCreated datePublished" datetime="2024-01-21T13:52:23+08:00">2024-01-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-22：Animation-cont"><a href="#Lecture-22：Animation-cont" class="headerlink" title="Lecture 22：Animation (cont.)"></a>Lecture 22：Animation (cont.)</h1><h2 id="1-单个粒子模拟（Single-Particle-Simulation）"><a href="#1-单个粒子模拟（Single-Particle-Simulation）" class="headerlink" title="1 单个粒子模拟（Single Particle Simulation）"></a>1 单个粒子模拟（Single Particle Simulation）</h2><h2 id="1-1-单个粒子的运动"><a href="#1-1-单个粒子的运动" class="headerlink" title="1.1 单个粒子的运动"></a>1.1 单个粒子的运动</h2><p>首先研究一个粒子的运动然后泛化到大多数粒子。</p>
<p>我们线认为粒子的运动由速度场(velocity vector field)决定，这个速度场就是一个位置和时间的函数：v（x，t）</p>
<p>知道粒子的位置和时间，就知道它的速度；（这个函数我们现在是已知的）</p>
<p><img src="/images/Games101/22/01.png"></p>
<p>那么，计算粒子的位置（随时间变化）需要解一个一阶的常微分方程(不存在对其他变量的微分或导数First-order意味着只存在一阶导数)：</p>
<p><img src="/images/Games101/22/02.png"></p>
<h2 id="1-2-欧拉方法（Euler’s-Method）"><a href="#1-2-欧拉方法（Euler’s-Method）" class="headerlink" title="1.2 欧拉方法（Euler’s Method）"></a>1.2 欧拉方法（Euler’s Method）</h2><h3 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h3><p>欧拉方法是一种简单的<strong>迭代方法</strong>，<strong>经常被使用</strong>、<strong>不准确</strong>、大多数都<strong>不稳定</strong>。</p>
<p>可以使用欧拉方法对给定初始位置和速度场的点求解经过时间t后所处的位置。</p>
<p><img src="/images/Games101/22/03.png"></p>
<h3 id="1-2-2-误差"><a href="#1-2-2-误差" class="headerlink" title="1.2.2 误差"></a>1.2.2 误差</h3><p>使用数值计算的方法积分，误差会累计，最后的Euler积分结果会很差。</p>
<p><img src="/images/Games101/22/04.png"></p>
<h3 id="1-2-3-欧拉方法的不稳定性（Instability-of-the-Euler-Method）"><a href="#1-2-3-欧拉方法的不稳定性（Instability-of-the-Euler-Method）" class="headerlink" title="1.2.3 欧拉方法的不稳定性（Instability of the Euler Method）"></a>1.2.3 欧拉方法的不稳定性（Instability of the Euler Method）</h3><p>如下图，粒子的轨迹始终不能沿着圆形或指定的轨迹。</p>
<p><img src="/images/Games101/22/05.png"></p>
<p>即欧拉方法有两个关键的问题：</p>
<ul>
<li>误差随着时间步长 Δt 的增加而增加。</li>
<li>不稳定性是一个普遍且严重的问题，它能造成模拟 diverge。</li>
</ul>
<h3 id="1-2-4-Errors-和-Instability"><a href="#1-2-4-Errors-和-Instability" class="headerlink" title="1.2.4 Errors 和 Instability"></a>1.2.4 Errors 和 Instability</h3><p>用有限差分数值积分法求解<br>导致两个问题:<br><strong>Errors</strong>：</p>
<ul>
<li>每个时间步的误差累积。精度随着模拟的进行而降低</li>
<li>在图形应用中，准确性可能不是关键</li>
</ul>
<p><strong>Instability</strong>：</p>
<ul>
<li>错误可以复合，导致模拟甚至发散当底层系统没有</li>
<li>缺乏稳定性是模拟中的一个基本问题不容忽视</li>
</ul>
<h2 id="1-3-克服不稳定性的方法"><a href="#1-3-克服不稳定性的方法" class="headerlink" title="1.3 克服不稳定性的方法"></a>1.3 克服不稳定性的方法</h2><h3 id="1-3-1-概述"><a href="#1-3-1-概述" class="headerlink" title="1.3.1 概述"></a>1.3.1 概述</h3><ul>
<li>中点法&#x2F;修正欧拉法<ul>
<li>起点和终点的平均速度</li>
</ul>
</li>
<li>自适应步长<ul>
<li>递归地比较一步和两个半步，直到可以接受错误</li>
</ul>
</li>
<li>隐式方法<ul>
<li>使用下一个时间步骤的速度(硬)</li>
</ul>
</li>
<li>基于位置&#x2F; Verlet的集成<ul>
<li>在时间步长后约束粒子的位置和速度</li>
</ul>
</li>
</ul>
<h3 id="1-3-2-中点法（Midpoint-Method）"><a href="#1-3-2-中点法（Midpoint-Method）" class="headerlink" title="1.3.2 中点法（Midpoint Method）"></a>1.3.2 中点法（Midpoint Method）</h3><ul>
<li>使用欧拉方法计算，点到达A( a )。</li>
<li>使用欧拉方法计算上一步起始点与A点的导数( b )。</li>
<li>使用中点的导数来重新更新位置( c )。</li>
</ul>
<p><img src="/images/Games101/22/06.png"></p>
<p>中点法比欧拉方法多了一个二次的项。</p>
<p><img src="/images/Games101/22/07.png"></p>
<h3 id="1-3-3-自适应步长法（Adaptive-Step-Size）"><a href="#1-3-3-自适应步长法（Adaptive-Step-Size）" class="headerlink" title="1.3.3 自适应步长法（Adaptive Step Size）"></a>1.3.3 自适应步长法（Adaptive Step Size）</h3><ul>
<li>使用步长为T计算一个欧拉步骤来获得 X(T)</li>
<li>计算两个欧拉步骤，步长为T&#x2F;2，获得 X(T&#x2F;2)</li>
<li>计算error ∣∣ X(T) − X(T&#x2F;2) ∣∣</li>
<li>If ( error &gt; threshold ) 减少步长并重复上面的步骤。</li>
</ul>
<p><img src="/images/Games101/22/08.png"></p>
<p>Adaptive 是基于 error 估计选择步长的方法，非常实用，但可能得到的步长会很小。</p>
<h3 id="1-3-3-隐式欧拉方法"><a href="#1-3-3-隐式欧拉方法" class="headerlink" title="1.3.3 隐式欧拉方法"></a>1.3.3 隐式欧拉方法</h3><p>也被称作后向方法，使用下一时间的导数来计算当前的步骤。</p>
<p><img src="/images/Games101/22/09.png"></p>
<p><img src="/images/Games101/22/10.png"></p>
<p><strong>定义与量化 “stability” （稳定性）的方法</strong></p>
<ul>
<li>使用局部截断误差（每个Δ \DeltaΔ的误差）&#x2F; 总截断累积误差（整体累加后的误差）来研究稳定性。</li>
<li>研究数的大小无意义，有意义的事研究它们的阶。</li>
<li>隐式欧拉方法的阶数为1，意味着局部截断误差为 O(h^2) 且全局阶段误差为 O(h)（h就是步长，定义为 Δt）。</li>
<li>O(h)的理解:如果将 h 减半，预期误差也会减半。</li>
</ul>
<p><img src="/images/Games101/22/11.png"></p>
<h3 id="1-3-4-Runge-Kutta-Families"><a href="#1-3-4-Runge-Kutta-Families" class="headerlink" title="1.3.4 Runge-Kutta Families"></a>1.3.4 Runge-Kutta Families</h3><p>Runge-Kutta方法是一系列用于求解 ODE 的高级方法。</p>
<p><strong>特点</strong></p>
<ul>
<li>擅长处理非线性问题。</li>
<li>它的四阶版是使用最广泛的，又名 RK4。</li>
</ul>
<p><img src="/images/Games101/22/12.png"></p>
<p>h就是步长，也就是 Δt</p>
<h3 id="1-3-5-Position-Based-Verlet-Integration"><a href="#1-3-5-Position-Based-Verlet-Integration" class="headerlink" title="1.3.5 Position-Based &#x2F; Verlet Integration"></a>1.3.5 Position-Based &#x2F; Verlet Integration</h3><p>这是一种不基于物理的方法，通过调整物体的位置使物体满足某种性质。</p>
<p><strong>思想：</strong></p>
<ul>
<li>在修改欧拉前步（forward-step）之后，约束粒子的位置以防止divergent、不稳定的现象。</li>
<li>使用约束位置计算速度。</li>
<li>这两种思想都会耗散能量，使其具有稳定性。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>快速又简单。</li>
<li>不是基于物理模拟的，不满足能量守恒。</li>
</ul>
<h1 id="2-刚体模拟（Rigid-Body-Simulation）"><a href="#2-刚体模拟（Rigid-Body-Simulation）" class="headerlink" title="2 刚体模拟（Rigid Body Simulation）"></a>2 刚体模拟（Rigid Body Simulation）</h1><p>刚体模拟与模拟单个粒子相似，只需额外考虑一些属性（角度，角速度）</p>
<p><img src="/images/Games101/22/13.png"></p>
<h1 id="3-流体模拟（Fluid-Simulation）"><a href="#3-流体模拟（Fluid-Simulation）" class="headerlink" title="3 流体模拟（Fluid Simulation）"></a>3 流体模拟（Fluid Simulation）</h1><h3 id="3-1-基于位置的简单流体模拟方法"><a href="#3-1-基于位置的简单流体模拟方法" class="headerlink" title="3.1 基于位置的简单流体模拟方法"></a>3.1 基于位置的简单流体模拟方法</h3><p><strong>关键思想</strong></p>
<ul>
<li>认为水是由刚体小球组成的。</li>
<li>认为水是不可压缩的。</li>
<li>只要某处的密度海绵，就需要通过改变粒子的位置来“纠正”。</li>
<li>需要知道任何位置的密度的梯度。</li>
<li>使用梯度下降法来进行更新。</li>
</ul>
<p><img src="/images/Games101/22/14.png"></p>
<h2 id="3-2-质点法和网络法（Eulerian-vs-Lagrangian）"><a href="#3-2-质点法和网络法（Eulerian-vs-Lagrangian）" class="headerlink" title="3.2 质点法和网络法（Eulerian vs. Lagrangian）"></a>3.2 质点法和网络法（Eulerian vs. Lagrangian）</h2><p><img src="/images/Games101/22/15.png"></p>
<h2 id="3-3-Material-Point-Method-MPM"><a href="#3-3-Material-Point-Method-MPM" class="headerlink" title="3.3 Material Point Method (MPM)"></a>3.3 Material Point Method (MPM)</h2><p>MPM 是一种混合的(Hybrid)，结合 Eulerian 和 Lagrangian 的方法。</p>
<ul>
<li>Lagrangian：认为粒子带有材质属性。</li>
<li>Eulerian：使用网格来做数值积分。</li>
<li>lnteraction：粒子将属性传递给网格，网格执行更新，然后插值回粒子。</li>
</ul>
<p><img src="/images/Games101/22/16.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489/article/details/121934159">图形学笔记（二十）粒子、刚体、流体的模拟—— 欧拉方法、Errors 和 Instability、中点法、自适应步长、隐式欧拉方法、Runge-Kutta方法、刚体与流体模拟（质点法、网格法、MPM）_隐式mpm-CSDN博客</a></p>
<p>结束，下面把作业做一做，然后打算做个玩具渲染器（当作毕设了…）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/21/games101/Lec%2021/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/21/games101/Lec%2021/" class="post-title-link" itemprop="url">【Games 101】Lec 21：动画</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-21 13:52:23 / 修改时间：15:23:16" itemprop="dateCreated datePublished" datetime="2024-01-21T13:52:23+08:00">2024-01-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-21：Animation"><a href="#Lecture-21：Animation" class="headerlink" title="Lecture 21：Animation"></a>Lecture 21：Animation</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>“Bring things to life”</p>
<ul>
<li>交流的工具</li>
<li>美学引导技术</li>
</ul>
<p>建模的扩展</p>
<ul>
<li>把3d模型延申到时间的维度</li>
</ul>
<p>输出：按顺序播放的图片序列，提供一种运动感。</p>
<ul>
<li>电影：24 fps</li>
<li>Video（通常）：30 fps</li>
<li>Virtual reality：90 fps</li>
</ul>
<h1 id="2-Historical-Points-in-Animation"><a href="#2-Historical-Points-in-Animation" class="headerlink" title="2 Historical Points in Animation"></a>2 Historical Points in Animation</h1><p>这个看一下PPT就行…</p>
<p><img src="/images/Games101/21/01.png"></p>
<h1 id="3-动画技术"><a href="#3-动画技术" class="headerlink" title="3 动画技术"></a>3 动画技术</h1><h2 id="3-1-关键帧动画（Keyframe-Animation）"><a href="#3-1-关键帧动画（Keyframe-Animation）" class="headerlink" title="3.1 关键帧动画（Keyframe Animation）"></a>3.1 关键帧动画（Keyframe Animation）</h2><ul>
<li>动画师 创建关键帧</li>
<li>人或计算机 创建中间的帧</li>
</ul>
<p><img src="/images/Games101/21/02.png"></p>
<p>关键帧动画一般使用插值方法来进行补帧，把每一帧当作参数值的向量，下面是线性插值。</p>
<p><img src="/images/Games101/21/03.png"></p>
<p>用样条进行优化：</p>
<p><img src="/images/Games101/21/04.png"></p>
<h2 id="3-2-物理仿真（Physical-Simulation）"><a href="#3-2-物理仿真（Physical-Simulation）" class="headerlink" title="3.2 物理仿真（Physical Simulation）"></a>3.2 物理仿真（Physical Simulation）</h2><h3 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h3><p>F &#x3D; ma</p>
<p>使用数值模拟生成物体的运动</p>
<p><img src="/images/Games101/21/05.png"></p>
<p>例子：</p>
<ul>
<li>布料模拟（ Cloth Simulation）</li>
<li>流体（ Fluids ）</li>
<li>质点弹簧系统（ Mass Spring System）</li>
<li>头发（ Hair ）</li>
<li>质点弹簧网格（Mass Spring Mesh）</li>
</ul>
<h3 id="3-2-2-质点弹簧系统（Mass-Spring-System）"><a href="#3-2-2-质点弹簧系统（Mass-Spring-System）" class="headerlink" title="3.2.2 质点弹簧系统（Mass Spring System）"></a>3.2.2 质点弹簧系统（Mass Spring System）</h3><ol>
<li><strong>简单的弹簧</strong></li>
</ol>
<p>理想化的弹簧：没有长度，作用力会导致位移。</p>
<p><strong>胡克定律：</strong></p>
<p><img src="/images/Games101/21/06.png"></p>
<ol start="2">
<li><strong>非0长度的弹簧</strong></li>
</ol>
<p><img src="/images/Games101/21/07.png"></p>
<p><strong>问题：永远震动下去。</strong></p>
<p><strong>定义概念：</strong></p>
<p><img src="/images/Games101/21/08.png"></p>
<p><strong>引入能量损失</strong></p>
<ul>
<li>表现得像运动中的粘性阻力</li>
<li>在速度方向上减慢运动</li>
<li>kd为阻尼系数</li>
</ul>
<p><img src="/images/Games101/21/09.png"></p>
<p><strong>问题：所有运动都会停止（不能表现弹簧内部的损耗）。</strong></p>
<p><strong>弹簧的内部阻尼（Internal Damping for Spring）</strong></p>
<p>只阻尼内部，由弹簧驱动的运动。</p>
<p><img src="/images/Games101/21/10.png"></p>
<p>Viscous drag 仅限于弹簧长度的变化，不会减慢弹簧系统的整体运动(例如，整体平移或旋转)</p>
<p>Note: 这只是一种特殊的阻尼(damping)。</p>
<ol start="3">
<li><strong>来自弹簧的结构</strong></li>
</ol>
<p><img src="/images/Games101/21/11.png"></p>
<p>弹簧结构的连接可以决定一个图形的行为，比如改进下面的连接来模拟布料。</p>
<p><img src="/images/Games101/21/12.png"></p>
<p>原来的不足之处：</p>
<ul>
<li>切变会影响形状。</li>
<li>会使原来的形状不在一个平面上。</li>
</ul>
<p>改进之后：</p>
<p><img src="/images/Games101/21/13.png"></p>
<ul>
<li><strong>在对角线连接弹簧会抵抗切变。</strong></li>
<li><strong>在两个对角线都连切线避免了各向异性。</strong></li>
<li><strong>红色的弹簧会避免 out-of-plane bending（两条对角线竖直方向会弯折）。</strong></li>
</ul>
<p>其他模型：<strong>有限元方法FEM（Finite Element Method）</strong></p>
<p>（代替弹簧系统的一种模拟布料的办法）</p>
<p>常用来做汽车碰撞，主要思想是<strong>力与力之间存在传导</strong>，效果如下。</p>
<p><img src="/images/Games101/21/14.png"></p>
<h3 id="3-2-3-粒子系统（Particle-System）"><a href="#3-2-3-粒子系统（Particle-System）" class="headerlink" title="3.2.3 粒子系统（Particle System）"></a>3.2.3 粒子系统（Particle System）</h3><ul>
<li>粒子系统就是将动态的系统建模为大量粒子的集合</li>
<li>每个粒子的运动都是由一组物理(或非物理)力定义的。</li>
<li>粒子系统是在图形和游戏上很流行的技术。</li>
<li>具备可扩展性：粒子越少，速度越快，粒子越多，速度越慢。</li>
</ul>
<p><strong>挑战</strong></p>
<ul>
<li>可能需要许多粒子(例如流体)</li>
<li>可能需要加速结构(例如寻找最近的粒子进行如引力的相互作用)</li>
</ul>
<p><strong>步骤</strong></p>
<ol>
<li>创建新的粒子（如果需要的话）。</li>
<li>计算每个粒子的力。</li>
<li>更新每个粒子的位置和速度。</li>
<li>移除死掉的粒子。</li>
<li>渲染粒子。</li>
</ol>
<p><strong>粒子系统的作用力</strong></p>
<ul>
<li>引力和斥力（repulsion） 如：万有引力、磁力、弹力（Springs）、弹簧、推进力（propulsion）。（eg：万有引力）</li>
<li>阻力（Damping forces）：摩擦（Friction），空气阻力（air drag），粘度 （viscosity）…</li>
<li>碰撞（Collisions）：墙壁、容器、固定的物体…。与动态物体、人物身体部位等…。</li>
</ul>
<p><strong>模拟动物集群（Simulated Flocking as an ODE）</strong></p>
<p>需要考虑一个例子的各种作用力</p>
<p><img src="/images/Games101/21/15.png"></p>
<h1 id="4-运动学-Kinematics"><a href="#4-运动学-Kinematics" class="headerlink" title="4 运动学 Kinematics"></a>4 运动学 Kinematics</h1><h2 id="4-1-正向运动学（Forward-Kinematics）"><a href="#4-1-正向运动学（Forward-Kinematics）" class="headerlink" title="4.1 正向运动学（Forward Kinematics）"></a>4.1 正向运动学（Forward Kinematics）</h2><p><strong>Articulated skeleton</strong></p>
<ul>
<li><strong>Topology 是一种拓扑结构（描述什么与什么连接）</strong></li>
<li><strong>关节（joints）间的几何关系。</strong></li>
<li><strong>树形结构</strong></li>
</ul>
<p><strong>Joint types（关节类型）</strong></p>
<ul>
<li><strong>Pin（1D rotation）：在平面内旋转</strong></li>
<li><strong>Ball（2D rotation）：可以旋转到不同的平面</strong></li>
<li><strong>Prismatic joint（translation）：可以拉长</strong></li>
</ul>
<p><img src="/images/Games101/21/16.png"></p>
<p>例子：2D中简单的两端骨骼。</p>
<p>Animator 提供角度，计算机决定 end-effector 的位置p。</p>
<p>Animation 是用角度参数与时间的函数来描述的。</p>
<p><img src="/images/Games101/21/17.png"></p>
<p><strong>优点：</strong></p>
<ul>
<li>直接控制方便</li>
<li>便于实施</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>动画可能难以用物理的方式来制作（不直观，艺术家不喜欢）</li>
<li>消耗动画师的时间</li>
</ul>
<h2 id="4-2-逆向运动学（Inverse-Kinematics）"><a href="#4-2-逆向运动学（Inverse-Kinematics）" class="headerlink" title="4.2 逆向运动学（Inverse Kinematics）"></a>4.2 逆向运动学（Inverse Kinematics）</h2><p><strong>概述：</strong></p>
<p>根据尖端获得关节的角度位置。</p>
<p>Animator 提供 end-effector 的位置，计算机决定满足限制的 joint 角度。</p>
<p>计算方法：</p>
<p><img src="/images/Games101/21/18.png"></p>
<p><strong>问题：</strong></p>
<ul>
<li>解不唯一</li>
<li>解可能不存在</li>
</ul>
<p><img src="/images/Games101/21/19.png"></p>
<p><strong>N-link lK 问题优化方法</strong></p>
<ul>
<li>选择一个初始构型。</li>
<li>定义一个 error metric（如：目标与当前位置之间距离的平方）。</li>
<li>计算误差梯度作为构形的函数</li>
<li>应用梯度下降(或牛顿法，或其他优化程序)</li>
</ul>
<h2 id="4-3-应用"><a href="#4-3-应用" class="headerlink" title="4.3 应用"></a>4.3 应用</h2><h3 id="4-3-1-Rigging-绑定"><a href="#4-3-1-Rigging-绑定" class="headerlink" title="4.3.1 Rigging 绑定"></a>4.3.1 Rigging 绑定</h3><p>Rigging 是一套高级角色控制，允许更快速和直观地修改姿势、变形、表情等。</p>
<ul>
<li>就像提线木偶的线一样。</li>
<li>捕捉所有有意义的角色变化。</li>
<li>因角色而异。</li>
<li>制作昂贵</li>
<li>具有人工误差并需要艺术和技术的训练。</li>
</ul>
<p><img src="/images/Games101/21/20.png"></p>
<h3 id="4-3-2-混合形状（Blend-Shapes）"><a href="#4-3-2-混合形状（Blend-Shapes）" class="headerlink" title="4.3.2 混合形状（Blend Shapes）"></a>4.3.2 混合形状（Blend Shapes）</h3><p>直接在曲面之间进行插值。</p>
<p><img src="/images/Games101/21/21.png"></p>
<p>最简单的方案：取顶点位置的线性组合，样条用于控制随着时间的推移权重的选择。</p>
<h3 id="4-3-3-动作捕捉（Motion-Capture）"><a href="#4-3-3-动作捕捉（Motion-Capture）" class="headerlink" title="4.3.3 动作捕捉（Motion Capture）"></a>4.3.3 动作捕捉（Motion Capture）</h3><p>Motion Capture 是创建动画序列的数据驱动方法。</p>
<p>下面是三种动捕设备（光学、磁力和机械）。</p>
<p><img src="/images/Games101/21/22.png"></p>
<p><strong>优点：</strong></p>
<ul>
<li>非常贴近真实</li>
<li>可以快速的过去大量的真实数据。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>准备工作复杂且高花费。</li>
<li>捕捉到的动画可能不满足艺术家的需要，需要选择。</li>
</ul>
<h2 id="5-动画-电影生产的-Pipeline"><a href="#5-动画-电影生产的-Pipeline" class="headerlink" title="5 动画&#x2F;电影生产的 Pipeline"></a>5 动画&#x2F;电影生产的 Pipeline</h2><p><img src="/images/Games101/21/23.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489/article/details/121895993?ops_request_misc=%7B%22request_id%22:%22170581620516800225512166%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=170581620516800225512166&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-14-121895993-null-null.nonecase&utm_term=%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0&spm=1018.2226.3001.4450">图形学笔记（十九）动画 —— 动画的历史、关键帧插值、物理仿真、质点弹簧系统、粒子系统、（反向IK）动力学、Rigging 绑定、Blend Shapes、动作捕捉_骨骼 逆运动学 动作捕捉 刚体模拟 流体模拟-CSDN博客</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/20/games101/Lec%2020/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/20/games101/Lec%2020/" class="post-title-link" itemprop="url">【Games 101】Lec 20：颜色和感知</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-20 16:41:43 / 修改时间：23:28:49" itemprop="dateCreated datePublished" datetime="2024-01-20T16:41:43+08:00">2024-01-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-20：Color-and-Perception"><a href="#Lecture-20：Color-and-Perception" class="headerlink" title="Lecture 20：Color and Perception"></a>Lecture 20：Color and Perception</h1><p>东西挺多的…</p>
<h1 id="1-光场（Light-Field-Lumigraph）"><a href="#1-光场（Light-Field-Lumigraph）" class="headerlink" title="1 光场（Light Field &#x2F; Lumigraph）"></a>1 光场（Light Field &#x2F; Lumigraph）</h1><h2 id="1-1-全光函数（The-Plenoptic-Function）"><a href="#1-1-全光函数（The-Plenoptic-Function）" class="headerlink" title="1.1 全光函数（The Plenoptic Function）"></a>1.1 全光函数（The Plenoptic Function）</h2><p><img src="/images/Games101/20/01.png"></p>
<p><strong>将整个世界看成是七个维度的函数：</strong></p>
<ul>
<li>θ,ϕ：角度</li>
<li>λ：光的波长信息（表示颜色信息）</li>
<li>t：时间</li>
<li>Vx，Vy，Vz：可以改变自己的位置从另外的角度看世界</li>
</ul>
<p>P( … ) 这个函数可以表示在任何地方，任何方向，任何时间看到的东西的颜色，这个函数就是<strong>全光函数</strong></p>
<p><img src="/images/Games101/20/02.png"></p>
<p><strong>光场就是全光函数的一部分。</strong></p>
<h2 id="1-2-光线-Ray"><a href="#1-2-光线-Ray" class="headerlink" title="1.2 光线 Ray"></a>1.2 光线 Ray</h2><p><strong>光线是一个5D表示的，包含 3D 的 position 和 2D 的 direction。</strong></p>
<p><img src="/images/Games101/20/03.png"></p>
<p><strong>另一种定义方式：两个点定义一条光线。</strong></p>
<p><strong>它是4D表示的，包含 2D 的 direction 和 2D 的 position。</strong></p>
<p><img src="/images/Games101/20/04.png"></p>
<h2 id="1-3-光场"><a href="#1-3-光场" class="headerlink" title="1.3 光场"></a>1.3 光场</h2><h3 id="1-3-1-定义"><a href="#1-3-1-定义" class="headerlink" title="1.3.1 定义"></a>1.3.1 定义</h3><p>想要描述一个物体的视觉信息，只要找出它的包围盒，并记录包围盒表面任意一点向任意方向的发光情况即可。</p>
<p><strong>光场就是在任何一个位置往任何一个方向去的光照强度。</strong></p>
<p><img src="/images/Games101/20/05.png"></p>
<h3 id="1-3-2-光场的作用"><a href="#1-3-2-光场的作用" class="headerlink" title="1.3.2 光场的作用"></a>1.3.2 光场的作用</h3><p>有了光场后，从任意位置都可以看向这个物体，有了<strong>视点</strong>和<strong>看向的方向</strong>，查询4D的函数就可以查询到记录的值（光的强度）。</p>
<p><img src="/images/Games101/20/06.png"></p>
<p>有了包围盒之后，就可以<strong>忽略光场内部的细节</strong>，<strong>只要记录包围盒表面的任何位置任何方向的光照信息即可</strong>。</p>
<p><img src="/images/Games101/20/07.png"></p>
<h3 id="1-3-3-光场的表示方式"><a href="#1-3-3-光场的表示方式" class="headerlink" title="1.3.3 光场的表示方式"></a>1.3.3 光场的表示方式</h3><ul>
<li><p>起始点 + 一个角度</p>
</li>
<li><p><img src="/images/Games101/20/08.png"></p>
</li>
<li><p>两个相互平行的平面，两个点确定一条光线</p>
</li>
<li><p><img src="/images/Games101/20/09.png"></p>
</li>
<li><p>参数化的表示两个平面（s t）（u v），找到所有 uv 和 st 的对应关系，便可以定义任意一条光线。</p>
</li>
</ul>
<p>下面看一下解释，假设整个世界在 st 面的右边：</p>
<ul>
<li><strong>固定 uv 平面点x，从这个点看向 st 面的不同的点yi，然后所有yi的集合相当于就是一张图像（改变x，相当于就是从不同的角度去看这个物体）</strong></li>
</ul>
<p><img src="/images/Games101/20/10.png"></p>
<ul>
<li><strong>固定 st 平面上的点x，从 uv 面的不同的点 yi 看向x，那么所有的yi的集合就是这个物体的一个方向的结果（改变x，得到的就是这个物体的不同方向上的结果）</strong></li>
</ul>
<p><img src="/images/Games101/20/11.png"></p>
<h3 id="1-3-4-光场摄像机（Light-Field-Camera）"><a href="#1-3-4-光场摄像机（Light-Field-Camera）" class="headerlink" title="1.3.4 光场摄像机（Light Field Camera）"></a>1.3.4 光场摄像机（Light Field Camera）</h3><p><strong>原理：</strong>本来是光都打在一个像素上的，但是现在把像素的位置往后移一下，原来的位置放成一个微透镜，让透镜把来自于不同方向的光分开然后记录下来，然后对于特定方向上的光线重新聚焦。</p>
<p><img src="/images/Games101/20/12.png"></p>
<p><img src="/images/Games101/20/13.png"></p>
<p>还原普通照片的方法：对于每个透镜都选择每一“块”的最底部的像素。</p>
<p>有了光场之后，可以虚拟移动相机的位置（重新聚焦也是一样的道理）。</p>
<p><img src="/images/Games101/20/14.png"></p>
<p><strong>总结</strong>：光场相机能实现虚拟移动相机位置，改变聚焦等功能。</p>
<p><strong>光场相机特点</strong>：光场摄像机记录了所有的光场信息。</p>
<p><strong>光场相机的问题</strong></p>
<ul>
<li>光场相机的空间上的分辨率不足。</li>
<li>高成本（胶片分辨率十分高，微透镜很精密）。</li>
</ul>
<h1 id="2-颜色"><a href="#2-颜色" class="headerlink" title="2 颜色"></a>2 颜色</h1><p><strong>颜色是人的感知的结果</strong>，他不是光的自然属性。不同波长的光不是“颜色”。</p>
<h2 id="2-1-颜色的物理学基础"><a href="#2-1-颜色的物理学基础" class="headerlink" title="2.1 颜色的物理学基础"></a>2.1 颜色的物理学基础</h2><h3 id="2-1-1-可见的光的波段"><a href="#2-1-1-可见的光的波段" class="headerlink" title="2.1.1 可见的光的波段"></a>2.1.1 可见的光的波段</h3><p><img src="/images/Games101/20/15.png"></p>
<h3 id="2-1-2-谱功率密度-Spectral-Power-Distribution-SPD"><a href="#2-1-2-谱功率密度-Spectral-Power-Distribution-SPD" class="headerlink" title="2.1.2 谱功率密度 Spectral Power Distribution(SPD)"></a>2.1.2 谱功率密度 Spectral Power Distribution(SPD)</h3><p>SPD 是光线不同波长的光强分布是多少，如下图所示蓝天能量集中在波长低的部分，日光波长越高能量越大。</p>
<p><img src="/images/Games101/20/16.png"></p>
<p><strong>SPD 具有线性性质，即可以叠加。</strong></p>
<h2 id="2-2-颜色的生物学基础"><a href="#2-2-颜色的生物学基础" class="headerlink" title="2.2 颜色的生物学基础"></a>2.2 颜色的生物学基础</h2><p>人的眼睛是摄像机，瞳孔是光圈，晶状体是透镜（通过肌肉伸缩来控制焦距），视网膜是传感器。</p>
<p><img src="/images/Games101/20/17.png"></p>
<h3 id="2-2-1-感光细胞：Rods-and-Cones"><a href="#2-2-1-感光细胞：Rods-and-Cones" class="headerlink" title="2.2.1 感光细胞：Rods and Cones"></a>2.2.1 感光细胞：Rods and Cones</h3><p>视网膜具有感光细胞（Retinel Photoreceptor Cells）：<strong>棒状和锥形细胞（Rods and Cones ）</strong></p>
<p><strong>Rods（棒状细胞）：感知光的强度，可以得到灰度图。~120 million</strong></p>
<p><strong>Cones（锥形细胞）：感知光的颜色。~6-7 million</strong></p>
<p>由于三种类型的细胞对于波长的感光程度不同，<strong>Cones可以进一步划分为三类：S-Cone，M-Cone，L-Cone。</strong></p>
<p><img src="/images/Games101/20/18.png"></p>
<h3 id="2-2-2-Tristimulus-Theory-of-Color"><a href="#2-2-2-Tristimulus-Theory-of-Color" class="headerlink" title="2.2.2 Tristimulus Theory of Color"></a>2.2.2 Tristimulus Theory of Color</h3><p>以下是人类锥形细胞的相应曲线，SML是人类最终看到的结果（只是一个数，不是光谱而是积分的结果）。</p>
<p><img src="/images/Games101/20/19.png"></p>
<p>每一个光的波长信息不能被人眼测量和大脑接收。</p>
<p>眼睛值看到了三个 response values（S,M,L），并且是大脑唯一可获取的信息。</p>
<p><img src="/images/Games101/20/20.png"></p>
<h3 id="2-2-3-同色异谱（Metamerism）"><a href="#2-2-3-同色异谱（Metamerism）" class="headerlink" title="2.2.3 同色异谱（Metamerism）"></a>2.2.3 同色异谱（Metamerism）</h3><p>Metamerism 是不同的光谱 spectra（ ∞ − dim）会映射到相同（S,M,L）的响应。</p>
<ul>
<li>这些似乎会对一个人产生相同的颜色（光谱不一定相同，但颜色可以相同）。</li>
</ul>
<p>Metamerism 对颜色reproduction很重要。</p>
<ul>
<li>不需要重构出真实世界的整个光谱。</li>
<li>例如metamer可以在显示器仅使用每个像素的三个颜色便可重现真实场景感知到的光。</li>
</ul>
<p><img src="/images/Games101/20/21.png"></p>
<h2 id="2-3-颜色匹配（Color-Reproduction-Matching）"><a href="#2-3-颜色匹配（Color-Reproduction-Matching）" class="headerlink" title="2.3 颜色匹配（Color Reproduction &#x2F; Matching）"></a>2.3 颜色匹配（Color Reproduction &#x2F; Matching）</h2><p><strong>加色系统 Additive Color</strong></p>
<ul>
<li>给定一组主要的光，每个光都有自己的光谱分布（例如使用RGB显示像素）。</li>
<li>调整这些光的亮度并把它们加在一起。</li>
<li>颜色最后被标量（R,G,B）描述。</li>
</ul>
<p><img src="/images/Games101/20/22.png"></p>
<p>（可以进行减色）</p>
<p><strong>CIE RGB Color Matching</strong></p>
<p>下图图显示每个CIE RGB主要（primary）光匹配x轴上给定波长的单色光需要混合的量。（注意有负的结果）。</p>
<p>对于任何一个光谱s，感知到的光被下面的公式匹配（缩放CIE RGB原色）。</p>
<p><img src="/images/Games101/20/23.png"></p>
<h2 id="2-4-颜色空间（Color-Spaces）"><a href="#2-4-颜色空间（Color-Spaces）" class="headerlink" title="2.4 颜色空间（Color Spaces）"></a>2.4 颜色空间（Color Spaces）</h2><h3 id="2-4-1-Standard-Color-Spaces（标准颜色空间）"><a href="#2-4-1-Standard-Color-Spaces（标准颜色空间）" class="headerlink" title="2.4.1 Standard Color Spaces（标准颜色空间）"></a>2.4.1 Standard Color Spaces（标准颜色空间）</h3><ul>
<li>先让特定的机器做好之后，让其他机器模仿这种RGB标准。</li>
<li>现在被广泛采用。</li>
<li>色域gamut是有限的。</li>
</ul>
<h3 id="2-4-2-色域（Gamut）"><a href="#2-4-2-色域（Gamut）" class="headerlink" title="2.4.2 色域（Gamut）"></a>2.4.2 色域（Gamut）</h3><p>Gamut 是被一个原色集生成的所有色度（chromaticities）。</p>
<p>不同的颜色空间表示不同范围的颜色，具有不同的色域（gamut），即它们覆盖charomaticities的不同区域。</p>
<p><img src="/images/Games101/20/24.png"></p>
<h3 id="2-4-3-常见的颜色空间"><a href="#2-4-3-常见的颜色空间" class="headerlink" title="2.4.3 常见的颜色空间"></a>2.4.3 常见的颜色空间</h3><ol>
<li><h5 id="科学上普遍的颜色空间：CIE-XYZ"><a href="#科学上普遍的颜色空间：CIE-XYZ" class="headerlink" title="科学上普遍的颜色空间：CIE XYZ"></a>科学上普遍的颜色空间：CIE XYZ</h5></li>
</ol>
<p>CIE是人造的颜色匹配系统。</p>
<p>首先设定标准颜色原色组X,Y,Z。</p>
<ul>
<li>不存在具有这些匹配函数的原色。</li>
<li>Y是luminace亮度（亮度与颜色无关）</li>
</ul>
<p>这个系统设计成匹配函数严格为正，覆盖所有可见光的范围。</p>
<p><img src="/images/Games101/20/25.png"></p>
<ol start="2">
<li><h5 id="HSV-Color-Space-Hue-Saturation-Value"><a href="#HSV-Color-Space-Hue-Saturation-Value" class="headerlink" title="HSV Color Space(Hue-Saturation-Value)"></a>HSV Color Space(Hue-Saturation-Value)</h5></li>
</ol>
<p>HSV 常见于颜色拾取器中（PS中常见）。</p>
<ul>
<li><strong>Hue：不同类型的颜色。</strong></li>
<li><strong>Saturation：更接近白色还是纯色（单一颜色）。</strong></li>
<li><strong>Brightness：从黑色到某种颜色。</strong></li>
</ul>
<p><img src="/images/Games101/20/26.png"></p>
<ol start="3">
<li><strong>CIELAB Space(AKA L<em>a</em>b*)</strong></li>
</ol>
<p>CIELAB Space是与感知有关的色彩空间。</p>
<ul>
<li>L* 是 Lightness（brightness）</li>
<li>a 和 b 是互补颜色对（a<em>是red-green，b</em>是blue-yellow）。</li>
</ul>
<p><img src="/images/Games101/20/27.png"></p>
<ol start="4">
<li><strong>CMYK：A Subtractive（减色） Color Space</strong></li>
</ol>
<p>Subtractive color model：混合的越多就越暗。</p>
<p>青色Cyan、洋红Magenta、黄色Yellow和黑色，并（Key Widely）广泛用于打印。</p>
<p><img src="/images/Games101/20/28.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/20/games101/Lec%2019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/20/games101/Lec%2019/" class="post-title-link" itemprop="url">【Games 101】Lec 19：照相机、镜头、光场</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-20 16:39:46 / 修改时间：19:06:55" itemprop="dateCreated datePublished" datetime="2024-01-20T16:39:46+08:00">2024-01-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-19：Cameras-Lenses-and-Light-Fields"><a href="#Lecture-19：Cameras-Lenses-and-Light-Fields" class="headerlink" title="Lecture 19：Cameras, Lenses and Light Fields"></a>Lecture 19：Cameras, Lenses and Light Fields</h1><h1 id="1-视场（Field-of-View（FOV））"><a href="#1-视场（Field-of-View（FOV））" class="headerlink" title="1. 视场（Field of View（FOV））"></a>1. 视场（Field of View（FOV））</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><strong>FOV：看到的角度</strong></p>
<p><strong>h：高度</strong></p>
<p><strong>f：焦距</strong></p>
<p><img src="/images/Games101/19/01.png"></p>
<h2 id="1-2-焦距（Focal-length）对视场（FOV）的影响"><a href="#1-2-焦距（Focal-length）对视场（FOV）的影响" class="headerlink" title="1.2 焦距（Focal length）对视场（FOV）的影响"></a>1.2 焦距（Focal length）对视场（FOV）的影响</h2><p><strong>当传感器大小一定时，FOV 随着焦距增加而减少。</strong></p>
<p><img src="/images/Games101/19/02.png"></p>
<h2 id="1-3-传感器（Sensor）大小对视场的影响"><a href="#1-3-传感器（Sensor）大小对视场的影响" class="headerlink" title="1.3 传感器（Sensor）大小对视场的影响"></a>1.3 传感器（Sensor）大小对视场的影响</h2><p>通常，<strong>相机（传感器）越大，镜头（焦距）越长越好。</strong></p>
<p><img src="/images/Games101/19/03.png"></p>
<h1 id="2-曝光-Exposure"><a href="#2-曝光-Exposure" class="headerlink" title="2. 曝光 Exposure"></a>2. 曝光 Exposure</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul>
<li><strong>H&#x3D;T×E</strong></li>
<li><strong>Exposure &#x3D; Time × Irradiance</strong></li>
<li><strong>T（曝光时间）由快门（shuttle）控制</strong></li>
<li><strong>E（Irradiance）由传感器上一个单位区域接收光的能量和镜头的光圈（aperture）和焦距控制。</strong></li>
</ul>
<p><img src="/images/Games101/19/04.png"></p>
<h2 id="2-2-曝光的影响因素"><a href="#2-2-曝光的影响因素" class="headerlink" title="2.2 曝光的影响因素"></a>2.2 曝光的影响因素</h2><ul>
<li><strong>Aperture size（光圈的大小）：通过打开和关闭 apeture 改变 f-stop。</strong></li>
<li><strong>Shuttle speed（快门开放的时间）：改变sensors的曝光时间即每个像素接收光的时间，快门越快曝光越少</strong></li>
<li><strong>ISO （Gain 感光度）：更改传感器值和数字图像值之间的倍率（模拟和&#x2F;或数字）。</strong></li>
</ul>
<p><img src="/images/Games101/19/05.png"></p>
<h2 id="2-3-感光度-ISO（Gain）"><a href="#2-3-感光度-ISO（Gain）" class="headerlink" title="2.3 感光度 ISO（Gain）"></a>2.3 感光度 ISO（Gain）</h2><p><strong>ISO</strong> 是 exposure 的第三个变量，<strong>简单放大ISO信号的同时会方法噪声</strong>。</p>
<p><strong>Film</strong>：权衡对（grain）的敏感度。</p>
<p><strong>Digital</strong>：权衡对噪声的敏感度。</p>
<ul>
<li>在模拟到数字的转换前乘以信号。</li>
<li>线性作用（ISO 200需要的光是ISO 100的一半）</li>
</ul>
<h2 id="2-4-F-Number-F-Stop-：Exposure-Levels"><a href="#2-4-F-Number-F-Stop-：Exposure-Levels" class="headerlink" title="2.4 F-Number(F-Stop)：Exposure Levels"></a>2.4 F-Number(F-Stop)：Exposure Levels</h2><ul>
<li>用于描述光圈的</li>
</ul>
<p>写作 FN或F&#x2F;N，N就是f-number。<br>简单理解为光圈的直径的倒数。</p>
<p><strong>正式定义</strong>：<strong>镜头的 f-number 是 焦距 除以 光圈的直径。</strong></p>
<p><img src="/images/Games101/19/06.png"></p>
<h2 id="2-5-快门-Physical-Shutter"><a href="#2-5-快门-Physical-Shutter" class="headerlink" title="2.5 快门 Physical Shutter"></a>2.5 快门 Physical Shutter</h2><p>快门可以用于调节曝光度。</p>
<p><strong>运动模糊（Motion blur）</strong>：由于快门打开有时间会拍摄到一段运动。</p>
<p>两倍的快门时间意味着两倍的运动模糊。</p>
<p>运动模糊不一定是坏事，从人的感知角度它可以<strong>形容速度快</strong>从采样角度，它也可以进行<strong>反走样</strong>。</p>
<p><img src="/images/Games101/19/07.png"></p>
<p><strong>Rolling shutter</strong>：图像上的不同位置可能会记录不同时间进入的光（会造成扭曲）。</p>
<h2 id="2-6-F-Stop-vs-Shutter-Speed"><a href="#2-6-F-Stop-vs-Shutter-Speed" class="headerlink" title="2.6 F-Stop vs Shutter Speed"></a>2.6 F-Stop vs Shutter Speed</h2><p>两者可以组合，调节曝光度；</p>
<p><img src="/images/Games101/19/08.png"></p>
<p>Photographers 需要权衡景深和运动物体的运动模糊。</p>
<h2 id="2-7-高速摄影和延时摄影（Fast-and-Slow-Photography）"><a href="#2-7-高速摄影和延时摄影（Fast-and-Slow-Photography）" class="headerlink" title="2.7 高速摄影和延时摄影（Fast and Slow Photography）"></a>2.7 高速摄影和延时摄影（Fast and Slow Photography）</h2><p><strong>High-Speed Photography</strong>：每秒拍更多的照片，也导致快门时间很少（短曝光时间，得用更大的光圈）。</p>
<p><img src="/images/Games101/19/09.png"></p>
<p><strong>Long-Exposure Photography</strong>：长曝光时间，小光圈。</p>
<p><img src="/images/Games101/19/10.png"></p>
<h1 id="3-薄透镜近似-Thin-Lens-Approximation"><a href="#3-薄透镜近似-Thin-Lens-Approximation" class="headerlink" title="3. 薄透镜近似 Thin Lens Approximation"></a>3. 薄透镜近似 Thin Lens Approximation</h1><p>真正的透镜非常复杂，需要一个简单的方法描述。</p>
<h2 id="3-1-理想化薄透镜（Ideal-Thin-Lens-Focal-Point）"><a href="#3-1-理想化薄透镜（Ideal-Thin-Lens-Focal-Point）" class="headerlink" title="3.1 理想化薄透镜（Ideal Thin Lens - Focal Point）"></a>3.1 理想化薄透镜（Ideal Thin Lens - Focal Point）</h2><ul>
<li><strong>所有进入透镜的平行光一定过焦点。</strong></li>
<li><strong>过交点的在透镜后面一定是平行光。</strong></li>
<li><strong>认为焦距可以被随意改变（透镜组）。</strong></li>
</ul>
<p><img src="/images/Games101/19/11.png"></p>
<h2 id="3-2-薄透镜公式（The-Thin-Lens-Equation）"><a href="#3-2-薄透镜公式（The-Thin-Lens-Equation）" class="headerlink" title="3.2 薄透镜公式（The Thin Lens Equation）"></a>3.2 薄透镜公式（The Thin Lens Equation）</h2><ul>
<li><strong>公式：（物距，像距，焦距 三者的关系）</strong></li>
</ul>
<p><img src="/images/Games101/19/12.png"></p>
<ul>
<li><strong>公式推导：</strong></li>
</ul>
<p><img src="/images/Games101/19/13.png"></p>
<h2 id="3-3-Defocus-Blur"><a href="#3-3-Defocus-Blur" class="headerlink" title="3.3 Defocus Blur"></a>3.3 Defocus Blur</h2><h3 id="3-3-1-Computing-Cicle-of-Confusion-CoC-Size"><a href="#3-3-1-Computing-Cicle-of-Confusion-CoC-Size" class="headerlink" title="3.3.1 Computing Cicle of Confusion(CoC) Size"></a>3.3.1 Computing Cicle of Confusion(CoC) Size</h3><p>如图，Object远离Focal Plane，聚焦后的点不在Sensor Plane上，而是在它前面聚焦，然后光线在聚焦点继续直线传播，到Sensor Plane上就变成了一个圆。（产生了模糊）</p>
<p><img src="/images/Games101/19/14.png"></p>
<p>其中：<strong>A是光圈直径，C是CoC的直径。</strong></p>
<p>Circle of Confusion 与光圈大小成正比。所以看到的东西<strong>是否模糊与光圈的大小有关</strong>。</p>
<p>将上面的公式与F-Number联系起来。</p>
<p><img src="/images/Games101/19/15.png"></p>
<h3 id="3-3-2-Ray-Tracing-Ideal-Thin-Lenses"><a href="#3-3-2-Ray-Tracing-Ideal-Thin-Lenses" class="headerlink" title="3.3.2 Ray Tracing Ideal Thin Lenses"></a>3.3.2 Ray Tracing Ideal Thin Lenses</h3><p><img src="/images/Games101/19/16.png"></p>
<p><strong>步骤：</strong></p>
<ul>
<li>先定义Sensor的大小（成像平面大小），然后定义透镜的属性，即焦距和光圈的大小。</li>
<li>定义透镜和关注平面的距离 zo（物距）。</li>
<li>根据透镜方程计算相应的深度 zi（相距）。</li>
</ul>
<p><strong>渲染：</strong></p>
<ul>
<li>对于每个在sensor上的像素 x′</li>
<li>在 lens plane上取样随机一点 x′′</li>
<li>然后知道了通过透镜的光线会打到 x′′′</li>
<li>计算光线 x′′ → x′′′ 的radiance。</li>
</ul>
<h3 id="3-3-3-景深（Depth-of-Field）"><a href="#3-3-3-景深（Depth-of-Field）" class="headerlink" title="3.3.3 景深（Depth of Field）"></a>3.3.3 景深（Depth of Field）</h3><p><strong>景深：</strong>就是指 <strong>成像清晰的一段范围</strong></p>
<p>或者说：<strong>在场景内对应的CoC足够小的距离范围。</strong></p>
<p><img src="/images/Games101/19/17.png"></p>
<p><strong>推导：</strong></p>
<p><img src="/images/Games101/19/18.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489/article/details/121771735?ops_request_misc=%7B%22request_id%22:%22170567531416800227439114%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=170567531416800227439114&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-10-121771735-null-null.nonecase&utm_term=%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0&spm=1018.2226.3001.4450">图形学笔记（十七）相机，棱镜 ——FOV、焦距、曝光、F-Stop、ISO、薄透镜公式、Circle of Confusion Size、景深、理想薄透镜光线追踪_相机凌镜成像-CSDN博客</a></p>
<p>光场放在了下一篇。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="FJBQ"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">FJBQ</p>
  <div class="site-description" itemprop="description">坚定 坚持 坚强</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-10 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FJBQ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共48.8k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":225,"hOffset":-15,"vOffset":-15},"mobile":{"show":false},"react":{"opacity":1},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
