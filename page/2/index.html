<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="坚定 坚持 坚强">
<meta property="og:type" content="website">
<meta property="og:title" content="FJBQ">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="FJBQ">
<meta property="og:description" content="坚定 坚持 坚强">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="FJBQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>FJBQ</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="FJBQ" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">FJBQ</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/27/games101/HomeWork%201/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/27/games101/HomeWork%201/" class="post-title-link" itemprop="url">【Games 101】HomeWork 1：旋转与投影</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-27 23:25:29 / 修改时间：23:59:13" itemprop="dateCreated datePublished" datetime="2024-01-27T23:25:29+08:00">2024-01-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HomeWork-1：旋转与投影"><a href="#HomeWork-1：旋转与投影" class="headerlink" title="HomeWork 1：旋转与投影"></a>HomeWork 1：旋转与投影</h1><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    模型变换：</span></span><br><span class="line"><span class="comment">        逐个元素地构建模型变换矩阵并返回该矩阵。</span></span><br><span class="line"><span class="comment">        在此函数中，你只需要实现三维中绕 z 轴旋转的变换矩阵，而不用处理平移与缩放。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    分析：</span></span><br><span class="line"><span class="comment">        这个比较简单，提示也说了我们只需要绕着 z 轴旋转就行；</span></span><br><span class="line"><span class="comment">        回顾一下公式：http://fjbq-blog.top/2023/12/30/GAMES%20101%20%E9%9A%8F%E7%AC%94/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_model_matrix</span><span class="params">(<span class="type">float</span> rotation_angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 转换为弧度制</span></span><br><span class="line">    <span class="type">float</span> rotation_angle_rad = rotation_angle / <span class="number">180.0</span> * MY_PI;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 模型变换矩阵，默认初始化矩阵为单位矩阵</span></span><br><span class="line">    Eigen::Matrix4f model = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line"></span><br><span class="line">    model &lt;&lt; <span class="built_in">cos</span>(rotation_angle_rad), -<span class="built_in">sin</span>(rotation_angle_rad), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">             <span class="built_in">sin</span>(rotation_angle_rad), <span class="built_in">cos</span>(rotation_angle_rad), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">             <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">             <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //绕x轴</span></span><br><span class="line"><span class="comment">    model &lt;&lt; 1, 0, 0, 0,</span></span><br><span class="line"><span class="comment">             0, cos(angle), -sin(angle), 0,</span></span><br><span class="line"><span class="comment">             0, sin(angle), cos(angle), 0,</span></span><br><span class="line"><span class="comment">             0, 0, 0, 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //绕y轴（注意是反的哦）</span></span><br><span class="line"><span class="comment">    model &lt;&lt; cos(angle), 0, sin(angle), 0,</span></span><br><span class="line"><span class="comment">             0, 1, 0, 0,</span></span><br><span class="line"><span class="comment">             -sin(angle), 0, cos(angle), 0,</span></span><br><span class="line"><span class="comment">             0, 0, 0, 1;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    投影变换：</span></span><br><span class="line"><span class="comment">        使用给定的参数逐个元素地构建透视投影矩阵并返回该矩阵。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    分析：</span></span><br><span class="line"><span class="comment">        这个感觉就比较复杂一点了...</span></span><br><span class="line"><span class="comment">        首先根据前面的学习，我们知道 透视投影矩阵 = 正交投影矩阵 * 透视压缩矩阵（注意顺序哦）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        其中这个 正交投影矩阵 里面用到的参数需要我们去求一下的...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_projection_matrix</span><span class="params">(<span class="type">float</span> eye_fov, <span class="type">float</span> aspect_ratio, <span class="type">float</span> zNear, <span class="type">float</span> zFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	怎么感觉知乎大佬的代码怪怪的；</span></span><br><span class="line"><span class="comment">    	这个 zNear，zFar 给的是正数；</span></span><br><span class="line"><span class="comment">    	下面计算的都是用的负数，先转换一下？</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    zNear = -zNear;</span><br><span class="line">    zFar = -zFar;</span><br><span class="line">    </span><br><span class="line">    Eigen::Matrix4f projection = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 透视投影压缩矩阵</span></span><br><span class="line">    Eigen::Matrix4f M_persp;</span><br><span class="line">    M_persp &lt;&lt;  zNear, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, zNear, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, zNear + zFar, -zNear*zFar,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求一下正交投影矩阵要用到的参数</span></span><br><span class="line">    <span class="type">float</span> alpha = <span class="number">0.5</span> * (eye_fov / <span class="number">180.0f</span> * MY_PI);     <span class="comment">// 视野角度的一半</span></span><br><span class="line">    <span class="type">float</span> yTop = -zNear * std::<span class="built_in">tan</span>(alpha);              <span class="comment">// 因为这里的z给的是负数，所以加负号之后再转换</span></span><br><span class="line">    <span class="type">float</span> yBottom = -yTop;</span><br><span class="line">    <span class="type">float</span> xRight = yTop * aspect_ratio;                 <span class="comment">// aspect_ratio 是 xy 的比例</span></span><br><span class="line">    <span class="type">float</span> xLeft = -xRight;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix4f M_trans;</span><br><span class="line">    M_trans &lt;&lt;  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -(xLeft + xRight) / <span class="number">2</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -(yTop + yBottom) / <span class="number">2</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -(zNear + zFar) / <span class="number">2</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix4f M_ortho;</span><br><span class="line">    M_ortho &lt;&lt;  <span class="number">2</span> / (xRight - xLeft), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">2</span> / (yTop - yBottom), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span> / (zNear - zFar), <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个就是 正交投影矩阵</span></span><br><span class="line">    M_ortho = M_ortho * M_trans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 透视投影矩阵 = 正交投影矩阵 * 透视压缩矩阵（注意顺序哦）</span></span><br><span class="line">    projection = M_ortho * M_persp * projection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> projection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    进阶 模型变换矩阵：绕任意轴旋转</span></span><br><span class="line"><span class="comment">    参考的是知乎大佬的：https://zhuanlan.zhihu.com/p/448904350</span></span><br><span class="line"><span class="comment">    用 n 表示一个过原点的向量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_random_model_matrix</span><span class="params">(Eigen::Vector3f n,<span class="type">float</span> rotation_angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Matrix4f model = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line">    Eigen::Matrix3f I = Eigen::Matrix3f::<span class="built_in">Identity</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> angle = rotation_angle / <span class="number">180.0f</span> * MY_PI ;</span><br><span class="line">    <span class="type">float</span> nx = n[<span class="number">0</span>];</span><br><span class="line">    <span class="type">float</span> ny = n[<span class="number">1</span>];</span><br><span class="line">    <span class="type">float</span> nz = n[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    Eigen::Matrix3f N;</span><br><span class="line">    N &lt;&lt; <span class="number">0</span>, -nz, ny,</span><br><span class="line">         nz, <span class="number">0</span>, -nx,</span><br><span class="line">         -ny, nx, <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公式</span></span><br><span class="line">    Eigen::Matrix3f R = std::<span class="built_in">cos</span>(angle) * I + (<span class="number">1</span> - std::<span class="built_in">cos</span>(angle)) * n * n.<span class="built_in">transpose</span>() + std::<span class="built_in">sin</span>(angle) * N;</span><br><span class="line">    </span><br><span class="line">    model &lt;&lt; <span class="built_in">R</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">R</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">R</span>(<span class="number">0</span>, <span class="number">2</span>), <span class="number">0</span>,</span><br><span class="line">             <span class="built_in">R</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">R</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">R</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="number">0</span>,</span><br><span class="line">             <span class="built_in">R</span>(<span class="number">2</span>, <span class="number">0</span>), <span class="built_in">R</span>(<span class="number">2</span>, <span class="number">1</span>), <span class="built_in">R</span>(<span class="number">2</span>, <span class="number">2</span>), <span class="number">0</span>,</span><br><span class="line">             <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><p><img src="/images/Games101/homework/01/01.png"></p>
<p><img src="/images/Games101/homework/01/02.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/21/games101/Lec%2022/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/21/games101/Lec%2022/" class="post-title-link" itemprop="url">【Games 101】Lec 22：动画（续）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-21 13:52:23 / 修改时间：18:02:42" itemprop="dateCreated datePublished" datetime="2024-01-21T13:52:23+08:00">2024-01-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-22：Animation-cont"><a href="#Lecture-22：Animation-cont" class="headerlink" title="Lecture 22：Animation (cont.)"></a>Lecture 22：Animation (cont.)</h1><h2 id="1-单个粒子模拟（Single-Particle-Simulation）"><a href="#1-单个粒子模拟（Single-Particle-Simulation）" class="headerlink" title="1 单个粒子模拟（Single Particle Simulation）"></a>1 单个粒子模拟（Single Particle Simulation）</h2><h2 id="1-1-单个粒子的运动"><a href="#1-1-单个粒子的运动" class="headerlink" title="1.1 单个粒子的运动"></a>1.1 单个粒子的运动</h2><p>首先研究一个粒子的运动然后泛化到大多数粒子。</p>
<p>我们线认为粒子的运动由速度场(velocity vector field)决定，这个速度场就是一个位置和时间的函数：v（x，t）</p>
<p>知道粒子的位置和时间，就知道它的速度；（这个函数我们现在是已知的）</p>
<p><img src="/images/Games101/22/01.png"></p>
<p>那么，计算粒子的位置（随时间变化）需要解一个一阶的常微分方程(不存在对其他变量的微分或导数First-order意味着只存在一阶导数)：</p>
<p><img src="/images/Games101/22/02.png"></p>
<h2 id="1-2-欧拉方法（Euler’s-Method）"><a href="#1-2-欧拉方法（Euler’s-Method）" class="headerlink" title="1.2 欧拉方法（Euler’s Method）"></a>1.2 欧拉方法（Euler’s Method）</h2><h3 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h3><p>欧拉方法是一种简单的<strong>迭代方法</strong>，<strong>经常被使用</strong>、<strong>不准确</strong>、大多数都<strong>不稳定</strong>。</p>
<p>可以使用欧拉方法对给定初始位置和速度场的点求解经过时间t后所处的位置。</p>
<p><img src="/images/Games101/22/03.png"></p>
<h3 id="1-2-2-误差"><a href="#1-2-2-误差" class="headerlink" title="1.2.2 误差"></a>1.2.2 误差</h3><p>使用数值计算的方法积分，误差会累计，最后的Euler积分结果会很差。</p>
<p><img src="/images/Games101/22/04.png"></p>
<h3 id="1-2-3-欧拉方法的不稳定性（Instability-of-the-Euler-Method）"><a href="#1-2-3-欧拉方法的不稳定性（Instability-of-the-Euler-Method）" class="headerlink" title="1.2.3 欧拉方法的不稳定性（Instability of the Euler Method）"></a>1.2.3 欧拉方法的不稳定性（Instability of the Euler Method）</h3><p>如下图，粒子的轨迹始终不能沿着圆形或指定的轨迹。</p>
<p><img src="/images/Games101/22/05.png"></p>
<p>即欧拉方法有两个关键的问题：</p>
<ul>
<li>误差随着时间步长 Δt 的增加而增加。</li>
<li>不稳定性是一个普遍且严重的问题，它能造成模拟 diverge。</li>
</ul>
<h3 id="1-2-4-Errors-和-Instability"><a href="#1-2-4-Errors-和-Instability" class="headerlink" title="1.2.4 Errors 和 Instability"></a>1.2.4 Errors 和 Instability</h3><p>用有限差分数值积分法求解<br>导致两个问题:<br><strong>Errors</strong>：</p>
<ul>
<li>每个时间步的误差累积。精度随着模拟的进行而降低</li>
<li>在图形应用中，准确性可能不是关键</li>
</ul>
<p><strong>Instability</strong>：</p>
<ul>
<li>错误可以复合，导致模拟甚至发散当底层系统没有</li>
<li>缺乏稳定性是模拟中的一个基本问题不容忽视</li>
</ul>
<h2 id="1-3-克服不稳定性的方法"><a href="#1-3-克服不稳定性的方法" class="headerlink" title="1.3 克服不稳定性的方法"></a>1.3 克服不稳定性的方法</h2><h3 id="1-3-1-概述"><a href="#1-3-1-概述" class="headerlink" title="1.3.1 概述"></a>1.3.1 概述</h3><ul>
<li>中点法&#x2F;修正欧拉法<ul>
<li>起点和终点的平均速度</li>
</ul>
</li>
<li>自适应步长<ul>
<li>递归地比较一步和两个半步，直到可以接受错误</li>
</ul>
</li>
<li>隐式方法<ul>
<li>使用下一个时间步骤的速度(硬)</li>
</ul>
</li>
<li>基于位置&#x2F; Verlet的集成<ul>
<li>在时间步长后约束粒子的位置和速度</li>
</ul>
</li>
</ul>
<h3 id="1-3-2-中点法（Midpoint-Method）"><a href="#1-3-2-中点法（Midpoint-Method）" class="headerlink" title="1.3.2 中点法（Midpoint Method）"></a>1.3.2 中点法（Midpoint Method）</h3><ul>
<li>使用欧拉方法计算，点到达A( a )。</li>
<li>使用欧拉方法计算上一步起始点与A点的导数( b )。</li>
<li>使用中点的导数来重新更新位置( c )。</li>
</ul>
<p><img src="/images/Games101/22/06.png"></p>
<p>中点法比欧拉方法多了一个二次的项。</p>
<p><img src="/images/Games101/22/07.png"></p>
<h3 id="1-3-3-自适应步长法（Adaptive-Step-Size）"><a href="#1-3-3-自适应步长法（Adaptive-Step-Size）" class="headerlink" title="1.3.3 自适应步长法（Adaptive Step Size）"></a>1.3.3 自适应步长法（Adaptive Step Size）</h3><ul>
<li>使用步长为T计算一个欧拉步骤来获得 X(T)</li>
<li>计算两个欧拉步骤，步长为T&#x2F;2，获得 X(T&#x2F;2)</li>
<li>计算error ∣∣ X(T) − X(T&#x2F;2) ∣∣</li>
<li>If ( error &gt; threshold ) 减少步长并重复上面的步骤。</li>
</ul>
<p><img src="/images/Games101/22/08.png"></p>
<p>Adaptive 是基于 error 估计选择步长的方法，非常实用，但可能得到的步长会很小。</p>
<h3 id="1-3-3-隐式欧拉方法"><a href="#1-3-3-隐式欧拉方法" class="headerlink" title="1.3.3 隐式欧拉方法"></a>1.3.3 隐式欧拉方法</h3><p>也被称作后向方法，使用下一时间的导数来计算当前的步骤。</p>
<p><img src="/images/Games101/22/09.png"></p>
<p><img src="/images/Games101/22/10.png"></p>
<p><strong>定义与量化 “stability” （稳定性）的方法</strong></p>
<ul>
<li>使用局部截断误差（每个Δ \DeltaΔ的误差）&#x2F; 总截断累积误差（整体累加后的误差）来研究稳定性。</li>
<li>研究数的大小无意义，有意义的事研究它们的阶。</li>
<li>隐式欧拉方法的阶数为1，意味着局部截断误差为 O(h^2) 且全局阶段误差为 O(h)（h就是步长，定义为 Δt）。</li>
<li>O(h)的理解:如果将 h 减半，预期误差也会减半。</li>
</ul>
<p><img src="/images/Games101/22/11.png"></p>
<h3 id="1-3-4-Runge-Kutta-Families"><a href="#1-3-4-Runge-Kutta-Families" class="headerlink" title="1.3.4 Runge-Kutta Families"></a>1.3.4 Runge-Kutta Families</h3><p>Runge-Kutta方法是一系列用于求解 ODE 的高级方法。</p>
<p><strong>特点</strong></p>
<ul>
<li>擅长处理非线性问题。</li>
<li>它的四阶版是使用最广泛的，又名 RK4。</li>
</ul>
<p><img src="/images/Games101/22/12.png"></p>
<p>h就是步长，也就是 Δt</p>
<h3 id="1-3-5-Position-Based-Verlet-Integration"><a href="#1-3-5-Position-Based-Verlet-Integration" class="headerlink" title="1.3.5 Position-Based &#x2F; Verlet Integration"></a>1.3.5 Position-Based &#x2F; Verlet Integration</h3><p>这是一种不基于物理的方法，通过调整物体的位置使物体满足某种性质。</p>
<p><strong>思想：</strong></p>
<ul>
<li>在修改欧拉前步（forward-step）之后，约束粒子的位置以防止divergent、不稳定的现象。</li>
<li>使用约束位置计算速度。</li>
<li>这两种思想都会耗散能量，使其具有稳定性。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>快速又简单。</li>
<li>不是基于物理模拟的，不满足能量守恒。</li>
</ul>
<h1 id="2-刚体模拟（Rigid-Body-Simulation）"><a href="#2-刚体模拟（Rigid-Body-Simulation）" class="headerlink" title="2 刚体模拟（Rigid Body Simulation）"></a>2 刚体模拟（Rigid Body Simulation）</h1><p>刚体模拟与模拟单个粒子相似，只需额外考虑一些属性（角度，角速度）</p>
<p><img src="/images/Games101/22/13.png"></p>
<h1 id="3-流体模拟（Fluid-Simulation）"><a href="#3-流体模拟（Fluid-Simulation）" class="headerlink" title="3 流体模拟（Fluid Simulation）"></a>3 流体模拟（Fluid Simulation）</h1><h3 id="3-1-基于位置的简单流体模拟方法"><a href="#3-1-基于位置的简单流体模拟方法" class="headerlink" title="3.1 基于位置的简单流体模拟方法"></a>3.1 基于位置的简单流体模拟方法</h3><p><strong>关键思想</strong></p>
<ul>
<li>认为水是由刚体小球组成的。</li>
<li>认为水是不可压缩的。</li>
<li>只要某处的密度海绵，就需要通过改变粒子的位置来“纠正”。</li>
<li>需要知道任何位置的密度的梯度。</li>
<li>使用梯度下降法来进行更新。</li>
</ul>
<p><img src="/images/Games101/22/14.png"></p>
<h2 id="3-2-质点法和网络法（Eulerian-vs-Lagrangian）"><a href="#3-2-质点法和网络法（Eulerian-vs-Lagrangian）" class="headerlink" title="3.2 质点法和网络法（Eulerian vs. Lagrangian）"></a>3.2 质点法和网络法（Eulerian vs. Lagrangian）</h2><p><img src="/images/Games101/22/15.png"></p>
<h2 id="3-3-Material-Point-Method-MPM"><a href="#3-3-Material-Point-Method-MPM" class="headerlink" title="3.3 Material Point Method (MPM)"></a>3.3 Material Point Method (MPM)</h2><p>MPM 是一种混合的(Hybrid)，结合 Eulerian 和 Lagrangian 的方法。</p>
<ul>
<li>Lagrangian：认为粒子带有材质属性。</li>
<li>Eulerian：使用网格来做数值积分。</li>
<li>lnteraction：粒子将属性传递给网格，网格执行更新，然后插值回粒子。</li>
</ul>
<p><img src="/images/Games101/22/16.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489/article/details/121934159">图形学笔记（二十）粒子、刚体、流体的模拟—— 欧拉方法、Errors 和 Instability、中点法、自适应步长、隐式欧拉方法、Runge-Kutta方法、刚体与流体模拟（质点法、网格法、MPM）_隐式mpm-CSDN博客</a></p>
<p>结束，下面把作业做一做，然后打算做个玩具渲染器（当作毕设了…）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/21/games101/Lec%2021/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/21/games101/Lec%2021/" class="post-title-link" itemprop="url">【Games 101】Lec 21：动画</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-21 13:52:23 / 修改时间：15:23:16" itemprop="dateCreated datePublished" datetime="2024-01-21T13:52:23+08:00">2024-01-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-21：Animation"><a href="#Lecture-21：Animation" class="headerlink" title="Lecture 21：Animation"></a>Lecture 21：Animation</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>“Bring things to life”</p>
<ul>
<li>交流的工具</li>
<li>美学引导技术</li>
</ul>
<p>建模的扩展</p>
<ul>
<li>把3d模型延申到时间的维度</li>
</ul>
<p>输出：按顺序播放的图片序列，提供一种运动感。</p>
<ul>
<li>电影：24 fps</li>
<li>Video（通常）：30 fps</li>
<li>Virtual reality：90 fps</li>
</ul>
<h1 id="2-Historical-Points-in-Animation"><a href="#2-Historical-Points-in-Animation" class="headerlink" title="2 Historical Points in Animation"></a>2 Historical Points in Animation</h1><p>这个看一下PPT就行…</p>
<p><img src="/images/Games101/21/01.png"></p>
<h1 id="3-动画技术"><a href="#3-动画技术" class="headerlink" title="3 动画技术"></a>3 动画技术</h1><h2 id="3-1-关键帧动画（Keyframe-Animation）"><a href="#3-1-关键帧动画（Keyframe-Animation）" class="headerlink" title="3.1 关键帧动画（Keyframe Animation）"></a>3.1 关键帧动画（Keyframe Animation）</h2><ul>
<li>动画师 创建关键帧</li>
<li>人或计算机 创建中间的帧</li>
</ul>
<p><img src="/images/Games101/21/02.png"></p>
<p>关键帧动画一般使用插值方法来进行补帧，把每一帧当作参数值的向量，下面是线性插值。</p>
<p><img src="/images/Games101/21/03.png"></p>
<p>用样条进行优化：</p>
<p><img src="/images/Games101/21/04.png"></p>
<h2 id="3-2-物理仿真（Physical-Simulation）"><a href="#3-2-物理仿真（Physical-Simulation）" class="headerlink" title="3.2 物理仿真（Physical Simulation）"></a>3.2 物理仿真（Physical Simulation）</h2><h3 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h3><p>F &#x3D; ma</p>
<p>使用数值模拟生成物体的运动</p>
<p><img src="/images/Games101/21/05.png"></p>
<p>例子：</p>
<ul>
<li>布料模拟（ Cloth Simulation）</li>
<li>流体（ Fluids ）</li>
<li>质点弹簧系统（ Mass Spring System）</li>
<li>头发（ Hair ）</li>
<li>质点弹簧网格（Mass Spring Mesh）</li>
</ul>
<h3 id="3-2-2-质点弹簧系统（Mass-Spring-System）"><a href="#3-2-2-质点弹簧系统（Mass-Spring-System）" class="headerlink" title="3.2.2 质点弹簧系统（Mass Spring System）"></a>3.2.2 质点弹簧系统（Mass Spring System）</h3><ol>
<li><strong>简单的弹簧</strong></li>
</ol>
<p>理想化的弹簧：没有长度，作用力会导致位移。</p>
<p><strong>胡克定律：</strong></p>
<p><img src="/images/Games101/21/06.png"></p>
<ol start="2">
<li><strong>非0长度的弹簧</strong></li>
</ol>
<p><img src="/images/Games101/21/07.png"></p>
<p><strong>问题：永远震动下去。</strong></p>
<p><strong>定义概念：</strong></p>
<p><img src="/images/Games101/21/08.png"></p>
<p><strong>引入能量损失</strong></p>
<ul>
<li>表现得像运动中的粘性阻力</li>
<li>在速度方向上减慢运动</li>
<li>kd为阻尼系数</li>
</ul>
<p><img src="/images/Games101/21/09.png"></p>
<p><strong>问题：所有运动都会停止（不能表现弹簧内部的损耗）。</strong></p>
<p><strong>弹簧的内部阻尼（Internal Damping for Spring）</strong></p>
<p>只阻尼内部，由弹簧驱动的运动。</p>
<p><img src="/images/Games101/21/10.png"></p>
<p>Viscous drag 仅限于弹簧长度的变化，不会减慢弹簧系统的整体运动(例如，整体平移或旋转)</p>
<p>Note: 这只是一种特殊的阻尼(damping)。</p>
<ol start="3">
<li><strong>来自弹簧的结构</strong></li>
</ol>
<p><img src="/images/Games101/21/11.png"></p>
<p>弹簧结构的连接可以决定一个图形的行为，比如改进下面的连接来模拟布料。</p>
<p><img src="/images/Games101/21/12.png"></p>
<p>原来的不足之处：</p>
<ul>
<li>切变会影响形状。</li>
<li>会使原来的形状不在一个平面上。</li>
</ul>
<p>改进之后：</p>
<p><img src="/images/Games101/21/13.png"></p>
<ul>
<li><strong>在对角线连接弹簧会抵抗切变。</strong></li>
<li><strong>在两个对角线都连切线避免了各向异性。</strong></li>
<li><strong>红色的弹簧会避免 out-of-plane bending（两条对角线竖直方向会弯折）。</strong></li>
</ul>
<p>其他模型：<strong>有限元方法FEM（Finite Element Method）</strong></p>
<p>（代替弹簧系统的一种模拟布料的办法）</p>
<p>常用来做汽车碰撞，主要思想是<strong>力与力之间存在传导</strong>，效果如下。</p>
<p><img src="/images/Games101/21/14.png"></p>
<h3 id="3-2-3-粒子系统（Particle-System）"><a href="#3-2-3-粒子系统（Particle-System）" class="headerlink" title="3.2.3 粒子系统（Particle System）"></a>3.2.3 粒子系统（Particle System）</h3><ul>
<li>粒子系统就是将动态的系统建模为大量粒子的集合</li>
<li>每个粒子的运动都是由一组物理(或非物理)力定义的。</li>
<li>粒子系统是在图形和游戏上很流行的技术。</li>
<li>具备可扩展性：粒子越少，速度越快，粒子越多，速度越慢。</li>
</ul>
<p><strong>挑战</strong></p>
<ul>
<li>可能需要许多粒子(例如流体)</li>
<li>可能需要加速结构(例如寻找最近的粒子进行如引力的相互作用)</li>
</ul>
<p><strong>步骤</strong></p>
<ol>
<li>创建新的粒子（如果需要的话）。</li>
<li>计算每个粒子的力。</li>
<li>更新每个粒子的位置和速度。</li>
<li>移除死掉的粒子。</li>
<li>渲染粒子。</li>
</ol>
<p><strong>粒子系统的作用力</strong></p>
<ul>
<li>引力和斥力（repulsion） 如：万有引力、磁力、弹力（Springs）、弹簧、推进力（propulsion）。（eg：万有引力）</li>
<li>阻力（Damping forces）：摩擦（Friction），空气阻力（air drag），粘度 （viscosity）…</li>
<li>碰撞（Collisions）：墙壁、容器、固定的物体…。与动态物体、人物身体部位等…。</li>
</ul>
<p><strong>模拟动物集群（Simulated Flocking as an ODE）</strong></p>
<p>需要考虑一个例子的各种作用力</p>
<p><img src="/images/Games101/21/15.png"></p>
<h1 id="4-运动学-Kinematics"><a href="#4-运动学-Kinematics" class="headerlink" title="4 运动学 Kinematics"></a>4 运动学 Kinematics</h1><h2 id="4-1-正向运动学（Forward-Kinematics）"><a href="#4-1-正向运动学（Forward-Kinematics）" class="headerlink" title="4.1 正向运动学（Forward Kinematics）"></a>4.1 正向运动学（Forward Kinematics）</h2><p><strong>Articulated skeleton</strong></p>
<ul>
<li><strong>Topology 是一种拓扑结构（描述什么与什么连接）</strong></li>
<li><strong>关节（joints）间的几何关系。</strong></li>
<li><strong>树形结构</strong></li>
</ul>
<p><strong>Joint types（关节类型）</strong></p>
<ul>
<li><strong>Pin（1D rotation）：在平面内旋转</strong></li>
<li><strong>Ball（2D rotation）：可以旋转到不同的平面</strong></li>
<li><strong>Prismatic joint（translation）：可以拉长</strong></li>
</ul>
<p><img src="/images/Games101/21/16.png"></p>
<p>例子：2D中简单的两端骨骼。</p>
<p>Animator 提供角度，计算机决定 end-effector 的位置p。</p>
<p>Animation 是用角度参数与时间的函数来描述的。</p>
<p><img src="/images/Games101/21/17.png"></p>
<p><strong>优点：</strong></p>
<ul>
<li>直接控制方便</li>
<li>便于实施</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>动画可能难以用物理的方式来制作（不直观，艺术家不喜欢）</li>
<li>消耗动画师的时间</li>
</ul>
<h2 id="4-2-逆向运动学（Inverse-Kinematics）"><a href="#4-2-逆向运动学（Inverse-Kinematics）" class="headerlink" title="4.2 逆向运动学（Inverse Kinematics）"></a>4.2 逆向运动学（Inverse Kinematics）</h2><p><strong>概述：</strong></p>
<p>根据尖端获得关节的角度位置。</p>
<p>Animator 提供 end-effector 的位置，计算机决定满足限制的 joint 角度。</p>
<p>计算方法：</p>
<p><img src="/images/Games101/21/18.png"></p>
<p><strong>问题：</strong></p>
<ul>
<li>解不唯一</li>
<li>解可能不存在</li>
</ul>
<p><img src="/images/Games101/21/19.png"></p>
<p><strong>N-link lK 问题优化方法</strong></p>
<ul>
<li>选择一个初始构型。</li>
<li>定义一个 error metric（如：目标与当前位置之间距离的平方）。</li>
<li>计算误差梯度作为构形的函数</li>
<li>应用梯度下降(或牛顿法，或其他优化程序)</li>
</ul>
<h2 id="4-3-应用"><a href="#4-3-应用" class="headerlink" title="4.3 应用"></a>4.3 应用</h2><h3 id="4-3-1-Rigging-绑定"><a href="#4-3-1-Rigging-绑定" class="headerlink" title="4.3.1 Rigging 绑定"></a>4.3.1 Rigging 绑定</h3><p>Rigging 是一套高级角色控制，允许更快速和直观地修改姿势、变形、表情等。</p>
<ul>
<li>就像提线木偶的线一样。</li>
<li>捕捉所有有意义的角色变化。</li>
<li>因角色而异。</li>
<li>制作昂贵</li>
<li>具有人工误差并需要艺术和技术的训练。</li>
</ul>
<p><img src="/images/Games101/21/20.png"></p>
<h3 id="4-3-2-混合形状（Blend-Shapes）"><a href="#4-3-2-混合形状（Blend-Shapes）" class="headerlink" title="4.3.2 混合形状（Blend Shapes）"></a>4.3.2 混合形状（Blend Shapes）</h3><p>直接在曲面之间进行插值。</p>
<p><img src="/images/Games101/21/21.png"></p>
<p>最简单的方案：取顶点位置的线性组合，样条用于控制随着时间的推移权重的选择。</p>
<h3 id="4-3-3-动作捕捉（Motion-Capture）"><a href="#4-3-3-动作捕捉（Motion-Capture）" class="headerlink" title="4.3.3 动作捕捉（Motion Capture）"></a>4.3.3 动作捕捉（Motion Capture）</h3><p>Motion Capture 是创建动画序列的数据驱动方法。</p>
<p>下面是三种动捕设备（光学、磁力和机械）。</p>
<p><img src="/images/Games101/21/22.png"></p>
<p><strong>优点：</strong></p>
<ul>
<li>非常贴近真实</li>
<li>可以快速的过去大量的真实数据。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>准备工作复杂且高花费。</li>
<li>捕捉到的动画可能不满足艺术家的需要，需要选择。</li>
</ul>
<h2 id="5-动画-电影生产的-Pipeline"><a href="#5-动画-电影生产的-Pipeline" class="headerlink" title="5 动画&#x2F;电影生产的 Pipeline"></a>5 动画&#x2F;电影生产的 Pipeline</h2><p><img src="/images/Games101/21/23.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489/article/details/121895993?ops_request_misc=%7B%22request_id%22:%22170581620516800225512166%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=170581620516800225512166&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-14-121895993-null-null.nonecase&utm_term=%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0&spm=1018.2226.3001.4450">图形学笔记（十九）动画 —— 动画的历史、关键帧插值、物理仿真、质点弹簧系统、粒子系统、（反向IK）动力学、Rigging 绑定、Blend Shapes、动作捕捉_骨骼 逆运动学 动作捕捉 刚体模拟 流体模拟-CSDN博客</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/20/games101/Lec%2020/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/20/games101/Lec%2020/" class="post-title-link" itemprop="url">【Games 101】Lec 20：颜色和感知</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-20 16:41:43 / 修改时间：23:28:49" itemprop="dateCreated datePublished" datetime="2024-01-20T16:41:43+08:00">2024-01-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-20：Color-and-Perception"><a href="#Lecture-20：Color-and-Perception" class="headerlink" title="Lecture 20：Color and Perception"></a>Lecture 20：Color and Perception</h1><p>东西挺多的…</p>
<h1 id="1-光场（Light-Field-Lumigraph）"><a href="#1-光场（Light-Field-Lumigraph）" class="headerlink" title="1 光场（Light Field &#x2F; Lumigraph）"></a>1 光场（Light Field &#x2F; Lumigraph）</h1><h2 id="1-1-全光函数（The-Plenoptic-Function）"><a href="#1-1-全光函数（The-Plenoptic-Function）" class="headerlink" title="1.1 全光函数（The Plenoptic Function）"></a>1.1 全光函数（The Plenoptic Function）</h2><p><img src="/images/Games101/20/01.png"></p>
<p><strong>将整个世界看成是七个维度的函数：</strong></p>
<ul>
<li>θ,ϕ：角度</li>
<li>λ：光的波长信息（表示颜色信息）</li>
<li>t：时间</li>
<li>Vx，Vy，Vz：可以改变自己的位置从另外的角度看世界</li>
</ul>
<p>P( … ) 这个函数可以表示在任何地方，任何方向，任何时间看到的东西的颜色，这个函数就是<strong>全光函数</strong></p>
<p><img src="/images/Games101/20/02.png"></p>
<p><strong>光场就是全光函数的一部分。</strong></p>
<h2 id="1-2-光线-Ray"><a href="#1-2-光线-Ray" class="headerlink" title="1.2 光线 Ray"></a>1.2 光线 Ray</h2><p><strong>光线是一个5D表示的，包含 3D 的 position 和 2D 的 direction。</strong></p>
<p><img src="/images/Games101/20/03.png"></p>
<p><strong>另一种定义方式：两个点定义一条光线。</strong></p>
<p><strong>它是4D表示的，包含 2D 的 direction 和 2D 的 position。</strong></p>
<p><img src="/images/Games101/20/04.png"></p>
<h2 id="1-3-光场"><a href="#1-3-光场" class="headerlink" title="1.3 光场"></a>1.3 光场</h2><h3 id="1-3-1-定义"><a href="#1-3-1-定义" class="headerlink" title="1.3.1 定义"></a>1.3.1 定义</h3><p>想要描述一个物体的视觉信息，只要找出它的包围盒，并记录包围盒表面任意一点向任意方向的发光情况即可。</p>
<p><strong>光场就是在任何一个位置往任何一个方向去的光照强度。</strong></p>
<p><img src="/images/Games101/20/05.png"></p>
<h3 id="1-3-2-光场的作用"><a href="#1-3-2-光场的作用" class="headerlink" title="1.3.2 光场的作用"></a>1.3.2 光场的作用</h3><p>有了光场后，从任意位置都可以看向这个物体，有了<strong>视点</strong>和<strong>看向的方向</strong>，查询4D的函数就可以查询到记录的值（光的强度）。</p>
<p><img src="/images/Games101/20/06.png"></p>
<p>有了包围盒之后，就可以<strong>忽略光场内部的细节</strong>，<strong>只要记录包围盒表面的任何位置任何方向的光照信息即可</strong>。</p>
<p><img src="/images/Games101/20/07.png"></p>
<h3 id="1-3-3-光场的表示方式"><a href="#1-3-3-光场的表示方式" class="headerlink" title="1.3.3 光场的表示方式"></a>1.3.3 光场的表示方式</h3><ul>
<li><p>起始点 + 一个角度</p>
</li>
<li><p><img src="/images/Games101/20/08.png"></p>
</li>
<li><p>两个相互平行的平面，两个点确定一条光线</p>
</li>
<li><p><img src="/images/Games101/20/09.png"></p>
</li>
<li><p>参数化的表示两个平面（s t）（u v），找到所有 uv 和 st 的对应关系，便可以定义任意一条光线。</p>
</li>
</ul>
<p>下面看一下解释，假设整个世界在 st 面的右边：</p>
<ul>
<li><strong>固定 uv 平面点x，从这个点看向 st 面的不同的点yi，然后所有yi的集合相当于就是一张图像（改变x，相当于就是从不同的角度去看这个物体）</strong></li>
</ul>
<p><img src="/images/Games101/20/10.png"></p>
<ul>
<li><strong>固定 st 平面上的点x，从 uv 面的不同的点 yi 看向x，那么所有的yi的集合就是这个物体的一个方向的结果（改变x，得到的就是这个物体的不同方向上的结果）</strong></li>
</ul>
<p><img src="/images/Games101/20/11.png"></p>
<h3 id="1-3-4-光场摄像机（Light-Field-Camera）"><a href="#1-3-4-光场摄像机（Light-Field-Camera）" class="headerlink" title="1.3.4 光场摄像机（Light Field Camera）"></a>1.3.4 光场摄像机（Light Field Camera）</h3><p><strong>原理：</strong>本来是光都打在一个像素上的，但是现在把像素的位置往后移一下，原来的位置放成一个微透镜，让透镜把来自于不同方向的光分开然后记录下来，然后对于特定方向上的光线重新聚焦。</p>
<p><img src="/images/Games101/20/12.png"></p>
<p><img src="/images/Games101/20/13.png"></p>
<p>还原普通照片的方法：对于每个透镜都选择每一“块”的最底部的像素。</p>
<p>有了光场之后，可以虚拟移动相机的位置（重新聚焦也是一样的道理）。</p>
<p><img src="/images/Games101/20/14.png"></p>
<p><strong>总结</strong>：光场相机能实现虚拟移动相机位置，改变聚焦等功能。</p>
<p><strong>光场相机特点</strong>：光场摄像机记录了所有的光场信息。</p>
<p><strong>光场相机的问题</strong></p>
<ul>
<li>光场相机的空间上的分辨率不足。</li>
<li>高成本（胶片分辨率十分高，微透镜很精密）。</li>
</ul>
<h1 id="2-颜色"><a href="#2-颜色" class="headerlink" title="2 颜色"></a>2 颜色</h1><p><strong>颜色是人的感知的结果</strong>，他不是光的自然属性。不同波长的光不是“颜色”。</p>
<h2 id="2-1-颜色的物理学基础"><a href="#2-1-颜色的物理学基础" class="headerlink" title="2.1 颜色的物理学基础"></a>2.1 颜色的物理学基础</h2><h3 id="2-1-1-可见的光的波段"><a href="#2-1-1-可见的光的波段" class="headerlink" title="2.1.1 可见的光的波段"></a>2.1.1 可见的光的波段</h3><p><img src="/images/Games101/20/15.png"></p>
<h3 id="2-1-2-谱功率密度-Spectral-Power-Distribution-SPD"><a href="#2-1-2-谱功率密度-Spectral-Power-Distribution-SPD" class="headerlink" title="2.1.2 谱功率密度 Spectral Power Distribution(SPD)"></a>2.1.2 谱功率密度 Spectral Power Distribution(SPD)</h3><p>SPD 是光线不同波长的光强分布是多少，如下图所示蓝天能量集中在波长低的部分，日光波长越高能量越大。</p>
<p><img src="/images/Games101/20/16.png"></p>
<p><strong>SPD 具有线性性质，即可以叠加。</strong></p>
<h2 id="2-2-颜色的生物学基础"><a href="#2-2-颜色的生物学基础" class="headerlink" title="2.2 颜色的生物学基础"></a>2.2 颜色的生物学基础</h2><p>人的眼睛是摄像机，瞳孔是光圈，晶状体是透镜（通过肌肉伸缩来控制焦距），视网膜是传感器。</p>
<p><img src="/images/Games101/20/17.png"></p>
<h3 id="2-2-1-感光细胞：Rods-and-Cones"><a href="#2-2-1-感光细胞：Rods-and-Cones" class="headerlink" title="2.2.1 感光细胞：Rods and Cones"></a>2.2.1 感光细胞：Rods and Cones</h3><p>视网膜具有感光细胞（Retinel Photoreceptor Cells）：<strong>棒状和锥形细胞（Rods and Cones ）</strong></p>
<p><strong>Rods（棒状细胞）：感知光的强度，可以得到灰度图。~120 million</strong></p>
<p><strong>Cones（锥形细胞）：感知光的颜色。~6-7 million</strong></p>
<p>由于三种类型的细胞对于波长的感光程度不同，<strong>Cones可以进一步划分为三类：S-Cone，M-Cone，L-Cone。</strong></p>
<p><img src="/images/Games101/20/18.png"></p>
<h3 id="2-2-2-Tristimulus-Theory-of-Color"><a href="#2-2-2-Tristimulus-Theory-of-Color" class="headerlink" title="2.2.2 Tristimulus Theory of Color"></a>2.2.2 Tristimulus Theory of Color</h3><p>以下是人类锥形细胞的相应曲线，SML是人类最终看到的结果（只是一个数，不是光谱而是积分的结果）。</p>
<p><img src="/images/Games101/20/19.png"></p>
<p>每一个光的波长信息不能被人眼测量和大脑接收。</p>
<p>眼睛值看到了三个 response values（S,M,L），并且是大脑唯一可获取的信息。</p>
<p><img src="/images/Games101/20/20.png"></p>
<h3 id="2-2-3-同色异谱（Metamerism）"><a href="#2-2-3-同色异谱（Metamerism）" class="headerlink" title="2.2.3 同色异谱（Metamerism）"></a>2.2.3 同色异谱（Metamerism）</h3><p>Metamerism 是不同的光谱 spectra（ ∞ − dim）会映射到相同（S,M,L）的响应。</p>
<ul>
<li>这些似乎会对一个人产生相同的颜色（光谱不一定相同，但颜色可以相同）。</li>
</ul>
<p>Metamerism 对颜色reproduction很重要。</p>
<ul>
<li>不需要重构出真实世界的整个光谱。</li>
<li>例如metamer可以在显示器仅使用每个像素的三个颜色便可重现真实场景感知到的光。</li>
</ul>
<p><img src="/images/Games101/20/21.png"></p>
<h2 id="2-3-颜色匹配（Color-Reproduction-Matching）"><a href="#2-3-颜色匹配（Color-Reproduction-Matching）" class="headerlink" title="2.3 颜色匹配（Color Reproduction &#x2F; Matching）"></a>2.3 颜色匹配（Color Reproduction &#x2F; Matching）</h2><p><strong>加色系统 Additive Color</strong></p>
<ul>
<li>给定一组主要的光，每个光都有自己的光谱分布（例如使用RGB显示像素）。</li>
<li>调整这些光的亮度并把它们加在一起。</li>
<li>颜色最后被标量（R,G,B）描述。</li>
</ul>
<p><img src="/images/Games101/20/22.png"></p>
<p>（可以进行减色）</p>
<p><strong>CIE RGB Color Matching</strong></p>
<p>下图图显示每个CIE RGB主要（primary）光匹配x轴上给定波长的单色光需要混合的量。（注意有负的结果）。</p>
<p>对于任何一个光谱s，感知到的光被下面的公式匹配（缩放CIE RGB原色）。</p>
<p><img src="/images/Games101/20/23.png"></p>
<h2 id="2-4-颜色空间（Color-Spaces）"><a href="#2-4-颜色空间（Color-Spaces）" class="headerlink" title="2.4 颜色空间（Color Spaces）"></a>2.4 颜色空间（Color Spaces）</h2><h3 id="2-4-1-Standard-Color-Spaces（标准颜色空间）"><a href="#2-4-1-Standard-Color-Spaces（标准颜色空间）" class="headerlink" title="2.4.1 Standard Color Spaces（标准颜色空间）"></a>2.4.1 Standard Color Spaces（标准颜色空间）</h3><ul>
<li>先让特定的机器做好之后，让其他机器模仿这种RGB标准。</li>
<li>现在被广泛采用。</li>
<li>色域gamut是有限的。</li>
</ul>
<h3 id="2-4-2-色域（Gamut）"><a href="#2-4-2-色域（Gamut）" class="headerlink" title="2.4.2 色域（Gamut）"></a>2.4.2 色域（Gamut）</h3><p>Gamut 是被一个原色集生成的所有色度（chromaticities）。</p>
<p>不同的颜色空间表示不同范围的颜色，具有不同的色域（gamut），即它们覆盖charomaticities的不同区域。</p>
<p><img src="/images/Games101/20/24.png"></p>
<h3 id="2-4-3-常见的颜色空间"><a href="#2-4-3-常见的颜色空间" class="headerlink" title="2.4.3 常见的颜色空间"></a>2.4.3 常见的颜色空间</h3><ol>
<li><h5 id="科学上普遍的颜色空间：CIE-XYZ"><a href="#科学上普遍的颜色空间：CIE-XYZ" class="headerlink" title="科学上普遍的颜色空间：CIE XYZ"></a>科学上普遍的颜色空间：CIE XYZ</h5></li>
</ol>
<p>CIE是人造的颜色匹配系统。</p>
<p>首先设定标准颜色原色组X,Y,Z。</p>
<ul>
<li>不存在具有这些匹配函数的原色。</li>
<li>Y是luminace亮度（亮度与颜色无关）</li>
</ul>
<p>这个系统设计成匹配函数严格为正，覆盖所有可见光的范围。</p>
<p><img src="/images/Games101/20/25.png"></p>
<ol start="2">
<li><h5 id="HSV-Color-Space-Hue-Saturation-Value"><a href="#HSV-Color-Space-Hue-Saturation-Value" class="headerlink" title="HSV Color Space(Hue-Saturation-Value)"></a>HSV Color Space(Hue-Saturation-Value)</h5></li>
</ol>
<p>HSV 常见于颜色拾取器中（PS中常见）。</p>
<ul>
<li><strong>Hue：不同类型的颜色。</strong></li>
<li><strong>Saturation：更接近白色还是纯色（单一颜色）。</strong></li>
<li><strong>Brightness：从黑色到某种颜色。</strong></li>
</ul>
<p><img src="/images/Games101/20/26.png"></p>
<ol start="3">
<li><strong>CIELAB Space(AKA L<em>a</em>b*)</strong></li>
</ol>
<p>CIELAB Space是与感知有关的色彩空间。</p>
<ul>
<li>L* 是 Lightness（brightness）</li>
<li>a 和 b 是互补颜色对（a<em>是red-green，b</em>是blue-yellow）。</li>
</ul>
<p><img src="/images/Games101/20/27.png"></p>
<ol start="4">
<li><strong>CMYK：A Subtractive（减色） Color Space</strong></li>
</ol>
<p>Subtractive color model：混合的越多就越暗。</p>
<p>青色Cyan、洋红Magenta、黄色Yellow和黑色，并（Key Widely）广泛用于打印。</p>
<p><img src="/images/Games101/20/28.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/20/games101/Lec%2019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/20/games101/Lec%2019/" class="post-title-link" itemprop="url">【Games 101】Lec 19：照相机、镜头、光场</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-20 16:39:46 / 修改时间：19:06:55" itemprop="dateCreated datePublished" datetime="2024-01-20T16:39:46+08:00">2024-01-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-19：Cameras-Lenses-and-Light-Fields"><a href="#Lecture-19：Cameras-Lenses-and-Light-Fields" class="headerlink" title="Lecture 19：Cameras, Lenses and Light Fields"></a>Lecture 19：Cameras, Lenses and Light Fields</h1><h1 id="1-视场（Field-of-View（FOV））"><a href="#1-视场（Field-of-View（FOV））" class="headerlink" title="1. 视场（Field of View（FOV））"></a>1. 视场（Field of View（FOV））</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><strong>FOV：看到的角度</strong></p>
<p><strong>h：高度</strong></p>
<p><strong>f：焦距</strong></p>
<p><img src="/images/Games101/19/01.png"></p>
<h2 id="1-2-焦距（Focal-length）对视场（FOV）的影响"><a href="#1-2-焦距（Focal-length）对视场（FOV）的影响" class="headerlink" title="1.2 焦距（Focal length）对视场（FOV）的影响"></a>1.2 焦距（Focal length）对视场（FOV）的影响</h2><p><strong>当传感器大小一定时，FOV 随着焦距增加而减少。</strong></p>
<p><img src="/images/Games101/19/02.png"></p>
<h2 id="1-3-传感器（Sensor）大小对视场的影响"><a href="#1-3-传感器（Sensor）大小对视场的影响" class="headerlink" title="1.3 传感器（Sensor）大小对视场的影响"></a>1.3 传感器（Sensor）大小对视场的影响</h2><p>通常，<strong>相机（传感器）越大，镜头（焦距）越长越好。</strong></p>
<p><img src="/images/Games101/19/03.png"></p>
<h1 id="2-曝光-Exposure"><a href="#2-曝光-Exposure" class="headerlink" title="2. 曝光 Exposure"></a>2. 曝光 Exposure</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul>
<li><strong>H&#x3D;T×E</strong></li>
<li><strong>Exposure &#x3D; Time × Irradiance</strong></li>
<li><strong>T（曝光时间）由快门（shuttle）控制</strong></li>
<li><strong>E（Irradiance）由传感器上一个单位区域接收光的能量和镜头的光圈（aperture）和焦距控制。</strong></li>
</ul>
<p><img src="/images/Games101/19/04.png"></p>
<h2 id="2-2-曝光的影响因素"><a href="#2-2-曝光的影响因素" class="headerlink" title="2.2 曝光的影响因素"></a>2.2 曝光的影响因素</h2><ul>
<li><strong>Aperture size（光圈的大小）：通过打开和关闭 apeture 改变 f-stop。</strong></li>
<li><strong>Shuttle speed（快门开放的时间）：改变sensors的曝光时间即每个像素接收光的时间，快门越快曝光越少</strong></li>
<li><strong>ISO （Gain 感光度）：更改传感器值和数字图像值之间的倍率（模拟和&#x2F;或数字）。</strong></li>
</ul>
<p><img src="/images/Games101/19/05.png"></p>
<h2 id="2-3-感光度-ISO（Gain）"><a href="#2-3-感光度-ISO（Gain）" class="headerlink" title="2.3 感光度 ISO（Gain）"></a>2.3 感光度 ISO（Gain）</h2><p><strong>ISO</strong> 是 exposure 的第三个变量，<strong>简单放大ISO信号的同时会方法噪声</strong>。</p>
<p><strong>Film</strong>：权衡对（grain）的敏感度。</p>
<p><strong>Digital</strong>：权衡对噪声的敏感度。</p>
<ul>
<li>在模拟到数字的转换前乘以信号。</li>
<li>线性作用（ISO 200需要的光是ISO 100的一半）</li>
</ul>
<h2 id="2-4-F-Number-F-Stop-：Exposure-Levels"><a href="#2-4-F-Number-F-Stop-：Exposure-Levels" class="headerlink" title="2.4 F-Number(F-Stop)：Exposure Levels"></a>2.4 F-Number(F-Stop)：Exposure Levels</h2><ul>
<li>用于描述光圈的</li>
</ul>
<p>写作 FN或F&#x2F;N，N就是f-number。<br>简单理解为光圈的直径的倒数。</p>
<p><strong>正式定义</strong>：<strong>镜头的 f-number 是 焦距 除以 光圈的直径。</strong></p>
<p><img src="/images/Games101/19/06.png"></p>
<h2 id="2-5-快门-Physical-Shutter"><a href="#2-5-快门-Physical-Shutter" class="headerlink" title="2.5 快门 Physical Shutter"></a>2.5 快门 Physical Shutter</h2><p>快门可以用于调节曝光度。</p>
<p><strong>运动模糊（Motion blur）</strong>：由于快门打开有时间会拍摄到一段运动。</p>
<p>两倍的快门时间意味着两倍的运动模糊。</p>
<p>运动模糊不一定是坏事，从人的感知角度它可以<strong>形容速度快</strong>从采样角度，它也可以进行<strong>反走样</strong>。</p>
<p><img src="/images/Games101/19/07.png"></p>
<p><strong>Rolling shutter</strong>：图像上的不同位置可能会记录不同时间进入的光（会造成扭曲）。</p>
<h2 id="2-6-F-Stop-vs-Shutter-Speed"><a href="#2-6-F-Stop-vs-Shutter-Speed" class="headerlink" title="2.6 F-Stop vs Shutter Speed"></a>2.6 F-Stop vs Shutter Speed</h2><p>两者可以组合，调节曝光度；</p>
<p><img src="/images/Games101/19/08.png"></p>
<p>Photographers 需要权衡景深和运动物体的运动模糊。</p>
<h2 id="2-7-高速摄影和延时摄影（Fast-and-Slow-Photography）"><a href="#2-7-高速摄影和延时摄影（Fast-and-Slow-Photography）" class="headerlink" title="2.7 高速摄影和延时摄影（Fast and Slow Photography）"></a>2.7 高速摄影和延时摄影（Fast and Slow Photography）</h2><p><strong>High-Speed Photography</strong>：每秒拍更多的照片，也导致快门时间很少（短曝光时间，得用更大的光圈）。</p>
<p><img src="/images/Games101/19/09.png"></p>
<p><strong>Long-Exposure Photography</strong>：长曝光时间，小光圈。</p>
<p><img src="/images/Games101/19/10.png"></p>
<h1 id="3-薄透镜近似-Thin-Lens-Approximation"><a href="#3-薄透镜近似-Thin-Lens-Approximation" class="headerlink" title="3. 薄透镜近似 Thin Lens Approximation"></a>3. 薄透镜近似 Thin Lens Approximation</h1><p>真正的透镜非常复杂，需要一个简单的方法描述。</p>
<h2 id="3-1-理想化薄透镜（Ideal-Thin-Lens-Focal-Point）"><a href="#3-1-理想化薄透镜（Ideal-Thin-Lens-Focal-Point）" class="headerlink" title="3.1 理想化薄透镜（Ideal Thin Lens - Focal Point）"></a>3.1 理想化薄透镜（Ideal Thin Lens - Focal Point）</h2><ul>
<li><strong>所有进入透镜的平行光一定过焦点。</strong></li>
<li><strong>过交点的在透镜后面一定是平行光。</strong></li>
<li><strong>认为焦距可以被随意改变（透镜组）。</strong></li>
</ul>
<p><img src="/images/Games101/19/11.png"></p>
<h2 id="3-2-薄透镜公式（The-Thin-Lens-Equation）"><a href="#3-2-薄透镜公式（The-Thin-Lens-Equation）" class="headerlink" title="3.2 薄透镜公式（The Thin Lens Equation）"></a>3.2 薄透镜公式（The Thin Lens Equation）</h2><ul>
<li><strong>公式：（物距，像距，焦距 三者的关系）</strong></li>
</ul>
<p><img src="/images/Games101/19/12.png"></p>
<ul>
<li><strong>公式推导：</strong></li>
</ul>
<p><img src="/images/Games101/19/13.png"></p>
<h2 id="3-3-Defocus-Blur"><a href="#3-3-Defocus-Blur" class="headerlink" title="3.3 Defocus Blur"></a>3.3 Defocus Blur</h2><h3 id="3-3-1-Computing-Cicle-of-Confusion-CoC-Size"><a href="#3-3-1-Computing-Cicle-of-Confusion-CoC-Size" class="headerlink" title="3.3.1 Computing Cicle of Confusion(CoC) Size"></a>3.3.1 Computing Cicle of Confusion(CoC) Size</h3><p>如图，Object远离Focal Plane，聚焦后的点不在Sensor Plane上，而是在它前面聚焦，然后光线在聚焦点继续直线传播，到Sensor Plane上就变成了一个圆。（产生了模糊）</p>
<p><img src="/images/Games101/19/14.png"></p>
<p>其中：<strong>A是光圈直径，C是CoC的直径。</strong></p>
<p>Circle of Confusion 与光圈大小成正比。所以看到的东西<strong>是否模糊与光圈的大小有关</strong>。</p>
<p>将上面的公式与F-Number联系起来。</p>
<p><img src="/images/Games101/19/15.png"></p>
<h3 id="3-3-2-Ray-Tracing-Ideal-Thin-Lenses"><a href="#3-3-2-Ray-Tracing-Ideal-Thin-Lenses" class="headerlink" title="3.3.2 Ray Tracing Ideal Thin Lenses"></a>3.3.2 Ray Tracing Ideal Thin Lenses</h3><p><img src="/images/Games101/19/16.png"></p>
<p><strong>步骤：</strong></p>
<ul>
<li>先定义Sensor的大小（成像平面大小），然后定义透镜的属性，即焦距和光圈的大小。</li>
<li>定义透镜和关注平面的距离 zo（物距）。</li>
<li>根据透镜方程计算相应的深度 zi（相距）。</li>
</ul>
<p><strong>渲染：</strong></p>
<ul>
<li>对于每个在sensor上的像素 x′</li>
<li>在 lens plane上取样随机一点 x′′</li>
<li>然后知道了通过透镜的光线会打到 x′′′</li>
<li>计算光线 x′′ → x′′′ 的radiance。</li>
</ul>
<h3 id="3-3-3-景深（Depth-of-Field）"><a href="#3-3-3-景深（Depth-of-Field）" class="headerlink" title="3.3.3 景深（Depth of Field）"></a>3.3.3 景深（Depth of Field）</h3><p><strong>景深：</strong>就是指 <strong>成像清晰的一段范围</strong></p>
<p>或者说：<strong>在场景内对应的CoC足够小的距离范围。</strong></p>
<p><img src="/images/Games101/19/17.png"></p>
<p><strong>推导：</strong></p>
<p><img src="/images/Games101/19/18.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489/article/details/121771735?ops_request_misc=%7B%22request_id%22:%22170567531416800227439114%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=170567531416800227439114&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-10-121771735-null-null.nonecase&utm_term=%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0&spm=1018.2226.3001.4450">图形学笔记（十七）相机，棱镜 ——FOV、焦距、曝光、F-Stop、ISO、薄透镜公式、Circle of Confusion Size、景深、理想薄透镜光线追踪_相机凌镜成像-CSDN博客</a></p>
<p>光场放在了下一篇。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/20/games101/Lec%2018/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/20/games101/Lec%2018/" class="post-title-link" itemprop="url">【Games 101】Lec 18：渲染的前沿话题</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-20 14:36:50" itemprop="dateCreated datePublished" datetime="2024-01-20T14:36:50+08:00">2024-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-21 20:57:35" itemprop="dateModified" datetime="2024-01-21T20:57:35+08:00">2024-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-18：Advanced-Topics-in-Rendering"><a href="#Lecture-18：Advanced-Topics-in-Rendering" class="headerlink" title="Lecture 18：Advanced Topics in Rendering"></a>Lecture 18：Advanced Topics in Rendering</h1><p>东西很多，当作扩展听一听就行。</p>
<h1 id="1-高级光线传播"><a href="#1-高级光线传播" class="headerlink" title="1. 高级光线传播"></a>1. 高级光线传播</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><img src="/images/Games101/18/01.png"></p>
<ul>
<li>无偏光线传播<ul>
<li>双向路径追踪</li>
<li>Metropolis light transport  (MLT)</li>
</ul>
</li>
<li>有偏光线追踪<ul>
<li>光子映射</li>
<li>Vertex connection and merging (VCM)</li>
</ul>
</li>
<li>试试辐射度算法</li>
</ul>
<h2 id="1-2-有偏（Biased）与无偏（Unbiased）的-Monte-Carlo-估计"><a href="#1-2-有偏（Biased）与无偏（Unbiased）的-Monte-Carlo-估计" class="headerlink" title="1.2  有偏（Biased）与无偏（Unbiased）的 Monte Carlo 估计"></a>1.2  有偏（Biased）与无偏（Unbiased）的 Monte Carlo 估计</h2><ul>
<li><strong>无偏</strong><ul>
<li>无偏的 Monte Carlo方法没有任何系统误差。即无论使用多少样本，无偏估计的期望值总是正确的。</li>
</ul>
</li>
<li><strong>有偏</strong><ul>
<li>有系统误差存在就是有偏估计。</li>
<li>有偏估计的<strong>一致性（consistent）</strong>：当取样无穷大时没有系统误差（会收敛）</li>
</ul>
</li>
</ul>
<p>在图形学中</p>
<ul>
<li><strong>Biased（有偏） &#x3D;&#x3D; blurry（模糊）</strong></li>
<li><strong>Consistent（有偏一致性） &#x3D;&#x3D; 当取样点无穷时不模糊</strong></li>
</ul>
<h2 id="1-3-双向路径追踪-Bidirectional-Path-Tracing（BDPT）"><a href="#1-3-双向路径追踪-Bidirectional-Path-Tracing（BDPT）" class="headerlink" title="1.3 双向路径追踪 Bidirectional Path Tracing（BDPT）"></a>1.3 双向路径追踪 Bidirectional Path Tracing（BDPT）</h2><h3 id="1-3-1-概述"><a href="#1-3-1-概述" class="headerlink" title="1.3.1 概述"></a>1.3.1 概述</h3><ul>
<li><strong>无偏的</strong> 光线传播方法。</li>
</ul>
<p>（路径追踪是从相机到光源使用一条路径连接起来。）</p>
<h3 id="1-3-2-BDPT-思想"><a href="#1-3-2-BDPT-思想" class="headerlink" title="1.3.2 BDPT 思想"></a>1.3.2 BDPT 思想</h3><ul>
<li>分别从相机和光源追踪sub-paths</li>
<li>从两个 sub-path 连接端点（各追踪一部分然后汇聚）</li>
</ul>
<p><img src="/images/Games101/18/02.png"></p>
<h3 id="1-3-3-BDPT-特点"><a href="#1-3-3-BDPT-特点" class="headerlink" title="1.3.3 BDPT 特点"></a>1.3.3 BDPT 特点</h3><ul>
<li>适合光线传播在光源这一边比较好算的情况。</li>
<li>难以实现且非常慢</li>
</ul>
<p><img src="/images/Games101/18/03.png"></p>
<h2 id="1-4-Metropolis-Light-Transport-（MLT）"><a href="#1-4-Metropolis-Light-Transport-（MLT）" class="headerlink" title="1.4 Metropolis Light Transport （MLT）"></a>1.4 Metropolis Light Transport （MLT）</h2><h3 id="1-4-1-概述"><a href="#1-4-1-概述" class="headerlink" title="1.4.1 概述"></a>1.4.1 概述</h3><ul>
<li>无偏估计</li>
<li>用马尔可夫链来进行采样</li>
</ul>
<h3 id="1-4-2-马尔可夫链-Markov-Chain-Monte-Carlo（MCMC）-application"><a href="#1-4-2-马尔可夫链-Markov-Chain-Monte-Carlo（MCMC）-application" class="headerlink" title="1.4.2 马尔可夫链 Markov Chain Monte Carlo（MCMC） application"></a>1.4.2 马尔可夫链 Markov Chain Monte Carlo（MCMC） application</h3><p>根据当前的样本可以生成与其靠近的下一个样本，他可以生成以任意形状函数为PDF的样本。</p>
<p><strong>关键思想</strong>：局部扰动一个现存路径来获得一个新路径。</p>
<p><img src="/images/Games101/18/04.png"></p>
<h3 id="1-4-3-特点"><a href="#1-4-3-特点" class="headerlink" title="1.4.3 特点"></a>1.4.3 特点</h3><p><strong>优点：</strong></p>
<ul>
<li>比较适合做困难的光线传播（只要找到一条路径做为种子就可以找到更多路径）</li>
<li>无偏</li>
</ul>
<p><img src="/images/Games101/18/05.png"></p>
<p><strong>缺点：</strong></p>
<ul>
<li>难以估计收敛速度</li>
<li>不能保证每个像素的收敛速度都相等（比较局部）</li>
<li>所以图片看起来比较脏</li>
<li>不能渲染动画</li>
</ul>
<h2 id="1-5-光子映射（Photon-Mapping）"><a href="#1-5-光子映射（Photon-Mapping）" class="headerlink" title="1.5 光子映射（Photon Mapping）"></a>1.5 光子映射（Photon Mapping）</h2><h3 id="1-5-1-概述"><a href="#1-5-1-概述" class="headerlink" title="1.5.1 概述"></a>1.5.1 概述</h3><ul>
<li>caustics（聚焦）：由于光线聚焦产生的一些列图案。</li>
<li>Specular-Diffuse-Specular（SDS）：光线先通过镜面反射，然后再进行漫反射，然后再进行镜面反射。</li>
<li>有偏的</li>
<li>擅长处理 Specular-Diffuse-Specular（SDS）paths 和生成 caustics。</li>
</ul>
<p><img src="/images/Games101/18/06.png"></p>
<h3 id="1-5-2-方法"><a href="#1-5-2-方法" class="headerlink" title="1.5.2 方法"></a>1.5.2 方法</h3><ol>
<li><strong>光子追踪</strong></li>
</ol>
<p>从光源发射光子，让它们在四周弹射，直到光子打到diffuse的物体上，把光子记录下来。</p>
<ol start="2">
<li><strong>光子收集</strong></li>
</ol>
<p>从眼睛和摄像机开始，射出 sub-paths，让它们在周围跳跃，直到它们打到漫反射的物体上。</p>
<p><img src="/images/Games101/18/07.png"></p>
<ol start="3">
<li><strong>计算局部密度估计</strong></li>
</ol>
<p>当第二趟打到 diffuse 物体表面时，就要做一个局部的密度估计。</p>
<p><strong>思想</strong>：光子分布越集中越亮。</p>
<p><strong>做法</strong>：对于每个着色点，找到最近的N个光子。计算它们占据的面积。然后就可以计算光子的密度。</p>
<p><img src="/images/Games101/18/08.png"></p>
<h3 id="1-5-3-分析"><a href="#1-5-3-分析" class="headerlink" title="1.5.3 分析"></a>1.5.3 分析</h3><ul>
<li><p>为什么<strong>有偏</strong>？</p>
<ul>
<li>密度的估计不准确，只有 dA 足够小才接近正确。</li>
</ul>
</li>
<li><p><strong>解决</strong></p>
<ul>
<li>更多的光子辐射出去 → 相同的N个光子则会覆盖更小的区域 ΔA  → ΔA 会更加接近 dA。所以它是biased，但是 consistent 的。</li>
</ul>
</li>
</ul>
<p><img src="/images/Games101/18/09.png"></p>
<h2 id="1-6-顶点连接和合并-Vertex-Connection-and-Merging（VCM）"><a href="#1-6-顶点连接和合并-Vertex-Connection-and-Merging（VCM）" class="headerlink" title="1.6 顶点连接和合并 Vertex Connection and Merging（VCM）"></a>1.6 顶点连接和合并 Vertex Connection and Merging（VCM）</h2><h3 id="1-6-1-概述"><a href="#1-6-1-概述" class="headerlink" title="1.6.1 概述"></a>1.6.1 概述</h3><p>结合了 <strong>双向路径追踪</strong> 和 <strong>光子映射</strong></p>
<h3 id="1-6-2-思想"><a href="#1-6-2-思想" class="headerlink" title="1.6.2 思想"></a>1.6.2 思想</h3><ul>
<li>如果端点不能被连接而是可以被融合就不浪费 BDPT 中的 sub-paths了。</li>
<li>使用 photon mapping 来处理 “photons” 附近的融合。</li>
</ul>
<p><img src="/images/Games101/18/10.png"></p>
<h2 id="1-7-实时辐射度算法-Instant-Radiosity-IR"><a href="#1-7-实时辐射度算法-Instant-Radiosity-IR" class="headerlink" title="1.7 实时辐射度算法 Instant Radiosity (IR)"></a>1.7 实时辐射度算法 Instant Radiosity (IR)</h2><ul>
<li>也称为 <strong>many-light</strong> 方法</li>
<li><strong>思想</strong>：已经被照亮的表面可以被当作光源。</li>
<li><strong>方法：</strong><ul>
<li>从光源打出 sub-paths 并把每一个 sub-path 的端点当作 Virtual Point Light（VPL）</li>
<li>使用这些 VPLs 渲染场景</li>
</ul>
</li>
</ul>
<p><img src="/images/Games101/18/11.png"></p>
<ul>
<li><strong>优点：</strong>快速并且通常对漫反射场景的结果比较好。</li>
<li><strong>缺点：</strong><ul>
<li>当 VPLs 非常接近着色点的时候，Spikes 将会融合（如下右图有过亮的点）。</li>
<li>不能处理glossy的材质。</li>
</ul>
</li>
</ul>
<p><img src="/images/Games101/18/12.png"></p>
<h1 id="2-高级外观建模"><a href="#2-高级外观建模" class="headerlink" title="2. 高级外观建模"></a>2. 高级外观建模</h1><h2 id="2-1-非表面材质"><a href="#2-1-非表面材质" class="headerlink" title="2.1 非表面材质"></a>2.1 非表面材质</h2><h3 id="2-1-1-散射介质（Participating-Media）"><a href="#2-1-1-散射介质（Participating-Media）" class="headerlink" title="2.1.1 散射介质（Participating Media）"></a>2.1.1 散射介质（Participating Media）</h3><p>当光通过散射介质时，任何一点可以(部分)吸收和散射。</p>
<p>使用<strong>相位函数</strong>（Phase Function）来描述参与介质中任意点的光散射角分布。</p>
<p><img src="/images/Games101/18/13.png"></p>
<p><strong>散射介质的渲染过程</strong></p>
<ul>
<li>随机选择一个方向来弹射。</li>
<li>随机选择一个距离直行。</li>
<li>对于每一个“着色点”，把它连接到光源。</li>
</ul>
<p><img src="/images/Games101/18/14.png"></p>
<h3 id="2-1-2-Hair-Appearance"><a href="#2-1-2-Hair-Appearance" class="headerlink" title="2.1.2 Hair Appearance"></a>2.1.2 Hair Appearance</h3><ol>
<li><strong>Kajiya-Kay Model</strong></li>
</ol>
<p>头发会散射成一个圆锥。像是diffuse+specular。</p>
<p><img src="/images/Games101/18/15.png"></p>
<ol start="2">
<li><strong>Marschner Model</strong></li>
</ol>
<p>除了考虑被散射的光线还要考虑穿过头发的光线。Marschner Model 考虑了以下三证类型的光线。<br><strong>R：直接反射的光。</strong><br><strong>TT：穿进去再传出去的光。</strong><br><strong>TRT：光线进到头发里面，在头发的内壁发生一次反射再回去。</strong></p>
<p><img src="/images/Games101/18/16.png"></p>
<p><img src="/images/Games101/18/17.png"></p>
<h3 id="2-1-3-Fur-Appearance"><a href="#2-1-3-Fur-Appearance" class="headerlink" title="2.1.3 Fur Appearance"></a>2.1.3 Fur Appearance</h3><p>人和动物毛发都具有三层结构，如下图所示。但动物的 Medulla 比人大很多。</p>
<p><img src="/images/Games101/18/18.png"></p>
<p><strong>双层圆柱模型 Double Cylinder Model</strong></p>
<p><img src="/images/Games101/18/19.png"></p>
<h3 id="2-1-4-颗粒材质（Granular-Material）"><a href="#2-1-4-颗粒材质（Granular-Material）" class="headerlink" title="2.1.4 颗粒材质（Granular Material）"></a>2.1.4 颗粒材质（Granular Material）</h3><p><img src="/images/Games101/18/20.png"></p>
<h2 id="2-2-Surface-Model"><a href="#2-2-Surface-Model" class="headerlink" title="2.2 Surface Model"></a>2.2 Surface Model</h2><h3 id="2-2-1-Translucent-半透明-Material"><a href="#2-2-1-Translucent-半透明-Material" class="headerlink" title="2.2.1 Translucent(半透明) Material"></a>2.2.1 Translucent(半透明) Material</h3><p><img src="/images/Games101/18/21.png"></p>
<h3 id="2-2-2-次表面散射（Subsurface-Scattering）"><a href="#2-2-2-次表面散射（Subsurface-Scattering）" class="headerlink" title="2.2.2 次表面散射（Subsurface Scattering）"></a>2.2.2 次表面散射（Subsurface Scattering）</h3><p>Subsurface Scattering 是在表面下发生的散射。</p>
<p><img src="/images/Games101/18/22.png"></p>
<ul>
<li><strong>BSSRDF</strong> 是BRDF概念的延申。它表示某一点的出射radiance来源于另一个点的微分irradiance。</li>
<li><strong>Scattering Function</strong> 渲染方程的延申，表示所有表面上的点和所有方向的积分。</li>
<li><strong>Dipole Approximation</strong> 通过引入两个点光源来近似次表面散射的效果</li>
</ul>
<p><img src="/images/Games101/18/23.png"></p>
<h2 id="2-3-布料-Cloth"><a href="#2-3-布料-Cloth" class="headerlink" title="2.3 布料 Cloth"></a>2.3 布料 Cloth</h2><h3 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h3><ul>
<li>布料是一系列缠绕的纤维构成的。</li>
<li>缠绕有两级：<strong>纤维（Fiber）</strong>第一次缠绕会成为<strong>股（Ply）</strong>，股（Ply）缠绕会成为<strong>线（Yarn）</strong>。</li>
</ul>
<p><img src="/images/Games101/18/24.png"></p>
<h3 id="2-3-2-渲染布料的三种方式"><a href="#2-3-2-渲染布料的三种方式" class="headerlink" title="2.3.2 渲染布料的三种方式"></a>2.3.2 渲染布料的三种方式</h3><p><strong>Cloth: Render as Surface（把布料当作表面来渲染）</strong></p>
<ul>
<li>给定编制图案，计算总体表现。</li>
<li>使用<strong>BRDF</strong>来渲染。</li>
<li>但是对于天鹅绒，根本不是一个平面，所以当作表面来渲染不合理。</li>
</ul>
<p><strong>Cloth: Render as Participating Media（把布料当作散射介质来渲染）</strong></p>
<ul>
<li>把单个纤维和它们分布的性质转化为散射参数。</li>
<li>然后把它们当作散射介质来渲染。</li>
</ul>
<p><strong>Cloth: Render as Actual Fibers （把布料当作真实的纤维来渲染）</strong></p>
<ul>
<li>即明确的渲染每一根纤维。</li>
</ul>
<h2 id="2-4-Detailed-Appearance"><a href="#2-4-Detailed-Appearance" class="headerlink" title="2.4 Detailed Appearance"></a>2.4 Detailed Appearance</h2><h3 id="2-4-1-动机"><a href="#2-4-1-动机" class="headerlink" title="2.4.1 动机"></a>2.4.1 动机</h3><p>渲染出来的太过“完美”，而真实的世界中充满着各种各样的细节。</p>
<p>而细节很难通过渲染表现出来。</p>
<p>因为对于微表面模型来说，通过从光源的不断反射，只有非常少的一部分会被反射到相机。</p>
<p><img src="/images/Games101/18/25.png"></p>
<h3 id="2-4-2-解决：BRDF-over-a-pixel"><a href="#2-4-2-解决：BRDF-over-a-pixel" class="headerlink" title="2.4.2 解决：BRDF over a pixel"></a>2.4.2 解决：BRDF over a pixel</h3><p>由于像素覆盖很多的微表面，所以将一个像素覆盖的法线分布计算出来然后替换光滑的法线分布，用在微表面模型里。</p>
<p><img src="/images/Games101/18/26.png"></p>
<p>一个可以像素覆盖不同大小的微表面，对于比较大的范围会得到统计学规律，而对于比较小的微表面得到的就比较有特点。</p>
<p>不同类型的法线贴图会得到不同的法线分布。</p>
<p><img src="/images/Games101/18/27.png"></p>
<h2 id="2-5-波动光学"><a href="#2-5-波动光学" class="headerlink" title="2.5 波动光学"></a>2.5 波动光学</h2><p>当物体非常小，就不能假设光沿直线传播，而是要考虑波动性，考虑光的波动性。</p>
<p>波动光学的 BRDF 与几何相似，但是相对而言比较不连续。</p>
<p><img src="/images/Games101/18/28.png"></p>
<h2 id="2-6-程序化生成的外观（Procedural-Appearance）"><a href="#2-6-程序化生成的外观（Procedural-Appearance）" class="headerlink" title="2.6 程序化生成的外观（Procedural Appearance）"></a>2.6 程序化生成的外观（Procedural Appearance）</h2><p><strong>动机</strong> 不使用纹理贴图来定义细节。</p>
<p><strong>3D noise（噪声函数）</strong>： 可以直接通过噪声函数来计算细节，使用这种方法可以看到被切割或断裂的内部纹理。</p>
<p><img src="/images/Games101/18/29.png"></p>
<p><strong>应用</strong>：地形、水面、木头。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489/article/details/121725948?ops_request_misc=%7B%22request_id%22:%22170567531416800227439114%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=170567531416800227439114&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-7-121725948-null-null.nonecase&utm_term=%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0&spm=1018.2226.3001.4450">图形学笔记（十六）渲染的高级问题 —— BDPT、MLT、光子映射、VCM、IR、散射介质、毛发材质（双圆柱模型）、次表面散射、布料渲染-CSDN博客</a></p>
<p>这周事情比较多，人又懒得一批… 就一直没更…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/13/games101/Lec%2017/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/13/games101/Lec%2017/" class="post-title-link" itemprop="url">【Games 101】Lec 17：材质和外观</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-13 20:08:06" itemprop="dateCreated datePublished" datetime="2024-01-13T20:08:06+08:00">2024-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-21 20:49:44" itemprop="dateModified" datetime="2024-01-21T20:49:44+08:00">2024-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-17：Materials-and-Appearances"><a href="#Lecture-17：Materials-and-Appearances" class="headerlink" title="Lecture 17：Materials and Appearances"></a>Lecture 17：Materials and Appearances</h1><h1 id="1-外观和材质"><a href="#1-外观和材质" class="headerlink" title="1. 外观和材质"></a>1. 外观和材质</h1><p>外观是光照和材质共同作用的结果。</p>
<p>由于材质不同，光线作用后会得到不同的结果，同样的模型会渲染出不同的结果。</p>
<p><img src="/images/Games101/17/01.png"></p>
<p>渲染方程中，由BRDF来决定材质。所以，<strong>Material &#x3D;&#x3D; BRDF</strong></p>
<h1 id="2-反射和折射"><a href="#2-反射和折射" class="headerlink" title="2. 反射和折射"></a>2. 反射和折射</h1><h2 id="2-1-完全镜面反射（Perfect-Specular-Reflection）"><a href="#2-1-完全镜面反射（Perfect-Specular-Reflection）" class="headerlink" title="2.1 完全镜面反射（Perfect Specular Reflection）"></a>2.1 完全镜面反射（Perfect Specular Reflection）</h2><p>对于完全镜面反射，有两种辨别方法：</p>
<ul>
<li><strong>入射光方向 &#x3D; 出射光方向</strong>，它们中间是<strong>法线</strong>。</li>
<li>把角度投影到局部坐标系，从上往下看，<strong>入射角和出射角相反</strong>。</li>
</ul>
<p><img src="/images/Games101/17/02.png"></p>
<p><strong>反射方向的计算方法：</strong></p>
<p><img src="/images/Games101/17/03.png"></p>
<h2 id="2-2-折射（Specular-Refraction）"><a href="#2-2-折射（Specular-Refraction）" class="headerlink" title="2.2 折射（Specular Refraction）"></a>2.2 折射（Specular Refraction）</h2><h3 id="2-2-1-折射定律（Snell’s-Law）"><a href="#2-2-1-折射定律（Snell’s-Law）" class="headerlink" title="2.2.1 折射定律（Snell’s Law）"></a>2.2.1 折射定律（Snell’s Law）</h3><p>由折射定律，<strong>η</strong> 是不同材质的<strong>折射率</strong>，有：</p>
<p><img src="/images/Games101/17/04.png"></p>
<p><strong>投影后满足下面的关系：</strong></p>
<p><img src="/images/Games101/17/05.png"></p>
<p>如果<strong>入射介质的折射率</strong> <strong>大于 折射介质的折射率</strong> 就会发生 <strong>全反射</strong>。</p>
<p><strong>折射定律公式：</strong></p>
<p><img src="/images/Games101/17/06.png"></p>
<h3 id="2-2-2-Snell’s-Window-Circle-现象"><a href="#2-2-2-Snell’s-Window-Circle-现象" class="headerlink" title="2.2.2 Snell’s Window &#x2F; Circle 现象"></a>2.2.2 Snell’s Window &#x2F; Circle 现象</h3><p>由于全反射现象，从空气打到水面的光线超过一定角度就无法进入人眼，形成了下面的<strong>Snell’s Window &#x2F; Circle 现象</strong>。</p>
<p><img src="/images/Games101/17/07.png"></p>
<h2 id="2-3-菲涅尔项（Fresnel-Reflection-Term）"><a href="#2-3-菲涅尔项（Fresnel-Reflection-Term）" class="headerlink" title="2.3 菲涅尔项（Fresnel Reflection &#x2F; Term）"></a>2.3 菲涅尔项（Fresnel Reflection &#x2F; Term）</h2><h3 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h3><p><strong>反射</strong> 和 <strong>入射光的角度</strong>有关。</p>
<p><img src="/images/Games101/17/08.png"></p>
<p><strong>比如上面图片中，当入射光线（我们的视线）和桌子的法线越垂直，反射就越明显；</strong></p>
<p><strong>不同的材质他们的效果是不一样的，比如镜子，那么不论从哪个角度看，反射都很明显；</strong></p>
<p><strong>这个材质的性质，我们用菲涅尔项来定义；</strong></p>
<p>下面这个菲尼尔项是上面例子的：可以看到角度越大反射率越高</p>
<p><img src="/images/Games101/17/09.png"></p>
<h3 id="2-3-2-Fresnel-Term-公式"><a href="#2-3-2-Fresnel-Term-公式" class="headerlink" title="2.3.2 Fresnel Term 公式"></a>2.3.2 Fresnel Term 公式</h3><ul>
<li><strong>精确公式：需要考虑极化（polarization）</strong></li>
</ul>
<p><img src="/images/Games101/17/10.png"></p>
<ul>
<li><strong>近似公式：Schlick’s approximation</strong></li>
</ul>
<p><img src="/images/Games101/17/11.png"></p>
<h1 id="3-常见材质"><a href="#3-常见材质" class="headerlink" title="3. 常见材质"></a>3. 常见材质</h1><h2 id="3-1-漫反射材质（Diffuse-Lambertian-Material）"><a href="#3-1-漫反射材质（Diffuse-Lambertian-Material）" class="headerlink" title="3.1 漫反射材质（Diffuse &#x2F; Lambertian Material）"></a>3.1 漫反射材质（Diffuse &#x2F; Lambertian Material）</h2><p><strong>在漫反射中，光被到达后会被均匀的反射到四面八方。</strong></p>
<p>现在假设进来的光也是均匀的，即来自各个角度的 Irradiance 是相同的。那么如果表面不吸收光，那么入射和出射的 Irradiance，且入射和出射都是均匀（uniform）的，那么入射光和出射光的 Radiance 也是相同的。</p>
<p><strong>漫反射的 BRDF 推导如下：</strong></p>
<p><img src="/images/Games101/17/12.png"></p>
<ul>
<li>其中 ρ 是反射率；</li>
<li>如果是完全不吸收能量，即反射率 ρ &#x3D; 1，此时 BRDF &#x3D; 1 &#x2F; π</li>
</ul>
<h2 id="3-2-Glossy-material（BDRF）"><a href="#3-2-Glossy-material（BDRF）" class="headerlink" title="3.2 Glossy material（BDRF）"></a>3.2 Glossy material（BDRF）</h2><p>Glossy material是被打磨的铜镜之类的材质效果，是较为模糊的镜面，<strong>BRDF 的反射方向集中在一个小范围内。</strong></p>
<p><img src="/images/Games101/17/13.png"></p>
<h2 id="3-3-Ideal-reflective-refractive-material-BSDF"><a href="#3-3-Ideal-reflective-refractive-material-BSDF" class="headerlink" title="3.3 Ideal reflective &#x2F; refractive material(BSDF*)"></a>3.3 Ideal reflective &#x2F; refractive material(BSDF*)</h2><p><strong>此种材质同时具有反射和折射，可以使用BSDF来表示这种材质（同时考虑反射和折射）。</strong></p>
<p><strong>BSDF &#x3D; BRDF + BTDF</strong></p>
<p><img src="/images/Games101/17/14.png"></p>
<h2 id="3-4-微表面材质（Microfacet-Material）"><a href="#3-4-微表面材质（Microfacet-Material）" class="headerlink" title="3.4 微表面材质（Microfacet Material）"></a>3.4 微表面材质（Microfacet Material）</h2><h3 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1 概述"></a>3.4.1 概述</h3><p><strong>基本思想</strong>：</p>
<ul>
<li><strong>如果离一个物体足够远，那么就看不到表面的细节，取而代之的是表面上的物体对表面的作用，即对光总体的效应。</strong></li>
</ul>
<p><strong>例子</strong>：</p>
<ul>
<li>如下图太阳找到澳大利亚，澳大利亚的不同地形反映出来的是一个比较亮的材质。</li>
</ul>
<p><img src="/images/Games101/17/15.png"></p>
<h3 id="3-4-2-微表面原理（Microfacet-Theory）"><a href="#3-4-2-微表面原理（Microfacet-Theory）" class="headerlink" title="3.4.2 微表面原理（Microfacet Theory）"></a>3.4.2 微表面原理（Microfacet Theory）</h3><p>微表面模型认为从<strong>远处看到的是材质外观</strong>，从<strong>近处看到的几何</strong>。</p>
<p><strong>关键</strong> 研究微表面法线的分布。如下图所示，<strong>不同的法线分布会产生不同的材质</strong>：</p>
<ul>
<li><strong>法线分布集中就是 Glossy；</strong></li>
<li><strong>分散就是 Diffuse。</strong></li>
</ul>
<p><img src="/images/Games101/17/16.png"></p>
<h3 id="3-4-3-Microfacet-BRDF（微表面的BRDF）"><a href="#3-4-3-Microfacet-BRDF（微表面的BRDF）" class="headerlink" title="3.4.3 Microfacet BRDF（微表面的BRDF）"></a>3.4.3 Microfacet BRDF（微表面的BRDF）</h3><p>Microfacet BRDF主要由三项构成：</p>
<ul>
<li><strong>Fresnel term</strong>：不同入射方向带来不同程度的反射，侧重能量。</li>
<li><strong>distribution of normals</strong>：法线分布，表示对于给定方向分布的值是多少。结合半程向量h就可以确定什么样的微表面可以从入射反射到出射（半程向量离法线越近越能反射）。</li>
<li><strong>shadowing-masking term</strong>：几何项，由于自遮挡现象使得有些微表面的作用。当光线几乎平着的打到微表面就容易发生shadow-masking。</li>
</ul>
<p><img src="/images/Games101/17/17.png"></p>
<h2 id="3-5-各项同性-各向异性材质（Isotropic-Anisotropic-Material-BRDFs-）"><a href="#3-5-各项同性-各向异性材质（Isotropic-Anisotropic-Material-BRDFs-）" class="headerlink" title="3.5 各项同性&#x2F;各向异性材质（Isotropic &#x2F; Anisotropic Material (BRDFs)）"></a>3.5 各项同性&#x2F;各向异性材质（Isotropic &#x2F; Anisotropic Material (BRDFs)）</h2><h3 id="3-5-1-概述"><a href="#3-5-1-概述" class="headerlink" title="3.5.1 概述"></a>3.5.1 概述</h3><p>各向异性会产生如下效果。</p>
<p><img src="/images/Games101/17/18.png"></p>
<p><strong>关键</strong>：各向异性的表面的法线分布具有方向性。</p>
<p><img src="/images/Games101/17/19.png"></p>
<h3 id="3-5-2-各向同性与各向异性的区别"><a href="#3-5-2-各向同性与各向异性的区别" class="headerlink" title="3.5.2 各向同性与各向异性的区别"></a>3.5.2 各向同性与各向异性的区别</h3><p><strong>区别：</strong>如果BRDF不满足在方位角上旋转得到的还是相同的BRDF，则称为是各向异性材质。</p>
<p><strong>简单来说各向同性的 BRDF 只和相对的方位角有关，而各向异性材质不止和相对方位角有关还和绝对方位角有关。</strong></p>
<p><img src="/images/Games101/17/20.png"></p>
<h1 id="4-BRDFs-的性质"><a href="#4-BRDFs-的性质" class="headerlink" title="4. BRDFs 的性质"></a>4. BRDFs 的性质</h1><ul>
<li>BRDF 是<strong>非负</strong>的：</li>
<li><img src="/images/Games101/17/21.png"></li>
<li>BRDF 是<strong>线性的，可拆分</strong>：</li>
<li><img src="/images/Games101/17/22.png"></li>
<li>BRDF 具<strong>有可逆性</strong>（Reciprocity）：交换入射方向和出射方向的角色，得到相同的 BRDF。</li>
<li><img src="/images/Games101/17/23.png"></li>
<li>BRDF <strong>能量守恒</strong>：</li>
<li><img src="/images/Games101/17/24.png"></li>
<li><strong>各向同性与各向异性：</strong></li>
<li><img src="/images/Games101/17/25.png"></li>
</ul>
<h1 id="5-测量-BRDFs"><a href="#5-测量-BRDFs" class="headerlink" title="5. 测量 BRDFs"></a>5. 测量 BRDFs</h1><p>只有测量出的 BRDF 才是真正的 BRDF。</p>
<h2 id="5-1-动机"><a href="#5-1-动机" class="headerlink" title="5.1 动机"></a>5.1 动机</h2><ul>
<li><strong>避免计算 BRDF 模型，只要测量出来就可以用。</strong></li>
<li><strong>计算的不一定准确，但测量能准确的得出真实世界的材质。</strong></li>
</ul>
<p><img src="/images/Games101/17/26.png"></p>
<h2 id="5-2-测量方法"><a href="#5-2-测量方法" class="headerlink" title="5.2 测量方法"></a>5.2 测量方法</h2><p>测量 BRDF 就是让光影和相机从各个方向去照去拍。</p>
<p><img src="/images/Games101/17/27.png"></p>
<p>下图是测量工具：gonioreflectometer，可以精确到0.1°的级别。</p>
<p><img src="/images/Games101/17/28.png"></p>
<h2 id="5-3-伪代码和优化"><a href="#5-3-伪代码和优化" class="headerlink" title="5.3 伪代码和优化"></a>5.3 伪代码和优化</h2><p><strong>伪代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foreach outgoing direction wo</span><br><span class="line">	move light to illuminate surface with a thin beam from wo</span><br><span class="line">	foreach incoming direction wi</span><br><span class="line">		move senser to be at direction wi from surface</span><br><span class="line">		measure incident radiance</span><br></pre></td></tr></table></figure>

<p><strong>优化：</strong></p>
<ul>
<li><strong>各向同性把维度从 4 维减少到了3维</strong></li>
<li><strong>使用可逆性减少了一般的测量</strong></li>
<li><strong>使用更加巧妙的光学测量</strong></li>
</ul>
<h2 id="5-3-表示-BRDF"><a href="#5-3-表示-BRDF" class="headerlink" title="5.3 表示 BRDF"></a>5.3 表示 BRDF</h2><h3 id="5-3-1-要求"><a href="#5-3-1-要求" class="headerlink" title="5.3.1 要求"></a>5.3.1 要求</h3><ul>
<li>紧凑的表示</li>
<li>测量数据的准确表示</li>
<li>对随意一对方向的高效预测</li>
<li>可用于重要性抽样的良好分布</li>
</ul>
<h3 id="5-3-2-表格化表示（Tabular-Representation）"><a href="#5-3-2-表格化表示（Tabular-Representation）" class="headerlink" title="5.3.2 表格化表示（Tabular Representation）"></a>5.3.2 表格化表示（Tabular Representation）</h3><p>把规则空间采样存储到三维数组 ( θi , θo , ∣ ϕi − ϕo ∣) 里。</p>
<p>参数化角度以更好地匹配镜面反射。</p>
<p>一般需要将测量值重新采样到表格中。</p>
<p><img src="/images/Games101/17/30.png"></p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489/article/details/121711731?spm=1001.2014.3001.5502">图形学笔记（十五）材质和外观 —— 菲涅尔项、常见材质（微表面材质、各向同性与各向异性）、BSDF、BRDF的性质、测量BRDF-CSDN博客</a></p>
<p>好多好难… </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/13/games101/Lec%2015/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/13/games101/Lec%2015/" class="post-title-link" itemprop="url">【Games 101】Lec 15：光线追踪 3（辐射度量学，光传输，全局光照）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-13 13:16:57 / 修改时间：15:01:38" itemprop="dateCreated datePublished" datetime="2024-01-13T13:16:57+08:00">2024-01-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-15：Ray-Tracing-3-Light-Transport-Global-Illumination"><a href="#Lecture-15：Ray-Tracing-3-Light-Transport-Global-Illumination" class="headerlink" title="Lecture 15：Ray Tracing 3 (Light Transport &amp; Global Illumination)"></a>Lecture 15：Ray Tracing 3 (Light Transport &amp; Global Illumination)</h1><p>这节课讲的是 <strong>Light Transport &amp; Global Illumination</strong> 当然首先包含了上一节课最后的辐射度量学；</p>
<p>ps：这几节课是真的难…</p>
<h1 id="1-辐射度量学（Basic-radiometry）"><a href="#1-辐射度量学（Basic-radiometry）" class="headerlink" title="1. 辐射度量学（Basic radiometry）"></a>1. 辐射度量学（Basic radiometry）</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><strong>辐射度量学的动机：</strong></p>
<p>光源中定义L&#x3D;10，但是10代表的是什么无法确定，缺少单位。</p>
<p><strong>定义：</strong></p>
<p>辐射度量学就是<strong>在物理上准确度量光照</strong>的方法。</p>
<p>它定义了一系列的方法和单位，准确的定义了光在空间中的属性：</p>
<ul>
<li>Radiant flux（辐射通量）</li>
<li>intensity（辐射强度）</li>
<li>irradiance（辐射[照]度）</li>
<li>radiance（辐[射]亮度）</li>
</ul>
<h2 id="1-2-角，立体角（solid-angle），微分立体角"><a href="#1-2-角，立体角（solid-angle），微分立体角" class="headerlink" title="1.2 角，立体角（solid angle），微分立体角"></a>1.2 角，立体角（solid angle），微分立体角</h2><ol>
<li><strong>角 Angle：</strong> 圆上的弧长与半径的比值。</li>
</ol>
<p><img src="/images/Games101/15/01.png"></p>
<ol start="2">
<li><strong>立体角（solid angle）：球面上的面积和半径平方的比值。</strong>（弧度制在三维空间的延申）</li>
</ol>
<p><img src="/images/Games101/15/02.png"></p>
<ol start="3">
<li><strong>微分立体角（Differential）</strong></li>
</ol>
<p><img src="/images/Games101/15/03.png"></p>
<blockquote>
<p>dA 是球面上的微分面积，近似成长方形</p>
</blockquote>
<p>通过积分可以得到，整个球的立体角是 <strong>4π</strong> 。</p>
<p><img src="/images/Games101/15/04.png"></p>
<h2 id="1-3-Radiant-Energy-and-Flux-Power"><a href="#1-3-Radiant-Energy-and-Flux-Power" class="headerlink" title="1.3 Radiant Energy and Flux (Power)"></a>1.3 Radiant Energy and Flux (Power)</h2><h3 id="1-3-1-Radiant-Energy"><a href="#1-3-1-Radiant-Energy" class="headerlink" title="1.3.1 Radiant Energy"></a>1.3.1 Radiant Energy</h3><p><strong>定义：Radiant energy是一种电磁辐射的能量。它由 <strong>焦耳</strong>（J&#x3D;Joule）单位来度量，用符号</strong>Q<strong>来表示。</strong></p>
<p><img src="/images/Games101/15/05.png"></p>
<h3 id="1-3-2-Radient-Flux-Power"><a href="#1-3-2-Radient-Flux-Power" class="headerlink" title="1.3.2 Radient Flux(Power)"></a>1.3.2 Radient Flux(Power)</h3><p><strong>定义：</strong></p>
<ul>
<li><strong>Radient flux(Power) 是单位时间的发射出的、反射的、传播的和接收的能量。</strong></li>
<li>或者：<strong>单位时间辐射出光子的数量</strong></li>
</ul>
<p><img src="/images/Games101/15/06.png"></p>
<h2 id="1-4-与光相关的物理量"><a href="#1-4-与光相关的物理量" class="headerlink" title="1.4 与光相关的物理量"></a>1.4 与光相关的物理量</h2><p>主要是区别下面三种物理量：</p>
<ul>
<li><strong>Radiant Intensity</strong>：光源辐射出的能量；</li>
<li><strong>Irrdiance</strong>：物体表面接收的光的能量；</li>
<li><strong>Radiance</strong>：光线在传播过程中的能量；</li>
</ul>
<p><img src="/images/Games101/15/07.png"></p>
<h3 id="1-4-1-Radient-intensity"><a href="#1-4-1-Radient-intensity" class="headerlink" title="1.4.1 Radient intensity"></a>1.4.1 Radient intensity</h3><p><strong>定义：</strong></p>
<ul>
<li>Radient intensity是 <strong>每单位立体角</strong> 辐射的能量。</li>
</ul>
<p><img src="/images/Games101/15/08.png"></p>
<h3 id="1-4-2-Irradiance"><a href="#1-4-2-Irradiance" class="headerlink" title="1.4.2 Irradiance"></a>1.4.2 Irradiance</h3><p><strong>定义：</strong></p>
<ul>
<li><strong>Irradiance</strong> 是<strong>单位面积的辐射通量</strong>（面必须和光线<strong>垂直</strong>，否则要变成和投影面垂直的）。</li>
</ul>
<p><img src="/images/Games101/15/09.png"></p>
<p><strong>Irradiance 例子：</strong></p>
<ul>
<li>冬夏温度之分是因为点光源辐射的能量到达辐射点的角度不同步（阳光和不同区域的夹角不同），导致接收的能量不同。</li>
<li>Irradiance 会衰减（不是 Intensity 衰减）</li>
</ul>
<p><img src="/images/Games101/15/10.png"></p>
<h3 id="1-4-3-Radiance"><a href="#1-4-3-Radiance" class="headerlink" title="1.4.3 Radiance"></a>1.4.3 Radiance</h3><p>Radiance 描述光线在传播过程中的属性。</p>
<p><strong>定义：</strong></p>
<ul>
<li>单位面积，单位立体角接受的能力；</li>
<li>或者理解为：<strong>在单位面积，单位立体角 发出的能量</strong>；</li>
</ul>
<p><img src="/images/Games101/15/11.png"></p>
<p><strong>注意：</strong></p>
<p>因为 <strong>Irradiance</strong> 是<strong>单位面积的辐射通量</strong>，<strong>Intensity</strong> 是<strong>单位立体角发出的能量</strong>。</p>
<p>所以 Radiance是<strong>每单位立体角的 Irradiance</strong>，Radiance是<strong>每单位面积的正交 Intensity</strong>。</p>
<h4 id="1-4-3-1-Incident-Radiance"><a href="#1-4-3-1-Incident-Radiance" class="headerlink" title="1.4.3.1 Incident Radiance"></a>1.4.3.1 Incident Radiance</h4><p>Incident Radiance 是每<strong>单位立体角</strong>的<strong>到达</strong>表面的 <strong>Irradiance</strong>。</p>
<p><img src="/images/Games101/15/12.png"></p>
<h4 id="1-4-3-2-Exiting-Radiance"><a href="#1-4-3-2-Exiting-Radiance" class="headerlink" title="1.4.3.2 Exiting Radiance"></a>1.4.3.2 Exiting Radiance</h4><p>Exiting surface radiance 是<strong>每单位面积</strong>向某个角度辐射出的 <strong>Intensity</strong>（这里参考文章里面应该是写错了）。</p>
<p><img src="/images/Games101/15/13.png"></p>
<h2 id="1-5-Irradiance-和-Radiance"><a href="#1-5-Irradiance-和-Radiance" class="headerlink" title="1.5 Irradiance 和 Radiance"></a>1.5 Irradiance 和 Radiance</h2><p><strong>Irradiance</strong>：被区域 dA 吸收的所有的能量。</p>
<p><strong>Radiance</strong>：被区域 dA 的来自d ω 的能量（多了一个立体角）。</p>
<p><img src="/images/Games101/15/14.png"></p>
<h2 id="1-6-各向同性点光源-Isotropic-Point-Source"><a href="#1-6-各向同性点光源-Isotropic-Point-Source" class="headerlink" title="1.6 各向同性点光源 Isotropic Point Source"></a>1.6 各向同性点光源 Isotropic Point Source</h2><p>如果点光源均匀的辐射出光，则可以得到点光源的强度 <strong>I</strong> 如下所示。</p>
<p><img src="/images/Games101/15/15.png"></p>
<h1 id="2-双向反射分布函数-Bidirectional-Reflectance-Distribution-Function（BRDF）"><a href="#2-双向反射分布函数-Bidirectional-Reflectance-Distribution-Function（BRDF）" class="headerlink" title="2. 双向反射分布函数 Bidirectional Reflectance Distribution Function（BRDF）"></a>2. 双向反射分布函数 Bidirectional Reflectance Distribution Function（BRDF）</h1><p><strong>引入</strong> ：</p>
<ul>
<li>来自于 <strong>ωi 立体角</strong>的 <strong>Radiance</strong> 转化成 dA 接受的能量E，然后能量E会变成向着任何其他方向 ω 的 Radiance。</li>
</ul>
<p><strong>意义：</strong></p>
<ul>
<li><strong>BRDF</strong> 用于<strong>表示某个微小面积 dA 从某个微小立体角 dωi 接受的 Irradiance 会如何被分配到不同的立体角去。</strong></li>
</ul>
<p><strong>定义：</strong></p>
<p><strong>如下图所示，从来自 ωi 立体角的 Irradiance（dE(ωi))，经过单位面积吸收后，向某一立体角 ωr 发射出去，发射出去的 Radiance 是 dLr(x , ωr)</strong></p>
<p><img src="/images/Games101/15/16.png"></p>
<p><strong>BRDF 用于表示从每个入射方向进来的光线会每个向出射方向 ωr 反射的能量多少。</strong></p>
<p><strong>BRDF 就是任何一个出射方向的 Radiance 的微分 除以 在入射点上 Irradiance的微</strong>分，BRDF 如下所示。</p>
<p><img src="/images/Games101/15/17.png"></p>
<h2 id="2-1-反射方程（The-Reflection-Equation）"><a href="#2-1-反射方程（The-Reflection-Equation）" class="headerlink" title="2.1 反射方程（The Reflection Equation）"></a>2.1 反射方程（The Reflection Equation）</h2><p>BRDF 是描述光线对物体时如何作用的，所以可以<strong>用于定义不同的材质</strong>。</p>
<p><strong>把每一个方向对出射方向的贡献积分起来就会获得向某个方向反射出光照的结果。</strong></p>
<p><img src="/images/Games101/15/18.png"></p>
<p>反射radiance取决于入射radiance，而入射Radiance不仅取决于光源，还有<strong>被其他物体反射的光</strong>，具有递归关系。</p>
<p><img src="/images/Games101/15/19.png"></p>
<h2 id="2-2-渲染方程（The-Rendering-Equation）"><a href="#2-2-渲染方程（The-Rendering-Equation）" class="headerlink" title="2.2 渲染方程（The Rendering Equation）"></a>2.2 渲染方程（The Rendering Equation）</h2><p><strong>渲染方程</strong> &#x3D; <strong>加上自己辐射的 Radiance</strong> + <strong>反射方程</strong></p>
<p><img src="/images/Games101/15/20.png"></p>
<p>注意：</p>
<ul>
<li><p>这里默认所有的方向 ω 都是向外的。</p>
</li>
<li><p>而且此时考虑的照亮到这一点的都是光源</p>
</li>
</ul>
<p><strong>但是实际上照亮这一点的不仅仅有光源的 Radiance，还有可能是其他物体反射过来的 Radiance；</strong></p>
<p>如果<strong>考虑其他物体反射的radiance</strong>，就把反射物体和反射面当成光源，可以把渲染方程写成更通用的形式。</p>
<p><img src="/images/Games101/15/21.png"></p>
<p><strong>以上的式子可以简单的表达为：</strong></p>
<p><img src="/images/Games101/15/22.png"></p>
<p><strong>K为反射操作符，进一步简写为：</strong></p>
<p><img src="/images/Games101/15/23.png"></p>
<p>可以看出L是递归定义的。</p>
<h3 id="2-2-1-结论"><a href="#2-2-1-结论" class="headerlink" title="2.2.1 结论"></a>2.2.1 结论</h3><p>简写渲染方程（L&#x3D; E + K L）的目的是解出 L。</p>
<p><strong>解L的方法如下所示，其中K也可以理解成反射次数，反射次数越多，项越多，K^2 代表光弹射两次。</strong></p>
<p><img src="/images/Games101/15/24.png"></p>
<p><strong>全局光照 &#x3D; 直接光照（E） + 间接光照（KE + K^2E + K^3E + …）</strong></p>
<p><img src="/images/Games101/15/25.png"></p>
<p><strong>光栅化的着色一般只有 E+EK，而后面的间接光照部分光栅化难以做到，一般使用光线追踪（路径追踪）来进行计算。</strong></p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489/article/details/121655346?spm=1001.2014.3001.5502">图形学笔记（十三）光线追踪3——双向反射分布函数BRDF（反射方程、递归方程）、辐射度量学基础radiometry、立体角、Radiant Energy、Flux、Irrdiance、Radiance_irrdiance 测量仪-CSDN博客</a></p>
<p><strong>好难…</strong> </p>
<p><strong>光做笔记都要写好久好久…</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/13/games101/Lec%2016/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/13/games101/Lec%2016/" class="post-title-link" itemprop="url">【Games 101】Lec 16：光线追踪 4（蒙特卡罗积分，路径追踪）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-13 13:16:57 / 修改时间：19:09:35" itemprop="dateCreated datePublished" datetime="2024-01-13T13:16:57+08:00">2024-01-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-16：Ray-Tracing-4-Monte-Carlo-Path-Tracing"><a href="#Lecture-16：Ray-Tracing-4-Monte-Carlo-Path-Tracing" class="headerlink" title="Lecture 16：Ray Tracing 4 (Monte Carlo Path Tracing)"></a>Lecture 16：Ray Tracing 4 (Monte Carlo Path Tracing)</h1><p>上一节课最后还讲了一点概率论，比较简单；</p>
<p>介绍了一个概念，后面常用，<strong>概率分布（密度）函数：</strong></p>
<p><img src="/images/Games101/16/01.png"></p>
<h1 id="1-蒙特卡洛积分（Monte-Carlo-Integration）"><a href="#1-蒙特卡洛积分（Monte-Carlo-Integration）" class="headerlink" title="1. 蒙特卡洛积分（Monte Carlo Integration）"></a>1. 蒙特卡洛积分（Monte Carlo Integration）</h1><h2 id="1-1-Why？"><a href="#1-1-Why？" class="headerlink" title="1.1 Why？"></a>1.1 Why？</h2><p><strong>蒙特卡洛（Monte Carlo）积分</strong>目的是 解决定积分，但是它难以积分（解析式不好表达，不定积分不好求）的情况。</p>
<p><img src="/images/Games101/16/02.png"></p>
<h2 id="1-2-具体方法"><a href="#1-2-具体方法" class="headerlink" title="1.2 具体方法"></a>1.2 具体方法</h2><h3 id="1-2-1-基本思想"><a href="#1-2-1-基本思想" class="headerlink" title="1.2.1 基本思想"></a>1.2.1 基本思想</h3><p>在积分域内不断采样，获得 y 值，不断的与 ab 范围获得一个个长方形，然后<strong>把所有长方形的面积相加求平均。</strong></p>
<h3 id="1-2-2-过程"><a href="#1-2-2-过程" class="headerlink" title="1.2.2 过程"></a>1.2.2 过程</h3><p>在积分域 [a,b] 之间不断随机取样 xi，得到结果为 f(xi)，作为长方形的高，那么我们就能得到这次采样的长方形的面积 (b-a)*f(xi)（但是并不准确），当我们多次采样后求平均，那么他就准确了。</p>
<p>然后，采样的话可以用不同的概率密度函数p(x)；</p>
<p><strong>对于给定函数 f(x) 的定积分，定义蒙特卡洛（Monte Carlo）积分：</strong></p>
<p><img src="/images/Games101/16/03.png"></p>
<p><img src="/images/Games101/16/04.png"></p>
<p>（其实不是很懂为什么这个 p(xi) 被放在了分母）</p>
<p><strong>注意：</strong></p>
<ul>
<li><strong>N越大，得到的结果越精确。</strong></li>
<li><strong>在x上积分就一定要在x上取样。</strong></li>
</ul>
<h3 id="1-2-3-例子"><a href="#1-2-3-例子" class="headerlink" title="1.2.3 例子"></a>1.2.3 例子</h3><p>假如有一个均匀分布的概率分布函数，则他的蒙特卡洛积分为：</p>
<p><img src="/images/Games101/16/05.png"></p>
<p><img src="/images/Games101/16/06.png"></p>
<h1 id="2-路径追踪"><a href="#2-路径追踪" class="headerlink" title="2. 路径追踪"></a>2. 路径追踪</h1><h2 id="2-1-动机：改进-Whitted-Style-Ray-Tracing"><a href="#2-1-动机：改进-Whitted-Style-Ray-Tracing" class="headerlink" title="2.1 动机：改进 Whitted-Style Ray Tracing"></a>2.1 动机：改进 Whitted-Style Ray Tracing</h2><p>Whitted-Style Ray Tracing 对光线进行了如下假设：</p>
<ul>
<li>总是进行镜面反射和折射</li>
<li>光线在漫反射面停止跳跃</li>
</ul>
<h3 id="2-1-1-Whitted-Style-Ray-Tracing-存在的问题"><a href="#2-1-1-Whitted-Style-Ray-Tracing-存在的问题" class="headerlink" title="2.1.1 Whitted-Style Ray Tracing 存在的问题"></a>2.1.1 Whitted-Style Ray Tracing 存在的问题</h3><p><strong>问题1</strong>：</p>
<ul>
<li>如下是 Mirror reflection 和 Glossy reflection，但是<strong>对于打到Glossy的物体上的光线，传播的路径不能与Specular完全相同</strong>。</li>
</ul>
<p><img src="/images/Games101/16/07.png"></p>
<p><strong>问题2</strong>：</p>
<ul>
<li>对于漫反射物体，如果光线传播到它的表面上，那么还是会有光线传播的，<strong>不应该停止</strong>。</li>
</ul>
<p><img src="/images/Games101/16/08.png"></p>
<blockquote>
<p>color bleeding：面的颜色流到其他的面上去。 就像上方右图高长方体的左面被全局光照映照出红色。</p>
</blockquote>
<h3 id="2-1-2-Whitted-Style-Ray-Tracing问题的解决办法"><a href="#2-1-2-Whitted-Style-Ray-Tracing问题的解决办法" class="headerlink" title="2.1.2 Whitted-Style Ray Tracing问题的解决办法"></a>2.1.2 Whitted-Style Ray Tracing问题的解决办法</h3><p><strong>Whitted-Style Ray Tracing 是错的，但是渲染方程是正确的。</strong></p>
<p>但是此方程涉及</p>
<ul>
<li><strong>解半球的积分</strong><ul>
<li><strong>解决方法：使用Monte Carlo积分解渲染方程的积分。</strong></li>
</ul>
</li>
<li><strong>递归</strong><ul>
<li><strong>解决方法：使用俄罗斯轮盘法来结束递归。</strong></li>
</ul>
</li>
</ul>
<p><img src="/images/Games101/16/09.png"></p>
<h2 id="2-2-使用Monte-Carlo积分解渲染方程的积分"><a href="#2-2-使用Monte-Carlo积分解渲染方程的积分" class="headerlink" title="2.2 使用Monte Carlo积分解渲染方程的积分"></a>2.2 使用Monte Carlo积分解渲染方程的积分</h2><h3 id="2-2-1-步骤"><a href="#2-2-1-步骤" class="headerlink" title="2.2.1 步骤"></a>2.2.1 步骤</h3><p><strong>目的：渲染下面场景的一像素的直接光照。</strong></p>
<p><img src="/images/Games101/16/10.png"></p>
<p><strong>ω0：观测方向，从着色点到观测方向。</strong></p>
<p><strong>ωi：各个不同的入射的方向。</strong></p>
<p>这里直接搬了参考文章中的分析：</p>
<p><img src="/images/Games101/16/11.png"></p>
<p>对于只考虑直接光照，算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">	随机选择 wi ~ pdf 的 N 个方向</span><br><span class="line">	Lo=<span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> 每个 wi</span><br><span class="line">		追踪一个光线r(p,wi)</span><br><span class="line">		<span class="keyword">if</span> 光线打到了光源</span><br><span class="line">			Lo += (<span class="number">1</span>/N) * L_i * f_r * cosine / pdf(wi)</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> r达到了一个物体上的q点</span><br><span class="line">			Lo += (<span class="number">1</span>/N) * shade(q,-wi) * f_r * cosine / pdf(wi)			</span><br><span class="line">	<span class="keyword">return</span> Lo</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-问题：路径追踪解决光线数量爆炸"><a href="#2-2-2-问题：路径追踪解决光线数量爆炸" class="headerlink" title="2.2.2 问题：路径追踪解决光线数量爆炸"></a>2.2.2 问题：路径追踪解决光线数量爆炸</h3><p>使用上面的方法，由于光线跳跃多次，<strong>光线的数量会爆炸</strong>（有递归）<strong>rays &#x3D; N^bounces</strong> ;</p>
<p><strong>解决方法</strong> 令N &#x3D; 1，即每次只选取 wi~pdf 的一个方向。</p>
<p><strong>路径追踪就是上面N&#x3D;1的算法</strong> ，即每次路径追踪只是随机选择一个方向反射。</p>
<p><img src="/images/Games101/16/12.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shade</span>(p,wo)</span><br><span class="line">	随机选择 wi~pdf 的<span class="number">1</span>个方向</span><br><span class="line">	追踪一个光线<span class="built_in">r</span>(p,wi)</span><br><span class="line">	<span class="keyword">if</span> 光线r打到了光源</span><br><span class="line">		<span class="keyword">return</span> L_i * f_r * cosine / <span class="built_in">pdf</span>(wi)</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> r达到了一个物体上的q点</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">shade</span>(q,-wi) * f_r * cosine / <span class="built_in">pdf</span>(wi)			</span><br></pre></td></tr></table></figure>

<p>但是噪声会很大。但是只要对每个像素<strong>trace more paths</strong>并求它们radiance的<strong>平均</strong>就可以减少噪声。如下所示。</p>
<p><img src="/images/Games101/16/13.png"></p>
<h3 id="2-2-3-Ray-Generation"><a href="#2-2-3-Ray-Generation" class="headerlink" title="2.2.3 Ray Generation"></a>2.2.3 Ray Generation</h3><p>为了减少噪声，所以每个像素要生成多个光线，进行多次路径追踪，光线生成算法如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ray_generation</span>(camPos,pixel)</span><br><span class="line">   在像素中平均的选取N个采样点</span><br><span class="line">   pixel_radiance = <span class="number">0.0</span></span><br><span class="line">   <span class="keyword">for</span> 对于像素中的每个采样点</span><br><span class="line">   	射出一条光线<span class="built_in">r</span>(camPos,cam_to_sample)</span><br><span class="line">   	如果光线击中了场景中的p点</span><br><span class="line">   		pixel_radiance += <span class="number">1</span> / N * <span class="built_in">shade</span>(p, sample_to_cam)</span><br><span class="line">   <span class="keyword">return</span> pixel_radiance</span><br></pre></td></tr></table></figure>

<p>其实这里也有点像蒙特卡洛积分，也是取平均；</p>
<h2 id="2-3-使用俄罗斯轮盘（RR）解决递归算法停不下来"><a href="#2-3-使用俄罗斯轮盘（RR）解决递归算法停不下来" class="headerlink" title="2.3 使用俄罗斯轮盘（RR）解决递归算法停不下来"></a>2.3 使用俄罗斯轮盘（RR）解决递归算法停不下来</h2><p><strong>问题</strong>：</p>
<ul>
<li>虽然现实中的光源跳跃也不会停，但是不停的话递归就无法结束。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>Russion Roulette(RR) 俄罗斯轮盘赌。</li>
</ul>
<h3 id="2-3-1-RR方法概述"><a href="#2-3-1-RR方法概述" class="headerlink" title="2.3.1 RR方法概述"></a>2.3.1 RR方法概述</h3><p>设定一个概率，0&lt;P&lt;1。</p>
<ul>
<li>有概率P，射出光线并且返回着色结果 Lo &#x2F; P；</li>
<li>有概率1-P不射出光线，并返回结果0；</li>
</ul>
<p><strong>用这种方法，仍然可以期望得到值 Lo：</strong></p>
<p><strong>E &#x3D; P ∗ (Lo &#x2F; P) + (1 − P) ∗ 0 &#x3D; Lo</strong></p>
<h3 id="2-3-2-RR方法改进后的路径追踪算法"><a href="#2-3-2-RR方法改进后的路径追踪算法" class="headerlink" title="2.3.2 RR方法改进后的路径追踪算法"></a>2.3.2 RR方法改进后的路径追踪算法</h3><p>进行如上改进后，得到的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shade</span>(p,wo)</span><br><span class="line">	手动指定一个概率 P_RR</span><br><span class="line">	在均匀分布[<span class="number">0</span>,<span class="number">1</span>]范围内随机选择ksi。</span><br><span class="line">	<span class="keyword">if</span>(ksi &gt; P_RR) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">	随机选择 wi~pdf 的<span class="number">1</span>个方向</span><br><span class="line">	追踪一个光线<span class="built_in">r</span>(p,wi)</span><br><span class="line">	<span class="keyword">if</span> 光线r打到了光源</span><br><span class="line">		<span class="keyword">return</span> L_i * f_r * cosine / <span class="built_in">pdf</span>(wi) / P_RR</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> 光线r达到了一个物体上的q点</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">shade</span>(q,-wi) * f_r * cosine / <span class="built_in">pdf</span>(wi) / P_RR</span><br></pre></td></tr></table></figure>

<p>这样就能保证递归可以停止。</p>
<h2 id="2-4-提高-Path-Tracing-的效率"><a href="#2-4-提高-Path-Tracing-的效率" class="headerlink" title="2.4 提高 Path Tracing 的效率"></a>2.4 提高 Path Tracing 的效率</h2><p><strong>问题</strong> 经过以上改进，现在路径追踪算法是正确的了，但是它<strong>不高效</strong>。</p>
<p><img src="/images/Games101/16/14.png"></p>
<p>如下图所示，如果均匀的四面八方采样，对于很多光线只有极少数打到光源，大部分都被浪费掉了。</p>
<p><img src="/images/Games101/16/15.png"></p>
<p><strong>所以我们直接在光源上采样，pdf &#x3D; 1&#x2F;A，但是渲染方程的积分是在立体角上进行的；</strong></p>
<p><img src="/images/Games101/16/16.png"></p>
<p><strong>由于Monte Carlo方程要求在哪里积分就在哪里取样，所以只要把 dω 转变成对 dA 积分即可。</strong></p>
<p>我们得到立体角和光源面积微分 dA 的关系如下：</p>
<p><img src="/images/Games101/16/18.png"></p>
<p><strong>然后重写渲染方程：</strong></p>
<p><img src="/images/Games101/16/19.png"></p>
<p><strong>现在我们认为着色结果来源于两部分：</strong></p>
<ul>
<li><p><strong>光源的贡献（直接采样光源，无需RR）</strong></p>
</li>
<li><p><strong>其他反射（indirect，需要RR）</strong></p>
</li>
</ul>
<p><img src="/images/Games101/16/20.png"></p>
<p><strong>伪代码如下：</strong></p>
<p><img src="/images/Games101/16/21.png"></p>
<p><strong>再考虑另一个问题，如果光源和着色点之间被物体遮挡，则直接返回0。</strong></p>
<p><img src="/images/Games101/16/22.png"></p>
<p><strong>到此 Path Tracing 算法完成。</strong></p>
<h2 id="2-5-Path-Tracing的特点"><a href="#2-5-Path-Tracing的特点" class="headerlink" title="2.5 Path Tracing的特点"></a>2.5 Path Tracing的特点</h2><p><strong>缺点</strong>：路径追踪不好处理点光源。</p>
<p><strong>优点</strong>：Path Tracing 可以做到照片级真实感PHOTO-REALISTIC（如下所示）。</p>
<p><img src="/images/Games101/16/23.png"></p>
<h1 id="3-Raytracing的概念区分"><a href="#3-Raytracing的概念区分" class="headerlink" title="3 Raytracing的概念区分"></a>3 Raytracing的概念区分</h1><p><strong>早期：</strong></p>
<ul>
<li>Ray tracing &#x3D;&#x3D; Whitted-style ray tracing</li>
</ul>
<p><strong>现代：</strong></p>
<ul>
<li>包含所有光线传播方法的集合</li>
<li>（单向&#x2F;双向）path tracing</li>
<li>光子映射 Photon mapping</li>
<li>Metropoils light transport</li>
<li>VCM &#x2F; UPBR</li>
</ul>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489/article/details/121617338?spm=1001.2014.3001.5502">图形学笔记（十四）光线追踪4——蒙特卡洛（Monte Carlo）积分、路径追踪详细过程（Whitted-Style的问题于RR（俄罗斯轮盘赌）算法、Ray Generation）、照片级真实感渲染_图形学rr-CSDN博客</a></p>
<p>太难啦</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/09/games101/Lec%2014/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FJBQ">
      <meta itemprop="description" content="坚定 坚持 坚强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FJBQ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/09/games101/Lec%2014/" class="post-title-link" itemprop="url">【Games 101】Lec 14：光线追踪 2（加速光线追踪 和 辐射度量学）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-09 22:42:57" itemprop="dateCreated datePublished" datetime="2024-01-09T22:42:57+08:00">2024-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-10 23:46:38" itemprop="dateModified" datetime="2024-01-10T23:46:38+08:00">2024-01-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Games 系列</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games-%E7%B3%BB%E5%88%97/Games-101/" itemprop="url" rel="index"><span itemprop="name">Games 101</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-14：Ray-Tracing-2-Acceleration-Radiometry"><a href="#Lecture-14：Ray-Tracing-2-Acceleration-Radiometry" class="headerlink" title="Lecture 14：Ray Tracing 2 (Acceleration &amp; Radiometry)"></a>Lecture 14：Ray Tracing 2 (Acceleration &amp; Radiometry)</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这节课讲了 <strong>光线追踪的加速</strong> 和 辐射度量学；</p>
<p>这篇文章写的是光线追踪的加速，辐射度量学一起放在下一篇文章；</p>
<p>上篇文章讲了包围盒，这节课前面讲的是如何用包围盒加速光线追踪；</p>
<h1 id="均匀空间划分-Uniform-Spatial-Partitions-（Grids）"><a href="#均匀空间划分-Uniform-Spatial-Partitions-（Grids）" class="headerlink" title="均匀空间划分 Uniform Spatial Partitions （Grids）"></a>均匀空间划分 Uniform Spatial Partitions （Grids）</h1><h2 id="预处理-–-建立加速格子"><a href="#预处理-–-建立加速格子" class="headerlink" title="预处理 – 建立加速格子"></a>预处理 – 建立加速格子</h2><ul>
<li><strong>找到包围盒</strong></li>
<li><strong>创建格子</strong></li>
<li><strong>标记出和物体相交的格子</strong></li>
<li><img src="/images/Games101/14/01.png"></li>
</ul>
<h2 id="光线与场景求交点"><a href="#光线与场景求交点" class="headerlink" title="光线与场景求交点"></a>光线与场景求交点</h2><ul>
<li><strong>依次遍历光线穿过的格子</strong></li>
<li><strong>如果这个格子被标记，则说明这个格子里面有物体，那么就计算光线是否和这个格子里面的物体相交</strong></li>
<li><img src="/images/Games101/14/02.png"></li>
</ul>
<h2 id="均匀空间划分的结果"><a href="#均匀空间划分的结果" class="headerlink" title="均匀空间划分的结果"></a>均匀空间划分的结果</h2><p>格子太多和格子太少都是不好的。</p>
<ul>
<li>只有一个格子：没有加速效果。</li>
<li>格子特别密集：需要做很多光线与格子求交，加大开销。</li>
<li>下面是划分方式的经验之谈：</li>
<li><img src="/images/Games101/14/03.png"></li>
</ul>
<p>格子划分法适用于大小和空间<strong>均匀分布</strong>的大型对象集合（如下图所示）。</p>
<p><img src="/images/Games101/14/04.png"></p>
<p>但是此方法不适合于有很多空旷区域的场景（如下图所示），下面又称为 “teapot in stadium” 问题。（其实就是分布不均的场景，有的地方物体很密，有的地方物体很稀疏）</p>
<p><img src="/images/Games101/14/05.png"></p>
<h1 id="空间划分（Spatial-Partitions）"><a href="#空间划分（Spatial-Partitions）" class="headerlink" title="空间划分（Spatial Partitions）"></a>空间划分（Spatial Partitions）</h1><h2 id="空间划分的方式"><a href="#空间划分的方式" class="headerlink" title="空间划分的方式"></a>空间划分的方式</h2><p><img src="/images/Games101/14/06.png"></p>
<ul>
<li><strong>Oct-Tree 八叉树</strong> 把场景包起来，然后把正方体切成<strong>八份</strong>（三维的就是8份，xyz各切一刀，但是上面的图是4份，因为是2维的，所以看起来是2^2）。不断的对子节点递归进行此过程，放格子里面是空的或者物体足够少就停下来。（但是有个严重的问题，随着维度的升高，节点数量指数型增长）</li>
<li><strong>KD-Tree</strong> 与八叉树几乎相同，但是对每次划分的格子，总是<strong>沿着某一个轴切割</strong>（通常是交替的），且对每个格子<strong>仅切割一次</strong>。（好处是相比于八叉树，节点数量的复杂度不会随着维度指数型增长。）（而且不用等分，看下面的例子好理解）</li>
<li><strong>BSP-Tree</strong> 对空间二分，每次划分时选择一个方向，与KD-Tree的区别在于它的切割不一定是与轴平行的。（存在的问题是在维度高的时候不好计算，切割的几何体从点到线到面到超平面。）</li>
</ul>
<h2 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h2><h3 id="KD-Tree-的基本结构"><a href="#KD-Tree-的基本结构" class="headerlink" title="KD-Tree 的基本结构"></a>KD-Tree 的基本结构</h3><p>本质上是一颗二叉树，如下图所示（为了简化没画全，实际上1、2等节点都有子节点）。</p>
<p><img src="/images/Games101/14/07.png"></p>
<ul>
<li>对于<strong>非叶子节点</strong><ul>
<li>划分的轴：x、y或z轴。</li>
<li>划分的位置：分割的平面沿轴的坐标。</li>
<li>子节点：一定有两个子节点。</li>
<li><strong>在非叶子节点不会存储物体。</strong></li>
</ul>
</li>
<li>对于<strong>叶子节点</strong><ul>
<li><strong>存储物体列表。</strong></li>
</ul>
</li>
</ul>
<p>还是有点抽象？没事，看一下下面的应用：（最好看一下原视频）</p>
<h3 id="计算光线与物体交点的步骤"><a href="#计算光线与物体交点的步骤" class="headerlink" title="计算光线与物体交点的步骤"></a>计算光线与物体交点的步骤</h3><ul>
<li>如果<strong>走到非叶子节点</strong>，则<strong>探一下它的两个子节点（递归）</strong></li>
<li>如果<strong>走到叶子节点</strong>，则：<ul>
<li>如果包围盒里面没有物体，则跳过就行了；</li>
<li>如果有物体，则判断光线是否和物体相交；</li>
</ul>
</li>
</ul>
<p><img src="/images/Games101/14/08.png"></p>
<h3 id="KD-Tree的问题"><a href="#KD-Tree的问题" class="headerlink" title="KD-Tree的问题"></a>KD-Tree的问题</h3><ul>
<li>很难判断物体的三角形和AABB包围盒是否有交集。（比如一个包围盒很小，整个嵌在了三角形的面里面，这个要怎么判断？）</li>
<li>一个物体可能会与很多AABB包围盒有交集。也即一个物体可能存储在多个叶子节点里。（计算起来比较废）</li>
</ul>
<h1 id="物体划分与BVH加速结构（Object-Partition-Bounding-Volume-Hierarchy）"><a href="#物体划分与BVH加速结构（Object-Partition-Bounding-Volume-Hierarchy）" class="headerlink" title="物体划分与BVH加速结构（Object Partition &amp; Bounding Volume Hierarchy）"></a>物体划分与BVH加速结构（Object Partition &amp; Bounding Volume Hierarchy）</h1><p>换一种思想，既然对空间划分这么麻烦，那么就直接划分物体；</p>
<h2 id="思想和步骤"><a href="#思想和步骤" class="headerlink" title="思想和步骤"></a>思想和步骤</h2><ul>
<li>首先找到一个包围盒（这个简单啊，所有三角形坐标求min，max就行）</li>
<li>递归的把物体集合划分成两个子集；</li>
<li>重新计算子集的包围盒；</li>
<li>当满足一定要求的时候停止（比如规定一个包围盒里面只有五个三角形的时候）；</li>
<li>在每个叶子节点里存储所有物体；</li>
</ul>
<p>下面是图解：</p>
<p><img src="/images/Games101/14/09.png"></p>
<h2 id="BVH-优点和缺点"><a href="#BVH-优点和缺点" class="headerlink" title="BVH 优点和缺点"></a>BVH 优点和缺点</h2><p>BVH避免了KD-Tree的问题，具有如下优点。</p>
<ul>
<li><strong>一个物体</strong>只能出现在<strong>一个格子</strong>里。</li>
<li><strong>不涉及三角形和包围盒求交</strong>的问题。</li>
</ul>
<p>缺点：</p>
<ul>
<li>BVH并<strong>没有</strong>把<strong>空间严格</strong>的<strong>划分</strong>开（包围盒有可能相交）。</li>
</ul>
<h2 id="BVH-的细节问题"><a href="#BVH-的细节问题" class="headerlink" title="BVH 的细节问题"></a>BVH 的细节问题</h2><h3 id="如何划分节点？"><a href="#如何划分节点？" class="headerlink" title="如何划分节点？"></a>如何划分节点？</h3><p>每次都需要选择一个维度来分割（经验上有下面两种做法）。</p>
<ul>
<li>选择节点中<strong>最长的轴</strong>。</li>
<li>取<strong>中间的物体</strong>的位置来划分节点。</li>
</ul>
<h3 id="如何存储-BVH-树？"><a href="#如何存储-BVH-树？" class="headerlink" title="如何存储 BVH 树？"></a>如何存储 BVH 树？</h3><ul>
<li>中间节点存储包围盒和子节点的指针。</li>
<li>叶子节点存储包围盒和物体列表。</li>
<li>节点代表场景中图元（primitives）的子集，所有物体都在子树中。</li>
</ul>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 参考的是课件里面的</span><br><span class="line"><span class="built_in">Intersect</span>(Ray ray, BVH node) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ray misses node.bbox) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node is a leaf node)</span><br><span class="line">        test intersection with all objs;</span><br><span class="line">    	<span class="keyword">return</span> closest intersection;</span><br><span class="line">    </span><br><span class="line">    hit1 = <span class="built_in">Intersect</span>(ray, node.child1);</span><br><span class="line">    hit2 = <span class="built_in">Intersect</span>(ray, node.child2);</span><br><span class="line">    <span class="keyword">return</span> the closer of hit1, hit2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Games101/14/10.png"></p>
<h1 id="空间划分和物体划分"><a href="#空间划分和物体划分" class="headerlink" title="空间划分和物体划分"></a>空间划分和物体划分</h1><h3 id="空间划分（如KD-tree）"><a href="#空间划分（如KD-tree）" class="headerlink" title="空间划分（如KD-tree）"></a>空间划分（如KD-tree）</h3><ul>
<li>把空间划分成不重叠的区域。</li>
<li>一个物体可能被包含在多个区域中。</li>
</ul>
<h3 id="物体划分（如BVH）"><a href="#物体划分（如BVH）" class="headerlink" title="物体划分（如BVH）"></a>物体划分（如BVH）</h3><ul>
<li>把物体划分成不相交的子集。</li>
<li>每个子集的包围盒在空间上可能是重叠的。</li>
</ul>
<p><img src="/images/Games101/14/11.png"></p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43399489/article/details/121512582?spm=1001.2014.3001.5502">图形学笔记（十二）光线追踪2——使用AABB包围盒加速光线追踪、空间划分（八叉树、KD树、BSP树）、物体划分（BVH加速结构）、光线与物体求交_光线追踪算法遍历八叉树-CSDN博客</a></p>
<hr>
<p><strong>AI孙燕姿</strong> 真好听 hhh</p>
<p>等哪天闲了也来研究研究这东西。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="FJBQ"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">FJBQ</p>
  <div class="site-description" itemprop="description">坚定 坚持 坚强</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-10 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FJBQ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共52k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":225,"hOffset":-15,"vOffset":-15},"mobile":{"show":false},"react":{"opacity":1},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
